SVN-fs-dump-format-version: 2

UUID: c1f0c3e6-afc3-481e-9fe9-70870562832a

Revision-number: 0
Prop-content-length: 56
Content-length: 56

K 8
svn:date
V 27
2016-11-28T13:56:27.125610Z
PROPS-END

Revision-number: 1
Prop-content-length: 119
Content-length: 119

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-28T14:04:06.744000Z
K 7
svn:log
V 18
Directorio de tags
PROPS-END

Node-path: tags
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Revision-number: 2
Prop-content-length: 123
Content-length: 123

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-28T14:04:39.600000Z
K 7
svn:log
V 22
tronco del repositorio
PROPS-END

Node-path: trunk
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Revision-number: 3
Prop-content-length: 120
Content-length: 120

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-28T14:05:05.910000Z
K 7
svn:log
V 19
Directorio de ramas
PROPS-END

Node-path: branches
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Revision-number: 4
Prop-content-length: 100
Content-length: 100

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-28T14:05:35.264000Z
K 7
svn:log
V 0

PROPS-END

Node-path: trunk/sumatorio-cubo
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Revision-number: 5
Prop-content-length: 143
Content-length: 143

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-28T14:16:51.575000Z
K 7
svn:log
V 42
Directorio con el contenido de las paginas
PROPS-END

Node-path: trunk/sumatorio-cubo/WebContent
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Revision-number: 6
Prop-content-length: 130
Content-length: 130

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-28T14:18:42.599000Z
K 7
svn:log
V 29
cambio para mejorar el nombre
PROPS-END

Node-path: trunk/sumatoria-cubo
Node-kind: dir
Node-action: add
Node-copyfrom-rev: 5
Node-copyfrom-path: trunk/sumatorio-cubo


Node-path: trunk/sumatorio-cubo
Node-action: delete


Revision-number: 7
Prop-content-length: 137
Content-length: 137

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-28T14:19:56.958000Z
K 7
svn:log
V 36
Se agrega directorio de dependencias
PROPS-END

Node-path: trunk/sumatoria-cubo/WebContent/dependencias
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Revision-number: 8
Prop-content-length: 137
Content-length: 137

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-28T14:36:25.823143Z
K 7
svn:log
V 36
Se agregan primera version funcional
PROPS-END

Node-path: trunk/sumatoria-cubo/WebContent/dependencias/foundation.min.css
Node-kind: file
Node-action: add
Text-content-md5: 0ab0735c016c9d78b2217137b6a5fb87
Text-content-sha1: f26329b9137dc14bf5bd4e043257f2fb1dd5ecfa
Prop-content-length: 10
Text-content-length: 62577
Content-length: 62587

PROPS-END
@charset "UTF-8";
/*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:not-allowed}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}.foundation-mq{font-family:"small=0em&medium=40em&large=64em&xlarge=75em&xxlarge=90em"}html{font-size:100%;box-sizing:border-box}*,:after,:before{box-sizing:inherit}body{padding:0;margin:0;font-family:Helvetica Neue,Helvetica,Roboto,Arial,sans-serif;font-weight:400;line-height:1.5;color:#0a0a0a;background:#fefefe;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}img{max-width:100%;height:auto;-ms-interpolation-mode:bicubic;display:inline-block;vertical-align:middle}textarea{height:auto;min-height:50px;border-radius:0}select{width:100%;border-radius:0}#map_canvas embed,#map_canvas img,#map_canvas object,.map_canvas embed,.map_canvas img,.map_canvas object,.mqa-display embed,.mqa-display img,.mqa-display object{max-width:none!important}button{-webkit-appearance:none;-moz-appearance:none;background:transparent;padding:0;border:0;border-radius:0;line-height:1}[data-whatinput=mouse] button{outline:0}.is-visible{display:block!important}.is-hidden{display:none!important}.row{max-width:75rem;margin-left:auto;margin-right:auto}.row:after,.row:before{content:' ';display:table}.row:after{clear:both}.row.collapse>.column,.row.collapse>.columns{padding-left:0;padding-right:0}.row .row{max-width:none;margin-left:-.625rem;margin-right:-.625rem}@media screen and (min-width:40em){.row .row{margin-left:-.9375rem;margin-right:-.9375rem}}.row .row.collapse{margin-left:0;margin-right:0}.row.expanded{max-width:none}.row.expanded .row{margin-left:auto;margin-right:auto}.column,.columns{width:100%;float:left;padding-left:.625rem;padding-right:.625rem}@media screen and (min-width:40em){.column,.columns{padding-left:.9375rem;padding-right:.9375rem}}.column:last-child:not(:first-child),.columns:last-child:not(:first-child){float:right}.column.end:last-child:last-child,.end.columns:last-child:last-child{float:left}.column.row.row,.row.row.columns{float:none}.row .column.row.row,.row .row.row.columns{padding-left:0;padding-right:0;margin-left:0;margin-right:0}.small-1{width:8.33333%}.small-push-1{position:relative;left:8.33333%}.small-pull-1{position:relative;left:-8.33333%}.small-offset-0{margin-left:0}.small-2{width:16.66667%}.small-push-2{position:relative;left:16.66667%}.small-pull-2{position:relative;left:-16.66667%}.small-offset-1{margin-left:8.33333%}.small-3{width:25%}.small-push-3{position:relative;left:25%}.small-pull-3{position:relative;left:-25%}.small-offset-2{margin-left:16.66667%}.small-4{width:33.33333%}.small-push-4{position:relative;left:33.33333%}.small-pull-4{position:relative;left:-33.33333%}.small-offset-3{margin-left:25%}.small-5{width:41.66667%}.small-push-5{position:relative;left:41.66667%}.small-pull-5{position:relative;left:-41.66667%}.small-offset-4{margin-left:33.33333%}.small-6{width:50%}.small-push-6{position:relative;left:50%}.small-pull-6{position:relative;left:-50%}.small-offset-5{margin-left:41.66667%}.small-7{width:58.33333%}.small-push-7{position:relative;left:58.33333%}.small-pull-7{position:relative;left:-58.33333%}.small-offset-6{margin-left:50%}.small-8{width:66.66667%}.small-push-8{position:relative;left:66.66667%}.small-pull-8{position:relative;left:-66.66667%}.small-offset-7{margin-left:58.33333%}.small-9{width:75%}.small-push-9{position:relative;left:75%}.small-pull-9{position:relative;left:-75%}.small-offset-8{margin-left:66.66667%}.small-10{width:83.33333%}.small-push-10{position:relative;left:83.33333%}.small-pull-10{position:relative;left:-83.33333%}.small-offset-9{margin-left:75%}.small-11{width:91.66667%}.small-push-11{position:relative;left:91.66667%}.small-pull-11{position:relative;left:-91.66667%}.small-offset-10{margin-left:83.33333%}.small-12{width:100%}.small-offset-11{margin-left:91.66667%}.small-up-1>.column,.small-up-1>.columns{width:100%;float:left}.small-up-1>.column:nth-of-type(1n),.small-up-1>.columns:nth-of-type(1n){clear:none}.small-up-1>.column:nth-of-type(1n+1),.small-up-1>.columns:nth-of-type(1n+1){clear:both}.small-up-1>.column:last-child,.small-up-1>.columns:last-child{float:left}.small-up-2>.column,.small-up-2>.columns{width:50%;float:left}.small-up-2>.column:nth-of-type(1n),.small-up-2>.columns:nth-of-type(1n){clear:none}.small-up-2>.column:nth-of-type(2n+1),.small-up-2>.columns:nth-of-type(2n+1){clear:both}.small-up-2>.column:last-child,.small-up-2>.columns:last-child{float:left}.small-up-3>.column,.small-up-3>.columns{width:33.33333%;float:left}.small-up-3>.column:nth-of-type(1n),.small-up-3>.columns:nth-of-type(1n){clear:none}.small-up-3>.column:nth-of-type(3n+1),.small-up-3>.columns:nth-of-type(3n+1){clear:both}.small-up-3>.column:last-child,.small-up-3>.columns:last-child{float:left}.small-up-4>.column,.small-up-4>.columns{width:25%;float:left}.small-up-4>.column:nth-of-type(1n),.small-up-4>.columns:nth-of-type(1n){clear:none}.small-up-4>.column:nth-of-type(4n+1),.small-up-4>.columns:nth-of-type(4n+1){clear:both}.small-up-4>.column:last-child,.small-up-4>.columns:last-child{float:left}.small-up-5>.column,.small-up-5>.columns{width:20%;float:left}.small-up-5>.column:nth-of-type(1n),.small-up-5>.columns:nth-of-type(1n){clear:none}.small-up-5>.column:nth-of-type(5n+1),.small-up-5>.columns:nth-of-type(5n+1){clear:both}.small-up-5>.column:last-child,.small-up-5>.columns:last-child{float:left}.small-up-6>.column,.small-up-6>.columns{width:16.66667%;float:left}.small-up-6>.column:nth-of-type(1n),.small-up-6>.columns:nth-of-type(1n){clear:none}.small-up-6>.column:nth-of-type(6n+1),.small-up-6>.columns:nth-of-type(6n+1){clear:both}.small-up-6>.column:last-child,.small-up-6>.columns:last-child{float:left}.small-up-7>.column,.small-up-7>.columns{width:14.28571%;float:left}.small-up-7>.column:nth-of-type(1n),.small-up-7>.columns:nth-of-type(1n){clear:none}.small-up-7>.column:nth-of-type(7n+1),.small-up-7>.columns:nth-of-type(7n+1){clear:both}.small-up-7>.column:last-child,.small-up-7>.columns:last-child{float:left}.small-up-8>.column,.small-up-8>.columns{width:12.5%;float:left}.small-up-8>.column:nth-of-type(1n),.small-up-8>.columns:nth-of-type(1n){clear:none}.small-up-8>.column:nth-of-type(8n+1),.small-up-8>.columns:nth-of-type(8n+1){clear:both}.small-up-8>.column:last-child,.small-up-8>.columns:last-child{float:left}.small-collapse>.column,.small-collapse>.columns{padding-left:0;padding-right:0}.expanded.row .small-collapse.row,.small-collapse .row{margin-left:0;margin-right:0}.small-uncollapse>.column,.small-uncollapse>.columns{padding-left:.625rem;padding-right:.625rem}.small-centered{float:none;margin-left:auto;margin-right:auto}.small-pull-0,.small-push-0,.small-uncentered{position:static;margin-left:0;margin-right:0;float:left}@media screen and (min-width:40em){.medium-1{width:8.33333%}.medium-push-1{position:relative;left:8.33333%}.medium-pull-1{position:relative;left:-8.33333%}.medium-offset-0{margin-left:0}.medium-2{width:16.66667%}.medium-push-2{position:relative;left:16.66667%}.medium-pull-2{position:relative;left:-16.66667%}.medium-offset-1{margin-left:8.33333%}.medium-3{width:25%}.medium-push-3{position:relative;left:25%}.medium-pull-3{position:relative;left:-25%}.medium-offset-2{margin-left:16.66667%}.medium-4{width:33.33333%}.medium-push-4{position:relative;left:33.33333%}.medium-pull-4{position:relative;left:-33.33333%}.medium-offset-3{margin-left:25%}.medium-5{width:41.66667%}.medium-push-5{position:relative;left:41.66667%}.medium-pull-5{position:relative;left:-41.66667%}.medium-offset-4{margin-left:33.33333%}.medium-6{width:50%}.medium-push-6{position:relative;left:50%}.medium-pull-6{position:relative;left:-50%}.medium-offset-5{margin-left:41.66667%}.medium-7{width:58.33333%}.medium-push-7{position:relative;left:58.33333%}.medium-pull-7{position:relative;left:-58.33333%}.medium-offset-6{margin-left:50%}.medium-8{width:66.66667%}.medium-push-8{position:relative;left:66.66667%}.medium-pull-8{position:relative;left:-66.66667%}.medium-offset-7{margin-left:58.33333%}.medium-9{width:75%}.medium-push-9{position:relative;left:75%}.medium-pull-9{position:relative;left:-75%}.medium-offset-8{margin-left:66.66667%}.medium-10{width:83.33333%}.medium-push-10{position:relative;left:83.33333%}.medium-pull-10{position:relative;left:-83.33333%}.medium-offset-9{margin-left:75%}.medium-11{width:91.66667%}.medium-push-11{position:relative;left:91.66667%}.medium-pull-11{position:relative;left:-91.66667%}.medium-offset-10{margin-left:83.33333%}.medium-12{width:100%}.medium-offset-11{margin-left:91.66667%}.medium-up-1>.column,.medium-up-1>.columns{width:100%;float:left}.medium-up-1>.column:nth-of-type(1n),.medium-up-1>.columns:nth-of-type(1n){clear:none}.medium-up-1>.column:nth-of-type(1n+1),.medium-up-1>.columns:nth-of-type(1n+1){clear:both}.medium-up-1>.column:last-child,.medium-up-1>.columns:last-child{float:left}.medium-up-2>.column,.medium-up-2>.columns{width:50%;float:left}.medium-up-2>.column:nth-of-type(1n),.medium-up-2>.columns:nth-of-type(1n){clear:none}.medium-up-2>.column:nth-of-type(2n+1),.medium-up-2>.columns:nth-of-type(2n+1){clear:both}.medium-up-2>.column:last-child,.medium-up-2>.columns:last-child{float:left}.medium-up-3>.column,.medium-up-3>.columns{width:33.33333%;float:left}.medium-up-3>.column:nth-of-type(1n),.medium-up-3>.columns:nth-of-type(1n){clear:none}.medium-up-3>.column:nth-of-type(3n+1),.medium-up-3>.columns:nth-of-type(3n+1){clear:both}.medium-up-3>.column:last-child,.medium-up-3>.columns:last-child{float:left}.medium-up-4>.column,.medium-up-4>.columns{width:25%;float:left}.medium-up-4>.column:nth-of-type(1n),.medium-up-4>.columns:nth-of-type(1n){clear:none}.medium-up-4>.column:nth-of-type(4n+1),.medium-up-4>.columns:nth-of-type(4n+1){clear:both}.medium-up-4>.column:last-child,.medium-up-4>.columns:last-child{float:left}.medium-up-5>.column,.medium-up-5>.columns{width:20%;float:left}.medium-up-5>.column:nth-of-type(1n),.medium-up-5>.columns:nth-of-type(1n){clear:none}.medium-up-5>.column:nth-of-type(5n+1),.medium-up-5>.columns:nth-of-type(5n+1){clear:both}.medium-up-5>.column:last-child,.medium-up-5>.columns:last-child{float:left}.medium-up-6>.column,.medium-up-6>.columns{width:16.66667%;float:left}.medium-up-6>.column:nth-of-type(1n),.medium-up-6>.columns:nth-of-type(1n){clear:none}.medium-up-6>.column:nth-of-type(6n+1),.medium-up-6>.columns:nth-of-type(6n+1){clear:both}.medium-up-6>.column:last-child,.medium-up-6>.columns:last-child{float:left}.medium-up-7>.column,.medium-up-7>.columns{width:14.28571%;float:left}.medium-up-7>.column:nth-of-type(1n),.medium-up-7>.columns:nth-of-type(1n){clear:none}.medium-up-7>.column:nth-of-type(7n+1),.medium-up-7>.columns:nth-of-type(7n+1){clear:both}.medium-up-7>.column:last-child,.medium-up-7>.columns:last-child{float:left}.medium-up-8>.column,.medium-up-8>.columns{width:12.5%;float:left}.medium-up-8>.column:nth-of-type(1n),.medium-up-8>.columns:nth-of-type(1n){clear:none}.medium-up-8>.column:nth-of-type(8n+1),.medium-up-8>.columns:nth-of-type(8n+1){clear:both}.medium-up-8>.column:last-child,.medium-up-8>.columns:last-child{float:left}.medium-collapse>.column,.medium-collapse>.columns{padding-left:0;padding-right:0}.expanded.row .medium-collapse.row,.medium-collapse .row{margin-left:0;margin-right:0}.medium-uncollapse>.column,.medium-uncollapse>.columns{padding-left:.9375rem;padding-right:.9375rem}.medium-centered{float:none;margin-left:auto;margin-right:auto}.medium-pull-0,.medium-push-0,.medium-uncentered{position:static;margin-left:0;margin-right:0;float:left}}@media screen and (min-width:64em){.large-1{width:8.33333%}.large-push-1{position:relative;left:8.33333%}.large-pull-1{position:relative;left:-8.33333%}.large-offset-0{margin-left:0}.large-2{width:16.66667%}.large-push-2{position:relative;left:16.66667%}.large-pull-2{position:relative;left:-16.66667%}.large-offset-1{margin-left:8.33333%}.large-3{width:25%}.large-push-3{position:relative;left:25%}.large-pull-3{position:relative;left:-25%}.large-offset-2{margin-left:16.66667%}.large-4{width:33.33333%}.large-push-4{position:relative;left:33.33333%}.large-pull-4{position:relative;left:-33.33333%}.large-offset-3{margin-left:25%}.large-5{width:41.66667%}.large-push-5{position:relative;left:41.66667%}.large-pull-5{position:relative;left:-41.66667%}.large-offset-4{margin-left:33.33333%}.large-6{width:50%}.large-push-6{position:relative;left:50%}.large-pull-6{position:relative;left:-50%}.large-offset-5{margin-left:41.66667%}.large-7{width:58.33333%}.large-push-7{position:relative;left:58.33333%}.large-pull-7{position:relative;left:-58.33333%}.large-offset-6{margin-left:50%}.large-8{width:66.66667%}.large-push-8{position:relative;left:66.66667%}.large-pull-8{position:relative;left:-66.66667%}.large-offset-7{margin-left:58.33333%}.large-9{width:75%}.large-push-9{position:relative;left:75%}.large-pull-9{position:relative;left:-75%}.large-offset-8{margin-left:66.66667%}.large-10{width:83.33333%}.large-push-10{position:relative;left:83.33333%}.large-pull-10{position:relative;left:-83.33333%}.large-offset-9{margin-left:75%}.large-11{width:91.66667%}.large-push-11{position:relative;left:91.66667%}.large-pull-11{position:relative;left:-91.66667%}.large-offset-10{margin-left:83.33333%}.large-12{width:100%}.large-offset-11{margin-left:91.66667%}.large-up-1>.column,.large-up-1>.columns{width:100%;float:left}.large-up-1>.column:nth-of-type(1n),.large-up-1>.columns:nth-of-type(1n){clear:none}.large-up-1>.column:nth-of-type(1n+1),.large-up-1>.columns:nth-of-type(1n+1){clear:both}.large-up-1>.column:last-child,.large-up-1>.columns:last-child{float:left}.large-up-2>.column,.large-up-2>.columns{width:50%;float:left}.large-up-2>.column:nth-of-type(1n),.large-up-2>.columns:nth-of-type(1n){clear:none}.large-up-2>.column:nth-of-type(2n+1),.large-up-2>.columns:nth-of-type(2n+1){clear:both}.large-up-2>.column:last-child,.large-up-2>.columns:last-child{float:left}.large-up-3>.column,.large-up-3>.columns{width:33.33333%;float:left}.large-up-3>.column:nth-of-type(1n),.large-up-3>.columns:nth-of-type(1n){clear:none}.large-up-3>.column:nth-of-type(3n+1),.large-up-3>.columns:nth-of-type(3n+1){clear:both}.large-up-3>.column:last-child,.large-up-3>.columns:last-child{float:left}.large-up-4>.column,.large-up-4>.columns{width:25%;float:left}.large-up-4>.column:nth-of-type(1n),.large-up-4>.columns:nth-of-type(1n){clear:none}.large-up-4>.column:nth-of-type(4n+1),.large-up-4>.columns:nth-of-type(4n+1){clear:both}.large-up-4>.column:last-child,.large-up-4>.columns:last-child{float:left}.large-up-5>.column,.large-up-5>.columns{width:20%;float:left}.large-up-5>.column:nth-of-type(1n),.large-up-5>.columns:nth-of-type(1n){clear:none}.large-up-5>.column:nth-of-type(5n+1),.large-up-5>.columns:nth-of-type(5n+1){clear:both}.large-up-5>.column:last-child,.large-up-5>.columns:last-child{float:left}.large-up-6>.column,.large-up-6>.columns{width:16.66667%;float:left}.large-up-6>.column:nth-of-type(1n),.large-up-6>.columns:nth-of-type(1n){clear:none}.large-up-6>.column:nth-of-type(6n+1),.large-up-6>.columns:nth-of-type(6n+1){clear:both}.large-up-6>.column:last-child,.large-up-6>.columns:last-child{float:left}.large-up-7>.column,.large-up-7>.columns{width:14.28571%;float:left}.large-up-7>.column:nth-of-type(1n),.large-up-7>.columns:nth-of-type(1n){clear:none}.large-up-7>.column:nth-of-type(7n+1),.large-up-7>.columns:nth-of-type(7n+1){clear:both}.large-up-7>.column:last-child,.large-up-7>.columns:last-child{float:left}.large-up-8>.column,.large-up-8>.columns{width:12.5%;float:left}.large-up-8>.column:nth-of-type(1n),.large-up-8>.columns:nth-of-type(1n){clear:none}.large-up-8>.column:nth-of-type(8n+1),.large-up-8>.columns:nth-of-type(8n+1){clear:both}.large-up-8>.column:last-child,.large-up-8>.columns:last-child{float:left}.large-collapse>.column,.large-collapse>.columns{padding-left:0;padding-right:0}.expanded.row .large-collapse.row,.large-collapse .row{margin-left:0;margin-right:0}.large-uncollapse>.column,.large-uncollapse>.columns{padding-left:.9375rem;padding-right:.9375rem}.large-centered{float:none;margin-left:auto;margin-right:auto}.large-pull-0,.large-push-0,.large-uncentered{position:static;margin-left:0;margin-right:0;float:left}}blockquote,dd,div,dl,dt,form,h1,h2,h3,h4,h5,h6,li,ol,p,pre,td,th,ul{margin:0;padding:0}p{font-size:inherit;line-height:1.6;margin-bottom:1rem;text-rendering:optimizeLegibility}em,i{font-style:italic}b,em,i,strong{line-height:inherit}b,strong{font-weight:700}small{font-size:80%;line-height:inherit}h1,h2,h3,h4,h5,h6{font-family:Helvetica Neue,Helvetica,Roboto,Arial,sans-serif;font-weight:400;font-style:normal;color:inherit;text-rendering:optimizeLegibility;margin-top:0;margin-bottom:.5rem;line-height:1.4}h1 small,h2 small,h3 small,h4 small,h5 small,h6 small{color:#cacaca;line-height:0}h1{font-size:1.5rem}h2{font-size:1.25rem}h3{font-size:1.1875rem}h4{font-size:1.125rem}h5{font-size:1.0625rem}h6{font-size:1rem}@media screen and (min-width:40em){h1{font-size:3rem}h2{font-size:2.5rem}h3{font-size:1.9375rem}h4{font-size:1.5625rem}h5{font-size:1.25rem}h6{font-size:1rem}}a{color:#2199e8;text-decoration:none;line-height:inherit;cursor:pointer}a:focus,a:hover{color:#1585cf}a img{border:0}hr{max-width:75rem;height:0;border-right:0;border-top:0;border-bottom:1px solid #cacaca;border-left:0;margin:1.25rem auto;clear:both}dl,ol,ul{line-height:1.6;margin-bottom:1rem;list-style-position:outside}li{font-size:inherit}ul{list-style-type:disc}ol,ul{margin-left:1.25rem}ol ol,ol ul,ul ol,ul ul{margin-left:1.25rem;margin-bottom:0}dl{margin-bottom:1rem}dl dt{margin-bottom:.3rem;font-weight:700}blockquote{margin:0 0 1rem;padding:.5625rem 1.25rem 0 1.1875rem;border-left:1px solid #cacaca}blockquote,blockquote p{line-height:1.6;color:#8a8a8a}cite{display:block;font-size:.8125rem;color:#8a8a8a}cite:before{content:'\2014 \0020'}abbr{color:#0a0a0a;cursor:help;border-bottom:1px dotted #0a0a0a}code{font-weight:400;border:1px solid #cacaca;padding:.125rem .3125rem .0625rem}code,kbd{font-family:Consolas,Liberation Mono,Courier,monospace;color:#0a0a0a;background-color:#e6e6e6}kbd{padding:.125rem .25rem 0;margin:0}.subheader{margin-top:.2rem;margin-bottom:.5rem;font-weight:400;line-height:1.4;color:#8a8a8a}.lead{font-size:125%;line-height:1.6}.stat{font-size:2.5rem;line-height:1}p+.stat{margin-top:-1rem}.no-bullet{margin-left:0;list-style:none}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}.text-justify{text-align:justify}@media screen and (min-width:40em){.medium-text-left{text-align:left}.medium-text-right{text-align:right}.medium-text-center{text-align:center}.medium-text-justify{text-align:justify}}@media screen and (min-width:64em){.large-text-left{text-align:left}.large-text-right{text-align:right}.large-text-center{text-align:center}.large-text-justify{text-align:justify}}.show-for-print{display:none!important}@media print{*{background:transparent!important;color:#000!important;box-shadow:none!important;text-shadow:none!important}.show-for-print{display:block!important}.hide-for-print{display:none!important}table.show-for-print{display:table!important}thead.show-for-print{display:table-header-group!important}tbody.show-for-print{display:table-row-group!important}tr.show-for-print{display:table-row!important}td.show-for-print,th.show-for-print{display:table-cell!important}a,a:visited{text-decoration:underline}a[href]:after{content:" (" attr(href) ")"}.ir a:after,a[href^='#']:after,a[href^='javascript:']:after{content:''}abbr[title]:after{content:" (" attr(title) ")"}blockquote,pre{border:1px solid #8a8a8a;page-break-inside:avoid}thead{display:table-header-group}img,tr{page-break-inside:avoid}img{max-width:100%!important}@page{margin:.5cm}h2,h3,p{orphans:3;widows:3}h2,h3{page-break-after:avoid}}[type=color],[type=date],[type=datetime-local],[type=datetime],[type=email],[type=month],[type=number],[type=password],[type=search],[type=tel],[type=text],[type=time],[type=url],[type=week],textarea{display:block;box-sizing:border-box;width:100%;height:2.4375rem;padding:.5rem;border:1px solid #cacaca;margin:0 0 1rem;font-family:inherit;font-size:1rem;color:#0a0a0a;background-color:#fefefe;box-shadow:inset 0 1px 2px hsla(0,0%,4%,.1);border-radius:0;-webkit-transition:-webkit-box-shadow .5s,border-color .25s ease-in-out;transition:box-shadow .5s,border-color .25s ease-in-out;-webkit-appearance:none;-moz-appearance:none}[type=color]:focus,[type=date]:focus,[type=datetime-local]:focus,[type=datetime]:focus,[type=email]:focus,[type=month]:focus,[type=number]:focus,[type=password]:focus,[type=search]:focus,[type=tel]:focus,[type=text]:focus,[type=time]:focus,[type=url]:focus,[type=week]:focus,textarea:focus{border:1px solid #8a8a8a;background-color:#fefefe;outline:none;box-shadow:0 0 5px #cacaca;-webkit-transition:-webkit-box-shadow .5s,border-color .25s ease-in-out;transition:box-shadow .5s,border-color .25s ease-in-out}textarea{max-width:100%}textarea[rows]{height:auto}input::-webkit-input-placeholder,textarea::-webkit-input-placeholder{color:#cacaca}input::-moz-placeholder,textarea::-moz-placeholder{color:#cacaca}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:#cacaca}input::placeholder,textarea::placeholder{color:#cacaca}input:disabled,input[readonly],textarea:disabled,textarea[readonly]{background-color:#e6e6e6;cursor:not-allowed}[type=button],[type=submit]{border-radius:0;-webkit-appearance:none;-moz-appearance:none}input[type=search]{box-sizing:border-box}[type=checkbox],[type=file],[type=radio]{margin:0 0 1rem}[type=checkbox]+label,[type=radio]+label{display:inline-block;margin-left:.5rem;margin-right:1rem;margin-bottom:0;vertical-align:baseline}[type=checkbox]+label[for],[type=radio]+label[for]{cursor:pointer}label>[type=checkbox],label>[type=radio]{margin-right:.5rem}[type=file]{width:100%}label{display:block;margin:0;font-size:.875rem;font-weight:400;line-height:1.8;color:#0a0a0a}label.middle{margin:0 0 1rem;padding:.5625rem 0}.help-text{margin-top:-.5rem;font-size:.8125rem;font-style:italic;color:#0a0a0a}.input-group{display:table;width:100%;margin-bottom:1rem}.input-group>:first-child,.input-group>:last-child>*{border-radius:0 0 0 0}.input-group-button,.input-group-field,.input-group-label{margin:0;white-space:nowrap;display:table-cell;vertical-align:middle}.input-group-label{text-align:center;padding:0 1rem;background:#e6e6e6;color:#0a0a0a;border:1px solid #cacaca;white-space:nowrap;width:1%;height:100%}.input-group-label:first-child{border-right:0}.input-group-label:last-child{border-left:0}.input-group-field{border-radius:0;height:2.5rem}.input-group-button{padding-top:0;padding-bottom:0;text-align:center;height:100%;width:1%}.input-group-button a,.input-group-button button,.input-group-button input{margin:0}.input-group .input-group-button{display:table-cell}fieldset{border:0;padding:0;margin:0}legend{margin-bottom:.5rem;max-width:100%}.fieldset{border:1px solid #cacaca;padding:1.25rem;margin:1.125rem 0}.fieldset legend{background:#fefefe;padding:0 .1875rem;margin:0;margin-left:-.1875rem}select{height:2.4375rem;padding:.5rem;border:1px solid #cacaca;margin:0 0 1rem;font-size:1rem;font-family:inherit;line-height:normal;color:#0a0a0a;background-color:#fefefe;border-radius:0;-webkit-appearance:none;-moz-appearance:none;background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' width='32' height='24' viewBox='0 0 32 24'><polygon points='0,0 32,0 16,24' style='fill: rgb%28138, 138, 138%29'></polygon></svg>");background-size:9px 6px;background-position:right -1rem center;background-origin:content-box;background-repeat:no-repeat;padding-right:1.5rem}@media screen and (min-width:0\0){select{background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAYCAYAAACbU/80AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAIpJREFUeNrEkckNgDAMBBfRkEt0ObRBBdsGXUDgmQfK4XhH2m8czQAAy27R3tsw4Qfe2x8uOO6oYLb6GlOor3GF+swURAOmUJ+RwtEJs9WvTGEYxBXqI1MQAZhCfUQKRzDMVj+TwrAIV6jvSUEkYAr1LSkcyTBb/V+KYfX7xAeusq3sLDtGH3kEGACPWIflNZfhRQAAAABJRU5ErkJggg==")}}select:disabled{background-color:#e6e6e6;cursor:not-allowed}select::-ms-expand{display:none}select[multiple]{height:auto;background-image:none}.is-invalid-input:not(:focus){background-color:rgba(236,88,64,.1);border-color:#ec5840}.form-error,.is-invalid-label{color:#ec5840}.form-error{display:none;margin-top:-.5rem;margin-bottom:1rem;font-size:.75rem;font-weight:700}.form-error.is-visible{display:block}.button{display:inline-block;text-align:center;line-height:1;cursor:pointer;-webkit-appearance:none;-webkit-transition:background-color .25s ease-out,color .25s ease-out;transition:background-color .25s ease-out,color .25s ease-out;vertical-align:middle;border:1px solid transparent;border-radius:0;padding:.85em 1em;margin:0 0 1rem;font-size:.9rem;background-color:#2199e8;color:#fefefe}[data-whatinput=mouse] .button{outline:0}.button:focus,.button:hover{background-color:#1583cc;color:#fefefe}.button.tiny{font-size:.6rem}.button.small{font-size:.75rem}.button.large{font-size:1.25rem}.button.expanded{display:block;width:100%;margin-left:0;margin-right:0}.button.primary{background-color:#2199e8;color:#fefefe}.button.primary:focus,.button.primary:hover{background-color:#147cc0;color:#fefefe}.button.secondary{background-color:#777;color:#fefefe}.button.secondary:focus,.button.secondary:hover{background-color:#5f5f5f;color:#fefefe}.button.success{background-color:#3adb76;color:#fefefe}.button.success:focus,.button.success:hover{background-color:#22bb5b;color:#fefefe}.button.warning{background-color:#ffae00;color:#fefefe}.button.warning:focus,.button.warning:hover{background-color:#cc8b00;color:#fefefe}.button.alert{background-color:#ec5840;color:#fefefe}.button.alert:focus,.button.alert:hover{background-color:#da3116;color:#fefefe}.button.hollow{border:1px solid #2199e8;color:#2199e8}.button.hollow,.button.hollow:focus,.button.hollow:hover{background-color:transparent}.button.hollow:focus,.button.hollow:hover{border-color:#0c4d78;color:#0c4d78}.button.hollow.primary{border:1px solid #2199e8;color:#2199e8}.button.hollow.primary:focus,.button.hollow.primary:hover{border-color:#0c4d78;color:#0c4d78}.button.hollow.secondary{border:1px solid #777;color:#777}.button.hollow.secondary:focus,.button.hollow.secondary:hover{border-color:#3c3c3c;color:#3c3c3c}.button.hollow.success{border:1px solid #3adb76;color:#3adb76}.button.hollow.success:focus,.button.hollow.success:hover{border-color:#157539;color:#157539}.button.hollow.warning{border:1px solid #ffae00;color:#ffae00}.button.hollow.warning:focus,.button.hollow.warning:hover{border-color:#805700;color:#805700}.button.hollow.alert{border:1px solid #ec5840;color:#ec5840}.button.hollow.alert:focus,.button.hollow.alert:hover{border-color:#881f0e;color:#881f0e}.button.disabled,.button[disabled]{opacity:.25;cursor:not-allowed}.button.disabled:focus,.button.disabled:hover,.button[disabled]:focus,.button[disabled]:hover{background-color:#2199e8;color:#fefefe}.button.dropdown:after{content:'';display:block;width:0;height:0;border:.4em inset;border-color:#fefefe transparent transparent;border-top-style:solid;border-bottom-width:0;position:relative;top:.4em;float:right;margin-left:1em;display:inline-block}.button.arrow-only:after{margin-left:0;float:none;top:-.1em}.accordion{list-style-type:none;background:#fefefe;margin-left:0}.accordion-item:first-child>:first-child,.accordion-item:last-child>:last-child{border-radius:0 0 0 0}.accordion-title{display:block;padding:1.25rem 1rem;line-height:1;font-size:.75rem;color:#2199e8;position:relative;border:1px solid #e6e6e6;border-bottom:0}:last-child:not(.is-active)>.accordion-title{border-radius:0 0 0 0;border-bottom:1px solid #e6e6e6}.accordion-title:focus,.accordion-title:hover{background-color:#e6e6e6}.accordion-title:before{content:'+';position:absolute;right:1rem;top:50%;margin-top:-.5rem}.is-active>.accordion-title:before{content:'â€“'}.accordion-content{padding:1rem;display:none;border:1px solid #e6e6e6;border-bottom:0;background-color:#fefefe;color:#0a0a0a}:last-child>.accordion-content:last-child{border-bottom:1px solid #e6e6e6}.is-accordion-submenu-parent>a{position:relative}.is-accordion-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:6px inset;border-color:#2199e8 transparent transparent;border-top-style:solid;border-bottom-width:0;position:absolute;top:50%;margin-top:-4px;right:1rem}.is-accordion-submenu-parent[aria-expanded=true]>a:after{-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-transform:scaleY(-1);transform:scaleY(-1)}.badge{display:inline-block;padding:.3em;min-width:2.1em;font-size:.6rem;text-align:center;border-radius:50%;background:#2199e8;color:#fefefe}.badge.secondary{background:#777;color:#fefefe}.badge.success{background:#3adb76;color:#fefefe}.badge.warning{background:#ffae00;color:#fefefe}.badge.alert{background:#ec5840;color:#fefefe}.breadcrumbs{list-style:none;margin:0 0 1rem}.breadcrumbs:after,.breadcrumbs:before{content:' ';display:table}.breadcrumbs:after{clear:both}.breadcrumbs li{float:left;color:#0a0a0a;font-size:.6875rem;cursor:default;text-transform:uppercase}.breadcrumbs li:not(:last-child):after{color:#cacaca;content:"/";margin:0 .75rem;position:relative;top:1px;opacity:1}.breadcrumbs a{color:#2199e8}.breadcrumbs a:hover{text-decoration:underline}.breadcrumbs .disabled{color:#cacaca;cursor:not-allowed}.button-group{margin-bottom:1rem;font-size:0}.button-group:after,.button-group:before{content:' ';display:table}.button-group:after{clear:both}.button-group .button{margin:0;margin-right:1px;margin-bottom:1px;font-size:.9rem}.button-group .button:last-child{margin-right:0}.button-group.tiny .button{font-size:.6rem}.button-group.small .button{font-size:.75rem}.button-group.large .button{font-size:1.25rem}.button-group.expanded{margin-right:-1px}.button-group.expanded:after,.button-group.expanded:before{display:none}.button-group.expanded .button:first-child:nth-last-child(2),.button-group.expanded .button:first-child:nth-last-child(2):first-child:nth-last-child(2)~.button{display:inline-block;width:calc(50% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(2):first-child:nth-last-child(2)~.button:last-child,.button-group.expanded .button:first-child:nth-last-child(2):last-child{margin-right:-6px}.button-group.expanded .button:first-child:nth-last-child(3),.button-group.expanded .button:first-child:nth-last-child(3):first-child:nth-last-child(3)~.button{display:inline-block;width:calc(33.33333% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(3):first-child:nth-last-child(3)~.button:last-child,.button-group.expanded .button:first-child:nth-last-child(3):last-child{margin-right:-6px}.button-group.expanded .button:first-child:nth-last-child(4),.button-group.expanded .button:first-child:nth-last-child(4):first-child:nth-last-child(4)~.button{display:inline-block;width:calc(25% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(4):first-child:nth-last-child(4)~.button:last-child,.button-group.expanded .button:first-child:nth-last-child(4):last-child{margin-right:-6px}.button-group.expanded .button:first-child:nth-last-child(5),.button-group.expanded .button:first-child:nth-last-child(5):first-child:nth-last-child(5)~.button{display:inline-block;width:calc(20% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(5):first-child:nth-last-child(5)~.button:last-child,.button-group.expanded .button:first-child:nth-last-child(5):last-child{margin-right:-6px}.button-group.expanded .button:first-child:nth-last-child(6),.button-group.expanded .button:first-child:nth-last-child(6):first-child:nth-last-child(6)~.button{display:inline-block;width:calc(16.66667% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(6):first-child:nth-last-child(6)~.button:last-child,.button-group.expanded .button:first-child:nth-last-child(6):last-child{margin-right:-6px}.button-group.primary .button{background-color:#2199e8;color:#fefefe}.button-group.primary .button:focus,.button-group.primary .button:hover{background-color:#147cc0;color:#fefefe}.button-group.secondary .button{background-color:#777;color:#fefefe}.button-group.secondary .button:focus,.button-group.secondary .button:hover{background-color:#5f5f5f;color:#fefefe}.button-group.success .button{background-color:#3adb76;color:#fefefe}.button-group.success .button:focus,.button-group.success .button:hover{background-color:#22bb5b;color:#fefefe}.button-group.warning .button{background-color:#ffae00;color:#fefefe}.button-group.warning .button:focus,.button-group.warning .button:hover{background-color:#cc8b00;color:#fefefe}.button-group.alert .button{background-color:#ec5840;color:#fefefe}.button-group.alert .button:focus,.button-group.alert .button:hover{background-color:#da3116;color:#fefefe}.button-group.stacked-for-medium .button,.button-group.stacked-for-small .button,.button-group.stacked .button{width:100%}.button-group.stacked-for-medium .button:last-child,.button-group.stacked-for-small .button:last-child,.button-group.stacked .button:last-child{margin-bottom:0}@media screen and (min-width:40em){.button-group.stacked-for-small .button{width:auto;margin-bottom:0}}@media screen and (min-width:64em){.button-group.stacked-for-medium .button{width:auto;margin-bottom:0}}@media screen and (max-width:39.9375em){.button-group.stacked-for-small.expanded{display:block}.button-group.stacked-for-small.expanded .button{display:block;margin-right:0}}.callout{margin:0 0 1rem;padding:1rem;border:1px solid hsla(0,0%,4%,.25);border-radius:0;position:relative;color:#0a0a0a;background-color:#fff}.callout>:first-child{margin-top:0}.callout>:last-child{margin-bottom:0}.callout.primary{background-color:#def0fc}.callout.secondary{background-color:#ebebeb}.callout.success{background-color:#e1faea}.callout.warning{background-color:#fff3d9}.callout.alert{background-color:#fce6e2}.callout.small{padding:.5rem}.callout.large{padding:3rem}.close-button{position:absolute;color:#8a8a8a;right:1rem;top:.5rem;font-size:2em;line-height:1;cursor:pointer}[data-whatinput=mouse] .close-button{outline:0}.close-button:focus,.close-button:hover{color:#0a0a0a}.menu{margin:0;list-style-type:none}.menu>li{display:table-cell;vertical-align:middle}[data-whatinput=mouse] .menu>li{outline:0}.menu>li>a{display:block;padding:.7rem 1rem;line-height:1}.menu a,.menu button,.menu input{margin-bottom:0}.menu>li>a i,.menu>li>a i+span,.menu>li>a img,.menu>li>a img+span,.menu>li>a svg,.menu>li>a svg+span{vertical-align:middle}.menu>li>a i,.menu>li>a img,.menu>li>a svg{margin-right:.25rem;display:inline-block}.menu>li{display:table-cell}.menu.vertical>li{display:block}@media screen and (min-width:40em){.menu.medium-horizontal>li{display:table-cell}.menu.medium-vertical>li{display:block}}@media screen and (min-width:64em){.menu.large-horizontal>li{display:table-cell}.menu.large-vertical>li{display:block}}.menu.simple li{line-height:1;display:inline-block;margin-right:1rem}.menu.simple a{padding:0}.menu.align-right:after,.menu.align-right:before{content:' ';display:table}.menu.align-right:after{clear:both}.menu.align-right>li{float:right}.menu.expanded{width:100%;display:table;table-layout:fixed}.menu.expanded>li:first-child:last-child{width:100%}.menu.icon-top>li>a{text-align:center}.menu.icon-top>li>a i,.menu.icon-top>li>a img,.menu.icon-top>li>a svg{display:block;margin:0 auto .25rem}.menu.nested{margin-left:1rem}.menu .active>a{color:#fefefe;background:#2199e8}.menu-text{font-weight:700;color:inherit;line-height:1;padding-top:0;padding-bottom:0;padding:.7rem 1rem}.menu-centered{text-align:center}.menu-centered>.menu{display:inline-block}.no-js [data-responsive-menu] ul{display:none}.menu-icon{position:relative;display:inline-block;vertical-align:middle;cursor:pointer;width:20px;height:16px}.menu-icon:after{content:'';position:absolute;display:block;width:100%;height:2px;background:#fefefe;top:0;left:0;box-shadow:0 7px 0 #fefefe,0 14px 0 #fefefe}.menu-icon:hover:after{background:#cacaca;box-shadow:0 7px 0 #cacaca,0 14px 0 #cacaca}.is-drilldown{position:relative;overflow:hidden}.is-drilldown li{display:block!important}.is-drilldown-submenu{position:absolute;top:0;left:100%;z-index:-1;height:100%;width:100%;background:#fefefe;-webkit-transition:-webkit-transform .15s linear;transition:transform .15s linear}.is-drilldown-submenu.is-active{z-index:1;display:block;-webkit-transform:translateX(-100%);transform:translateX(-100%)}.is-drilldown-submenu.is-closing{-webkit-transform:translateX(100%);transform:translateX(100%)}.is-drilldown-submenu-parent>a{position:relative}.is-drilldown-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:6px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0;position:absolute;top:50%;margin-top:-6px;right:1rem}.js-drilldown-back>a:before{content:'';display:block;width:0;height:0;border:6px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0;display:inline-block;vertical-align:middle;margin-right:.75rem}.dropdown-pane{background-color:#fefefe;border:1px solid #cacaca;border-radius:0;display:block;font-size:1rem;padding:1rem;position:absolute;visibility:hidden;width:300px;z-index:10}.dropdown-pane.is-open{visibility:visible}.dropdown-pane.tiny{width:100px}.dropdown-pane.small{width:200px}.dropdown-pane.large{width:400px}.dropdown.menu>li.opens-left>.is-dropdown-submenu{left:auto;right:0;top:100%}.dropdown.menu>li.opens-right>.is-dropdown-submenu{right:auto;left:0;top:100%}.dropdown.menu>li.is-dropdown-submenu-parent>a{padding-right:1.5rem;position:relative}.dropdown.menu>li.is-dropdown-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:#2199e8 transparent transparent;border-top-style:solid;border-bottom-width:0;right:5px;margin-top:-2px}[data-whatinput=mouse] .dropdown.menu a{outline:0}.no-js .dropdown.menu ul{display:none}.dropdown.menu.vertical>li .is-dropdown-submenu{top:0}.dropdown.menu.vertical>li.opens-left>.is-dropdown-submenu{left:auto;right:100%}.dropdown.menu.vertical>li.opens-right>.is-dropdown-submenu{right:auto;left:100%}.dropdown.menu.vertical>li>a:after{right:14px;margin-top:-3px}.dropdown.menu.vertical>li.opens-left>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0}.dropdown.menu.vertical>li.opens-right>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0}@media screen and (min-width:40em){.dropdown.menu.medium-horizontal>li.opens-left>.is-dropdown-submenu{left:auto;right:0;top:100%}.dropdown.menu.medium-horizontal>li.opens-right>.is-dropdown-submenu{right:auto;left:0;top:100%}.dropdown.menu.medium-horizontal>li.is-dropdown-submenu-parent>a{padding-right:1.5rem;position:relative}.dropdown.menu.medium-horizontal>li.is-dropdown-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:#2199e8 transparent transparent;border-top-style:solid;border-bottom-width:0;right:5px;margin-top:-2px}.dropdown.menu.medium-vertical>li .is-dropdown-submenu{top:0}.dropdown.menu.medium-vertical>li.opens-left>.is-dropdown-submenu{left:auto;right:100%}.dropdown.menu.medium-vertical>li.opens-right>.is-dropdown-submenu{right:auto;left:100%}.dropdown.menu.medium-vertical>li>a:after{right:14px;margin-top:-3px}.dropdown.menu.medium-vertical>li.opens-left>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0}.dropdown.menu.medium-vertical>li.opens-right>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0}}@media screen and (min-width:64em){.dropdown.menu.large-horizontal>li.opens-left>.is-dropdown-submenu{left:auto;right:0;top:100%}.dropdown.menu.large-horizontal>li.opens-right>.is-dropdown-submenu{right:auto;left:0;top:100%}.dropdown.menu.large-horizontal>li.is-dropdown-submenu-parent>a{padding-right:1.5rem;position:relative}.dropdown.menu.large-horizontal>li.is-dropdown-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:#2199e8 transparent transparent;border-top-style:solid;border-bottom-width:0;right:5px;margin-top:-2px}.dropdown.menu.large-vertical>li .is-dropdown-submenu{top:0}.dropdown.menu.large-vertical>li.opens-left>.is-dropdown-submenu{left:auto;right:100%}.dropdown.menu.large-vertical>li.opens-right>.is-dropdown-submenu{right:auto;left:100%}.dropdown.menu.large-vertical>li>a:after{right:14px;margin-top:-3px}.dropdown.menu.large-vertical>li.opens-left>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0}.dropdown.menu.large-vertical>li.opens-right>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0}}.dropdown.menu.align-right .is-dropdown-submenu.first-sub{top:100%;left:auto;right:0}.is-dropdown-menu.vertical{width:100px}.is-dropdown-menu.vertical.align-right{float:right}.is-dropdown-submenu-parent{position:relative}.is-dropdown-submenu-parent a:after{position:absolute;top:50%;right:5px;margin-top:-2px}.is-dropdown-submenu-parent.opens-inner>.is-dropdown-submenu{top:100%;left:auto}.is-dropdown-submenu-parent.opens-left>.is-dropdown-submenu{left:auto;right:100%}.is-dropdown-submenu-parent.opens-right>.is-dropdown-submenu{right:auto;left:100%}.is-dropdown-submenu{display:none;position:absolute;top:0;left:100%;min-width:200px;z-index:1;background:#fefefe;border:1px solid #cacaca}.is-dropdown-submenu .is-dropdown-submenu-parent>a:after{right:14px;margin-top:-3px}.is-dropdown-submenu .is-dropdown-submenu-parent.opens-left>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0}.is-dropdown-submenu .is-dropdown-submenu-parent.opens-right>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0}.is-dropdown-submenu .is-dropdown-submenu{margin-top:-1px}.is-dropdown-submenu>li{width:100%}.is-dropdown-submenu.js-dropdown-active{display:block}.flex-video{position:relative;height:0;padding-bottom:75%;margin-bottom:1rem;overflow:hidden}.flex-video embed,.flex-video iframe,.flex-video object,.flex-video video{position:absolute;top:0;left:0;width:100%;height:100%}.flex-video.widescreen{padding-bottom:56.25%}.flex-video.vimeo{padding-top:0}.label{display:inline-block;padding:.33333rem .5rem;font-size:.8rem;line-height:1;white-space:nowrap;cursor:default;border-radius:0;background:#2199e8;color:#fefefe}.label.secondary{background:#777;color:#fefefe}.label.success{background:#3adb76;color:#fefefe}.label.warning{background:#ffae00;color:#fefefe}.label.alert{background:#ec5840;color:#fefefe}.media-object{margin-bottom:1rem;display:block}.media-object img{max-width:none}@media screen and (max-width:39.9375em){.media-object.stack-for-small .media-object-section{padding:0;padding-bottom:1rem;display:block}.media-object.stack-for-small .media-object-section img{width:100%}}.media-object-section{display:table-cell;vertical-align:top}.media-object-section:first-child{padding-right:1rem}.media-object-section:last-child:not(:nth-child(2)){padding-left:1rem}.media-object-section>:last-child{margin-bottom:0}.media-object-section.middle{vertical-align:middle}.media-object-section.bottom{vertical-align:bottom}body,html{height:100%}.off-canvas-wrapper{width:100%;overflow-x:hidden;position:relative;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-overflow-scrolling:auto}.off-canvas-wrapper-inner{position:relative;width:100%;-webkit-transition:-webkit-transform .5s ease;transition:transform .5s ease}.off-canvas-wrapper-inner:after,.off-canvas-wrapper-inner:before{content:' ';display:table}.off-canvas-wrapper-inner:after{clear:both}.off-canvas-content{min-height:100%;background:#fefefe;-webkit-transition:-webkit-transform .5s ease;transition:transform .5s ease;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;padding-bottom:.1px;box-shadow:0 0 10px hsla(0,0%,4%,.5)}.js-off-canvas-exit{display:none;position:absolute;top:0;left:0;width:100%;height:100%;background:hsla(0,0%,100%,.25);cursor:pointer;-webkit-transition:background .5s ease;transition:background .5s ease}.off-canvas{position:absolute;background:#e6e6e6;z-index:-1;max-height:100%;overflow-y:auto;-webkit-transform:translateX(0);transform:translateX(0)}[data-whatinput=mouse] .off-canvas{outline:0}.off-canvas.position-left{left:-250px;top:0;width:250px}.is-open-left{-webkit-transform:translateX(250px);transform:translateX(250px)}.off-canvas.position-right{right:-250px;top:0;width:250px}.is-open-right{-webkit-transform:translateX(-250px);transform:translateX(-250px)}@media screen and (min-width:40em){.position-left.reveal-for-medium{left:0;z-index:auto;position:fixed}.position-left.reveal-for-medium~.off-canvas-content{margin-left:250px}.position-right.reveal-for-medium{right:0;z-index:auto;position:fixed}.position-right.reveal-for-medium~.off-canvas-content{margin-right:250px}}@media screen and (min-width:64em){.position-left.reveal-for-large{left:0;z-index:auto;position:fixed}.position-left.reveal-for-large~.off-canvas-content{margin-left:250px}.position-right.reveal-for-large{right:0;z-index:auto;position:fixed}.position-right.reveal-for-large~.off-canvas-content{margin-right:250px}}.orbit,.orbit-container{position:relative}.orbit-container{margin:0;overflow:hidden;list-style:none}.orbit-slide{width:100%;max-height:100%}.orbit-slide.no-motionui.is-active{top:0;left:0}.orbit-figure{margin:0}.orbit-image{margin:0;width:100%;max-width:100%}.orbit-caption{bottom:0;width:100%;margin-bottom:0;background-color:hsla(0,0%,4%,.5)}.orbit-caption,.orbit-next,.orbit-previous{position:absolute;padding:1rem;color:#fefefe}.orbit-next,.orbit-previous{top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);z-index:10}[data-whatinput=mouse] .orbit-next,[data-whatinput=mouse] .orbit-previous{outline:0}.orbit-next:active,.orbit-next:focus,.orbit-next:hover,.orbit-previous:active,.orbit-previous:focus,.orbit-previous:hover{background-color:hsla(0,0%,4%,.5)}.orbit-previous{left:0}.orbit-next{left:auto;right:0}.orbit-bullets{position:relative;margin-top:.8rem;margin-bottom:.8rem;text-align:center}[data-whatinput=mouse] .orbit-bullets{outline:0}.orbit-bullets button{width:1.2rem;height:1.2rem;margin:.1rem;background-color:#cacaca;border-radius:50%}.orbit-bullets button.is-active,.orbit-bullets button:hover{background-color:#8a8a8a}.pagination{margin-left:0;margin-bottom:1rem}.pagination:after,.pagination:before{content:' ';display:table}.pagination:after{clear:both}.pagination li{font-size:.875rem;margin-right:.0625rem;border-radius:0;display:none}.pagination li:first-child,.pagination li:last-child{display:inline-block}@media screen and (min-width:40em){.pagination li{display:inline-block}}.pagination a,.pagination button{color:#0a0a0a;display:block;padding:.1875rem .625rem;border-radius:0}.pagination a:hover,.pagination button:hover{background:#e6e6e6}.pagination .current{padding:.1875rem .625rem;background:#2199e8;color:#fefefe;cursor:default}.pagination .disabled{padding:.1875rem .625rem;color:#cacaca;cursor:not-allowed}.pagination .disabled:hover{background:transparent}.pagination .ellipsis:after{content:'\2026';padding:.1875rem .625rem;color:#0a0a0a}.pagination-previous.disabled:before,.pagination-previous a:before{content:'\00ab';display:inline-block;margin-right:.5rem}.pagination-next.disabled:after,.pagination-next a:after{content:'\00bb';display:inline-block;margin-left:.5rem}.progress{background-color:#cacaca;height:1rem;margin-bottom:1rem;border-radius:0}.progress.primary .progress-meter{background-color:#2199e8}.progress.secondary .progress-meter{background-color:#777}.progress.success .progress-meter{background-color:#3adb76}.progress.warning .progress-meter{background-color:#ffae00}.progress.alert .progress-meter{background-color:#ec5840}.progress-meter{position:relative;display:block;width:0;height:100%;background-color:#2199e8}.progress-meter-text{top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);position:absolute;margin:0;font-size:.75rem;font-weight:700;color:#fefefe;white-space:nowrap}.slider{position:relative;height:.5rem;margin-top:1.25rem;margin-bottom:2.25rem;background-color:#e6e6e6;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-touch-action:none;touch-action:none}.slider-fill{position:absolute;top:0;left:0;display:inline-block;max-width:100%;height:.5rem;background-color:#cacaca;-webkit-transition:all .2s ease-in-out;transition:all .2s ease-in-out}.slider-fill.is-dragging{-webkit-transition:all 0s linear;transition:all 0s linear}.slider-handle{top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);position:absolute;left:0;z-index:1;display:inline-block;width:1.4rem;height:1.4rem;background-color:#2199e8;-webkit-transition:all .2s ease-in-out;transition:all .2s ease-in-out;-ms-touch-action:manipulation;touch-action:manipulation;border-radius:0}[data-whatinput=mouse] .slider-handle{outline:0}.slider-handle:hover{background-color:#1583cc}.slider-handle.is-dragging{-webkit-transition:all 0s linear;transition:all 0s linear}.slider.disabled,.slider[disabled]{opacity:.25;cursor:not-allowed}.slider.vertical{display:inline-block;width:.5rem;height:12.5rem;margin:0 1.25rem;-webkit-transform:scaleY(-1);transform:scaleY(-1)}.slider.vertical .slider-fill{top:0;width:.5rem;max-height:100%}.slider.vertical .slider-handle{position:absolute;top:0;left:50%;width:1.4rem;height:1.4rem;-webkit-transform:translateX(-50%);transform:translateX(-50%)}.sticky-container{position:relative}.sticky{position:absolute;z-index:0;-webkit-transform:translateZ(0);transform:translateZ(0)}.sticky.is-stuck{position:fixed;z-index:5}.sticky.is-stuck.is-at-top{top:0}.sticky.is-stuck.is-at-bottom{bottom:0}.sticky.is-anchored{position:absolute;left:auto;right:auto}.sticky.is-anchored.is-at-bottom{bottom:0}body.is-reveal-open{overflow:hidden}html.is-reveal-open,html.is-reveal-open body{height:100%;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.reveal-overlay{display:none;position:fixed;top:0;bottom:0;left:0;right:0;z-index:1005;background-color:hsla(0,0%,4%,.45);overflow-y:scroll}.reveal{display:none;z-index:1006;padding:1rem;border:1px solid #cacaca;background-color:#fefefe;border-radius:0;position:relative;top:100px;margin-left:auto;margin-right:auto;overflow-y:auto}[data-whatinput=mouse] .reveal{outline:0}@media screen and (min-width:40em){.reveal{min-height:0}}.reveal .column,.reveal .columns{min-width:0}.reveal>:last-child{margin-bottom:0}@media screen and (min-width:40em){.reveal{width:600px;max-width:75rem}}@media screen and (min-width:40em){.reveal .reveal{left:auto;right:auto;margin:0 auto}}.reveal.collapse{padding:0}@media screen and (min-width:40em){.reveal.tiny{width:30%;max-width:75rem}}@media screen and (min-width:40em){.reveal.small{width:50%;max-width:75rem}}@media screen and (min-width:40em){.reveal.large{width:90%;max-width:75rem}}.reveal.full{top:0;left:0;width:100%;height:100%;height:100vh;min-height:100vh;max-width:none;margin-left:0;border:0;border-radius:0}@media screen and (max-width:39.9375em){.reveal{top:0;left:0;width:100%;height:100%;height:100vh;min-height:100vh;max-width:none;margin-left:0;border:0;border-radius:0}}.reveal.without-overlay{position:fixed}.switch{margin-bottom:1rem;outline:0;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;color:#fefefe;font-weight:700;font-size:.875rem}.switch-input{opacity:0;position:absolute}.switch-paddle{background:#cacaca;cursor:pointer;display:block;position:relative;width:4rem;height:2rem;-webkit-transition:all .25s ease-out;transition:all .25s ease-out;border-radius:0;color:inherit;font-weight:inherit}input+.switch-paddle{margin:0}.switch-paddle:after{background:#fefefe;content:'';display:block;position:absolute;height:1.5rem;left:.25rem;top:.25rem;width:1.5rem;-webkit-transition:all .25s ease-out;transition:all .25s ease-out;-webkit-transform:translateZ(0);transform:translateZ(0);border-radius:0}input:checked~.switch-paddle{background:#2199e8}input:checked~.switch-paddle:after{left:2.25rem}[data-whatinput=mouse] input:focus~.switch-paddle{outline:0}.switch-active,.switch-inactive{position:absolute;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.switch-active{left:8%;display:none}input:checked+label>.switch-active{display:block}.switch-inactive{right:15%}input:checked+label>.switch-inactive{display:none}.switch.tiny .switch-paddle{width:3rem;height:1.5rem;font-size:.625rem}.switch.tiny .switch-paddle:after{width:1rem;height:1rem}.switch.tiny input:checked~.switch-paddle:after{left:1.75rem}.switch.small .switch-paddle{width:3.5rem;height:1.75rem;font-size:.75rem}.switch.small .switch-paddle:after{width:1.25rem;height:1.25rem}.switch.small input:checked~.switch-paddle:after{left:2rem}.switch.large .switch-paddle{width:5rem;height:2.5rem;font-size:1rem}.switch.large .switch-paddle:after{width:2rem;height:2rem}.switch.large input:checked~.switch-paddle:after{left:2.75rem}table{width:100%;margin-bottom:1rem;border-radius:0}table tbody,table tfoot,table thead{border:1px solid #f1f1f1;background-color:#fefefe}table caption{font-weight:700;padding:.5rem .625rem .625rem}table tfoot,table thead{background:#f8f8f8;color:#0a0a0a}table tfoot tr,table thead tr{background:transparent}table tfoot td,table tfoot th,table thead td,table thead th{padding:.5rem .625rem .625rem;font-weight:700;text-align:left}table tbody tr:nth-child(even){background-color:#f1f1f1}table tbody td,table tbody th{padding:.5rem .625rem .625rem}@media screen and (max-width:63.9375em){table.stack tfoot,table.stack thead{display:none}table.stack td,table.stack th,table.stack tr{display:block}table.stack td{border-top:0}}table.scroll{display:block;width:100%;overflow-x:auto}table.hover tr:hover{background-color:#f9f9f9}table.hover tr:nth-of-type(even):hover{background-color:#ececec}.table-scroll{overflow-x:auto}.table-scroll table{width:auto}.tabs{margin:0;list-style-type:none;background:#fefefe;border:1px solid #e6e6e6}.tabs:after,.tabs:before{content:' ';display:table}.tabs:after{clear:both}.tabs.vertical>li{width:auto;float:none;display:block}.tabs.simple>li>a{padding:0}.tabs.simple>li>a:hover{background:transparent}.tabs.primary{background:#2199e8}.tabs.primary>li>a{color:#fefefe}.tabs.primary>li>a:focus,.tabs.primary>li>a:hover{background:#1893e4}.tabs-title{float:left}.tabs-title>a{display:block;padding:1.25rem 1.5rem;line-height:1;font-size:.75rem}.tabs-title>a:hover{background:#fefefe}.tabs-title>a:focus,.tabs-title>a[aria-selected=true]{background:#e6e6e6}.tabs-content{background:#fefefe;-webkit-transition:all .5s ease;transition:all .5s ease;border:1px solid #e6e6e6;border-top:0}.tabs-content.vertical{border:1px solid #e6e6e6;border-left:0}.tabs-panel{display:none;padding:1rem}.tabs-panel.is-active{display:block}.thumbnail{border:4px solid #fefefe;box-shadow:0 0 0 1px hsla(0,0%,4%,.2);display:inline-block;line-height:0;max-width:100%;-webkit-transition:-webkit-box-shadow .2s ease-out;transition:box-shadow .2s ease-out;border-radius:0;margin-bottom:1rem}.thumbnail:focus,.thumbnail:hover{box-shadow:0 0 6px 1px rgba(33,153,232,.5)}.title-bar{background:#0a0a0a;color:#fefefe;padding:.5rem}.title-bar:after,.title-bar:before{content:' ';display:table}.title-bar:after{clear:both}.title-bar .menu-icon{margin-left:.25rem;margin-right:.25rem}.title-bar-left{float:left}.title-bar-right{float:right;text-align:right}.title-bar-title{font-weight:700}.menu-icon.dark,.title-bar-title{vertical-align:middle;display:inline-block}.menu-icon.dark{position:relative;cursor:pointer;width:20px;height:16px}.menu-icon.dark:after{content:'';position:absolute;display:block;width:100%;height:2px;background:#0a0a0a;top:0;left:0;box-shadow:0 7px 0 #0a0a0a,0 14px 0 #0a0a0a}.menu-icon.dark:hover:after{background:#8a8a8a;box-shadow:0 7px 0 #8a8a8a,0 14px 0 #8a8a8a}.has-tip{border-bottom:1px dotted #8a8a8a;font-weight:700;position:relative;display:inline-block;cursor:help}.tooltip{background-color:#0a0a0a;color:#fefefe;font-size:80%;padding:.75rem;position:absolute;z-index:10;top:calc(100% + .6495rem);max-width:10rem!important;border-radius:0}.tooltip:before{border-color:transparent transparent #0a0a0a;border-bottom-style:solid;border-top-width:0;bottom:100%;position:absolute;left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}.tooltip.top:before,.tooltip:before{content:'';display:block;width:0;height:0;border:.75rem inset}.tooltip.top:before{border-color:#0a0a0a transparent transparent;border-top-style:solid;border-bottom-width:0;top:100%;bottom:auto}.tooltip.left:before{border-color:transparent transparent transparent #0a0a0a;border-left-style:solid;border-right-width:0;left:100%}.tooltip.left:before,.tooltip.right:before{content:'';display:block;width:0;height:0;border:.75rem inset;bottom:auto;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.tooltip.right:before{border-color:transparent #0a0a0a transparent transparent;border-right-style:solid;border-left-width:0;left:auto;right:100%}.top-bar{padding:.5rem}.top-bar:after,.top-bar:before{content:' ';display:table}.top-bar:after{clear:both}.top-bar,.top-bar ul{background-color:#e6e6e6}.top-bar input{max-width:200px;margin-right:1rem}.top-bar .input-group-field{width:100%;margin-right:0}.top-bar input.button{width:auto}.top-bar .top-bar-left,.top-bar .top-bar-right{width:100%}@media screen and (min-width:40em){.top-bar .top-bar-left,.top-bar .top-bar-right{width:auto}}@media screen and (max-width:63.9375em){.top-bar.stacked-for-medium .top-bar-left,.top-bar.stacked-for-medium .top-bar-right{width:100%}}@media screen and (max-width:74.9375em){.top-bar.stacked-for-large .top-bar-left,.top-bar.stacked-for-large .top-bar-right{width:100%}}.top-bar-title{float:left;margin-right:1rem}.top-bar-left{float:left}.top-bar-right{float:right}.hide{display:none!important}.invisible{visibility:hidden}@media screen and (max-width:39.9375em){.hide-for-small-only{display:none!important}}@media screen and (max-width:0em),screen and (min-width:40em){.show-for-small-only{display:none!important}}@media screen and (min-width:40em){.hide-for-medium{display:none!important}}@media screen and (max-width:39.9375em){.show-for-medium{display:none!important}}@media screen and (min-width:40em) and (max-width:63.9375em){.hide-for-medium-only{display:none!important}}@media screen and (max-width:39.9375em),screen and (min-width:64em){.show-for-medium-only{display:none!important}}@media screen and (min-width:64em){.hide-for-large{display:none!important}}@media screen and (max-width:63.9375em){.show-for-large{display:none!important}}@media screen and (min-width:64em) and (max-width:74.9375em){.hide-for-large-only{display:none!important}}@media screen and (max-width:63.9375em),screen and (min-width:75em){.show-for-large-only{display:none!important}}.show-for-sr,.show-on-focus{position:absolute!important;width:1px;height:1px;overflow:hidden;clip:rect(0,0,0,0)}.show-on-focus:active,.show-on-focus:focus{position:static!important;height:auto;width:auto;overflow:visible;clip:auto}.hide-for-portrait,.show-for-landscape{display:block!important}@media screen and (orientation:landscape){.hide-for-portrait,.show-for-landscape{display:block!important}}@media screen and (orientation:portrait){.hide-for-portrait,.show-for-landscape{display:none!important}}.hide-for-landscape,.show-for-portrait{display:none!important}@media screen and (orientation:landscape){.hide-for-landscape,.show-for-portrait{display:none!important}}@media screen and (orientation:portrait){.hide-for-landscape,.show-for-portrait{display:block!important}}.float-left{float:left!important}.float-right{float:right!important}.float-center{display:block;margin-left:auto;margin-right:auto}.clearfix:after,.clearfix:before{content:' ';display:table}.clearfix:after{clear:both}

Node-path: trunk/sumatoria-cubo/WebContent/sumatoriacubo.html
Node-kind: file
Node-action: add
Text-content-md5: aeae0dcd0eba55b7a8ace661ca29270c
Text-content-sha1: c3af59c1d78a828773a21b3441c3b19d8ea6fa95
Prop-content-length: 10
Text-content-length: 921
Content-length: 931

PROPS-END
<!DOCTYPE html>
<html>
	<head>
	<meta charset="UTF-8">
	<title>Sumatoria cubo</title>
	<link rel="stylesheet" type="text/css" href="dependencias/foundation.min.css" />
</head>
<body>	
	<h1>Sumatoria cubo</h1>
	<form>
		<div class="row">
			<div class="medium-5 columns">
				<label>
					Entrada:
					<textarea id="Comandos" rows="15">
2
4 5
UPDATE 2 2 2 4
QUERY 1 1 1 3 3 3
UPDATE 1 1 1 23
QUERY 2 2 2 4 4 4
QUERY 1 1 1 3 3 3
2 4
UPDATE 2 2 2 1
QUERY 1 1 1 1 1 1
QUERY 1 1 1 2 2 2
QUERY 2 2 2 2 2 2
					</textarea>
				</label>
			</div>
			<div class="medium-2 columns">
				<input class="button" type="button" onclick="sumatoriacubo.procesar()" value="Procesar" />
			</div>
			<div class="medium-5 columns">
				<label>
					Salida:
					<textarea id="Resultado" rows="15">		
					</textarea>
				</label>
			</div>
		</div>
	</form>
	<script type="text/javascript" src="sumatoriacubo.js"></script>	
</body>
</html>

Node-path: trunk/sumatoria-cubo/WebContent/sumatoriacubo.js
Node-kind: file
Node-action: add
Text-content-md5: 8516868a5325d1d6b732de6a1aebffe2
Text-content-sha1: a20bd5e31a1dcb982807cb9f8e746694d178cf59
Prop-content-length: 10
Text-content-length: 1731
Content-length: 1741

PROPS-END

(function(sumatoriacubo) {
var sumatoriacubo = sumatoriacubo || {};

sumatoriacubo.procesar = function()
{
	var cadenaResultado = ''; 
	
	var comandos = document.getElementById('Comandos').value.trim();
	var lineaActual = 0;
	var comandosComoLineas = comandos.split('\n');
	var numeroPruebas = parseInt( comandosComoLineas[lineaActual++].trim() );
	for(var i = 0; i < numeroPruebas ; i++)
	{
		var matriz = new Map();
		var dimesionMatrizSentencias = comandosComoLineas[lineaActual++].trim().split(' ');
		var dimensionMatriz =  parseInt( dimesionMatrizSentencias[0] );
		var numeroSentencias =  parseInt( dimesionMatrizSentencias[1] );
		for(var j = 0; j < numeroSentencias ;  j++)
		{
			var comando = comandosComoLineas[lineaActual++].trim();
			if( comando.substring(0,6) === 'UPDATE' )
			{
				var tokens = comando.split(' ');
				matriz.set(tokens[1] + '|' + tokens[2] + '|' + tokens[3], parseInt(tokens[4]) );
			}
			else if( comando.substring(0,5) === 'QUERY' )
			{
				var tokens = comando.split(' ');
				var x1 = parseInt(tokens[1]);
				var y1 = parseInt(tokens[2]);
				var z1 = parseInt(tokens[3]);
				var x2 = parseInt(tokens[4]);
				var y2 = parseInt(tokens[5]);
				var z2 = parseInt(tokens[6]);
				var suma = 0;
				for (var [key, value] of matriz) 
				{
					var keyTokens = key.split('|');
					var x = parseInt(keyTokens[0]);
					var y = parseInt(keyTokens[1]);
					var z = parseInt(keyTokens[2]);					
					if ( (x >= x1 && x <= x2) && (y >= y1 && y <= y2) && (z >= z1 && z <= z2)  )
					{
						suma += value;
					}
				}
				cadenaResultado += suma + '\n';
			}
		}		
	}
	
	document.getElementById('Resultado').value = cadenaResultado;
}

})(window.sumatoriacubo || (window.sumatoriacubo = {}));

Revision-number: 9
Prop-content-length: 150
Content-length: 150

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-28T14:37:48.596582Z
K 7
svn:log
V 49
Se agregan archivos de configuracion del proyecto
PROPS-END

Node-path: trunk/sumatoria-cubo/.project
Node-kind: file
Node-action: add
Text-content-md5: f36825947c6665cdd5ad6bd43dd96455
Text-content-sha1: 839d7240d4f47ccd8c28ccc7049f489fe4312d84
Prop-content-length: 10
Text-content-length: 658
Content-length: 668

PROPS-END
<?xml version="1.0" encoding="UTF-8"?>
<projectDescription>
	<name>sumatoria-cubo</name>
	<comment></comment>
	<projects>
	</projects>
	<buildSpec>
		<buildCommand>
			<name>org.eclipse.wst.common.project.facet.core.builder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.eclipse.wst.validation.validationbuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
	</buildSpec>
	<natures>
		<nature>org.eclipse.wst.common.project.facet.core.nature</nature>
		<nature>org.eclipse.wst.common.modulecore.ModuleCoreNature</nature>
		<nature>org.eclipse.wst.jsdt.core.jsNature</nature>
	</natures>
</projectDescription>


Node-path: trunk/sumatoria-cubo/.settings
Node-kind: dir
Node-action: add
Prop-content-length: 10
Content-length: 10

PROPS-END


Node-path: trunk/sumatoria-cubo/.settings/org.eclipse.wst.common.component
Node-kind: file
Node-action: add
Text-content-md5: 30becf03b30fbcfd2caba484c9b20353
Text-content-sha1: bfdf4287e71e5ee791642ffafa68530d870708d5
Prop-content-length: 10
Text-content-length: 317
Content-length: 327

PROPS-END
<?xml version="1.0" encoding="UTF-8"?><project-modules id="moduleCoreId" project-version="1.5.0">
    <wb-module deploy-name="sumatoria-cubo-old2">
        <wb-resource deploy-path="/" source-path="/WebContent"/>
        <property name="context-root" value="sumatoria-cubo-old2"/>
    </wb-module>
</project-modules>


Node-path: trunk/sumatoria-cubo/.settings/org.eclipse.wst.common.project.facet.core.xml
Node-kind: file
Node-action: add
Text-content-md5: 9af50e66a486c253a2f12037f6ff7961
Text-content-sha1: 4d7736c29e38cbdb2e645e9f08c4eb156b841b5f
Prop-content-length: 10
Text-content-length: 230
Content-length: 240

PROPS-END
<?xml version="1.0" encoding="UTF-8"?>
<faceted-project>
  <fixed facet="wst.web"/>
  <fixed facet="wst.jsdt.web"/>
  <installed facet="wst.web" version="1.0"/>
  <installed facet="wst.jsdt.web" version="1.0"/>
</faceted-project>


Node-path: trunk/sumatoria-cubo/.settings/org.eclipse.wst.jsdt.ui.superType.container
Node-kind: file
Node-action: add
Text-content-md5: b27d1cf62dde4473bab7c433317bb0ce
Text-content-sha1: 87ab9531e1222351568346cf9057a0cae36112b8
Prop-content-length: 10
Text-content-length: 49
Content-length: 59

PROPS-END
org.eclipse.wst.jsdt.launching.baseBrowserLibrary

Node-path: trunk/sumatoria-cubo/.settings/org.eclipse.wst.jsdt.ui.superType.name
Node-kind: file
Node-action: add
Text-content-md5: c89686a387d2b12b3c729ce35a0bcb5b
Text-content-sha1: 41dfc0a6c92707948578891c51d98c6443be63cc
Prop-content-length: 10
Text-content-length: 6
Content-length: 16

PROPS-END
Window

Revision-number: 10
Prop-content-length: 228
Content-length: 228

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-28T15:44:30.633717Z
K 7
svn:log
V 126
Se agrega dependencias para ejecutar pruebas. y se agrega funcion de conversion de cadenas a enteros y sus respectivas pruebas
PROPS-END

Node-path: trunk/sumatoria-cubo/WebContent/dependencias/boot.js
Node-kind: file
Node-action: add
Text-content-md5: 4dc39978f0a557dfd1afa1e5356639e0
Text-content-sha1: 66663cfc221ee5b0e6f01ef22aae522263430b0b
Prop-content-length: 10
Text-content-length: 5334
Content-length: 5344

PROPS-END
/**
 Starting with version 2.0, this file "boots" Jasmine, performing all of the necessary initialization before executing the loaded environment and all of a project's specs. This file should be loaded after `jasmine.js` and `jasmine_html.js`, but before any project source files or spec files are loaded. Thus this file can also be used to customize Jasmine for a project.

 If a project is using Jasmine via the standalone distribution, this file can be customized directly. If a project is using Jasmine via the [Ruby gem][jasmine-gem], this file can be copied into the support directory via `jasmine copy_boot_js`. Other environments (e.g., Python) will have different mechanisms.

 The location of `boot.js` can be specified and/or overridden in `jasmine.yml`.

 [jasmine-gem]: http://github.com/pivotal/jasmine-gem
 */

(function() {

  /**
   * ## Require &amp; Instantiate
   *
   * Require Jasmine's core files. Specifically, this requires and attaches all of Jasmine's code to the `jasmine` reference.
   */
  window.jasmine = jasmineRequire.core(jasmineRequire);

  /**
   * Since this is being run in a browser and the results should populate to an HTML page, require the HTML-specific Jasmine code, injecting the same reference.
   */
  jasmineRequire.html(jasmine);

  /**
   * Create the Jasmine environment. This is used to run all specs in a project.
   */
  var env = jasmine.getEnv();

  /**
   * ## The Global Interface
   *
   * Build up the functions that will be exposed as the Jasmine public interface. A project can customize, rename or alias any of these functions as desired, provided the implementation remains unchanged.
   */
  var jasmineInterface = jasmineRequire.interface(jasmine, env);

  /**
   * Add all of the Jasmine global/public interface to the global scope, so a project can use the public interface directly. For example, calling `describe` in specs instead of `jasmine.getEnv().describe`.
   */
  extend(window, jasmineInterface);

  /**
   * ## Runner Parameters
   *
   * More browser specific code - wrap the query string in an object and to allow for getting/setting parameters from the runner user interface.
   */

  var queryString = new jasmine.QueryString({
    getWindowLocation: function() { return window.location; }
  });

  var catchingExceptions = queryString.getParam("catch");
  env.catchExceptions(typeof catchingExceptions === "undefined" ? true : catchingExceptions);

  var throwingExpectationFailures = queryString.getParam("throwFailures");
  env.throwOnExpectationFailure(throwingExpectationFailures);

  var random = queryString.getParam("random");
  env.randomizeTests(random);

  var seed = queryString.getParam("seed");
  if (seed) {
    env.seed(seed);
  }

  /**
   * ## Reporters
   * The `HtmlReporter` builds all of the HTML UI for the runner page. This reporter paints the dots, stars, and x's for specs, as well as all spec names and all failures (if any).
   */
  var htmlReporter = new jasmine.HtmlReporter({
    env: env,
    onRaiseExceptionsClick: function() { queryString.navigateWithNewParam("catch", !env.catchingExceptions()); },
    onThrowExpectationsClick: function() { queryString.navigateWithNewParam("throwFailures", !env.throwingExpectationFailures()); },
    onRandomClick: function() { queryString.navigateWithNewParam("random", !env.randomTests()); },
    addToExistingQueryString: function(key, value) { return queryString.fullStringWithNewParam(key, value); },
    getContainer: function() { return document.body; },
    createElement: function() { return document.createElement.apply(document, arguments); },
    createTextNode: function() { return document.createTextNode.apply(document, arguments); },
    timer: new jasmine.Timer()
  });

  /**
   * The `jsApiReporter` also receives spec results, and is used by any environment that needs to extract the results  from JavaScript.
   */
  env.addReporter(jasmineInterface.jsApiReporter);
  env.addReporter(htmlReporter);

  /**
   * Filter which specs will be run by matching the start of the full name against the `spec` query param.
   */
  var specFilter = new jasmine.HtmlSpecFilter({
    filterString: function() { return queryString.getParam("spec"); }
  });

  env.specFilter = function(spec) {
    return specFilter.matches(spec.getFullName());
  };

  /**
   * Setting up timing functions to be able to be overridden. Certain browsers (Safari, IE 8, phantomjs) require this hack.
   */
  window.setTimeout = window.setTimeout;
  window.setInterval = window.setInterval;
  window.clearTimeout = window.clearTimeout;
  window.clearInterval = window.clearInterval;

  /**
   * ## Execution
   *
   * Replace the browser window's `onload`, ensure it's called, and then run all of the loaded specs. This includes initializing the `HtmlReporter` instance and then executing the loaded Jasmine environment. All of this will happen after all of the specs are loaded.
   */
  var currentWindowOnload = window.onload;

  window.onload = function() {
    if (currentWindowOnload) {
      currentWindowOnload();
    }
    htmlReporter.initialize();
    env.execute();
  };

  /**
   * Helper function for readability above.
   */
  function extend(destination, source) {
    for (var property in source) destination[property] = source[property];
    return destination;
  }

}());


Node-path: trunk/sumatoria-cubo/WebContent/dependencias/console.js
Node-kind: file
Node-action: add
Text-content-md5: cc14f6041da178c3492d0645eeaa15f9
Text-content-sha1: 244453d833689d9811178b6de02a456bfefd9aa5
Prop-content-length: 10
Text-content-length: 5224
Content-length: 5234

PROPS-END
/*
Copyright (c) 2008-2016 Pivotal Labs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
function getJasmineRequireObj() {
  if (typeof module !== 'undefined' && module.exports) {
    return exports;
  } else {
    window.jasmineRequire = window.jasmineRequire || {};
    return window.jasmineRequire;
  }
}

getJasmineRequireObj().console = function(jRequire, j$) {
  j$.ConsoleReporter = jRequire.ConsoleReporter();
};

getJasmineRequireObj().ConsoleReporter = function() {

  var noopTimer = {
    start: function(){},
    elapsed: function(){ return 0; }
  };

  function ConsoleReporter(options) {
    var print = options.print,
      showColors = options.showColors || false,
      onComplete = options.onComplete || function() {},
      timer = options.timer || noopTimer,
      specCount,
      failureCount,
      failedSpecs = [],
      pendingCount,
      ansi = {
        green: '\x1B[32m',
        red: '\x1B[31m',
        yellow: '\x1B[33m',
        none: '\x1B[0m'
      },
      failedSuites = [];

    print('ConsoleReporter is deprecated and will be removed in a future version.');

    this.jasmineStarted = function() {
      specCount = 0;
      failureCount = 0;
      pendingCount = 0;
      print('Started');
      printNewline();
      timer.start();
    };

    this.jasmineDone = function() {
      printNewline();
      for (var i = 0; i < failedSpecs.length; i++) {
        specFailureDetails(failedSpecs[i]);
      }

      if(specCount > 0) {
        printNewline();

        var specCounts = specCount + ' ' + plural('spec', specCount) + ', ' +
          failureCount + ' ' + plural('failure', failureCount);

        if (pendingCount) {
          specCounts += ', ' + pendingCount + ' pending ' + plural('spec', pendingCount);
        }

        print(specCounts);
      } else {
        print('No specs found');
      }

      printNewline();
      var seconds = timer.elapsed() / 1000;
      print('Finished in ' + seconds + ' ' + plural('second', seconds));
      printNewline();

      for(i = 0; i < failedSuites.length; i++) {
        suiteFailureDetails(failedSuites[i]);
      }

      onComplete(failureCount === 0);
    };

    this.specDone = function(result) {
      specCount++;

      if (result.status == 'pending') {
        pendingCount++;
        print(colored('yellow', '*'));
        return;
      }

      if (result.status == 'passed') {
        print(colored('green', '.'));
        return;
      }

      if (result.status == 'failed') {
        failureCount++;
        failedSpecs.push(result);
        print(colored('red', 'F'));
      }
    };

    this.suiteDone = function(result) {
      if (result.failedExpectations && result.failedExpectations.length > 0) {
        failureCount++;
        failedSuites.push(result);
      }
    };

    return this;

    function printNewline() {
      print('\n');
    }

    function colored(color, str) {
      return showColors ? (ansi[color] + str + ansi.none) : str;
    }

    function plural(str, count) {
      return count == 1 ? str : str + 's';
    }

    function repeat(thing, times) {
      var arr = [];
      for (var i = 0; i < times; i++) {
        arr.push(thing);
      }
      return arr;
    }

    function indent(str, spaces) {
      var lines = (str || '').split('\n');
      var newArr = [];
      for (var i = 0; i < lines.length; i++) {
        newArr.push(repeat(' ', spaces).join('') + lines[i]);
      }
      return newArr.join('\n');
    }

    function specFailureDetails(result) {
      printNewline();
      print(result.fullName);

      for (var i = 0; i < result.failedExpectations.length; i++) {
        var failedExpectation = result.failedExpectations[i];
        printNewline();
        print(indent(failedExpectation.message, 2));
        print(indent(failedExpectation.stack, 2));
      }

      printNewline();
    }

    function suiteFailureDetails(result) {
      for (var i = 0; i < result.failedExpectations.length; i++) {
        printNewline();
        print(colored('red', 'An error was thrown in an afterAll'));
        printNewline();
        print(colored('red', 'AfterAll ' + result.failedExpectations[i].message));

      }
      printNewline();
    }
  }

  return ConsoleReporter;
};


Node-path: trunk/sumatoria-cubo/WebContent/dependencias/jasmine-html.js
Node-kind: file
Node-action: add
Text-content-md5: 60988ff6e4a98b2e1bb87433048e1065
Text-content-sha1: 6f454d15ae70c3dc528d642e4a847d5e204e3093
Prop-content-length: 10
Text-content-length: 16732
Content-length: 16742

PROPS-END
/*
Copyright (c) 2008-2016 Pivotal Labs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
jasmineRequire.html = function(j$) {
  j$.ResultsNode = jasmineRequire.ResultsNode();
  j$.HtmlReporter = jasmineRequire.HtmlReporter(j$);
  j$.QueryString = jasmineRequire.QueryString();
  j$.HtmlSpecFilter = jasmineRequire.HtmlSpecFilter();
};

jasmineRequire.HtmlReporter = function(j$) {

  var noopTimer = {
    start: function() {},
    elapsed: function() { return 0; }
  };

  function HtmlReporter(options) {
    var env = options.env || {},
      getContainer = options.getContainer,
      createElement = options.createElement,
      createTextNode = options.createTextNode,
      onRaiseExceptionsClick = options.onRaiseExceptionsClick || function() {},
      onThrowExpectationsClick = options.onThrowExpectationsClick || function() {},
      onRandomClick = options.onRandomClick || function() {},
      addToExistingQueryString = options.addToExistingQueryString || defaultQueryString,
      timer = options.timer || noopTimer,
      results = [],
      specsExecuted = 0,
      failureCount = 0,
      pendingSpecCount = 0,
      htmlReporterMain,
      symbols,
      failedSuites = [];

    this.initialize = function() {
      clearPrior();
      htmlReporterMain = createDom('div', {className: 'jasmine_html-reporter'},
        createDom('div', {className: 'jasmine-banner'},
          createDom('a', {className: 'jasmine-title', href: 'http://jasmine.github.io/', target: '_blank'}),
          createDom('span', {className: 'jasmine-version'}, j$.version)
        ),
        createDom('ul', {className: 'jasmine-symbol-summary'}),
        createDom('div', {className: 'jasmine-alert'}),
        createDom('div', {className: 'jasmine-results'},
          createDom('div', {className: 'jasmine-failures'})
        )
      );
      getContainer().appendChild(htmlReporterMain);
    };

    var totalSpecsDefined;
    this.jasmineStarted = function(options) {
      totalSpecsDefined = options.totalSpecsDefined || 0;
      timer.start();
    };

    var summary = createDom('div', {className: 'jasmine-summary'});

    var topResults = new j$.ResultsNode({}, '', null),
      currentParent = topResults;

    this.suiteStarted = function(result) {
      currentParent.addChild(result, 'suite');
      currentParent = currentParent.last();
    };

    this.suiteDone = function(result) {
      if (result.status == 'failed') {
        failedSuites.push(result);
      }

      if (currentParent == topResults) {
        return;
      }

      currentParent = currentParent.parent;
    };

    this.specStarted = function(result) {
      currentParent.addChild(result, 'spec');
    };

    var failures = [];
    this.specDone = function(result) {
      if(noExpectations(result) && typeof console !== 'undefined' && typeof console.error !== 'undefined') {
        console.error('Spec \'' + result.fullName + '\' has no expectations.');
      }

      if (result.status != 'disabled') {
        specsExecuted++;
      }

      if (!symbols){
        symbols = find('.jasmine-symbol-summary');
      }

      symbols.appendChild(createDom('li', {
          className: noExpectations(result) ? 'jasmine-empty' : 'jasmine-' + result.status,
          id: 'spec_' + result.id,
          title: result.fullName
        }
      ));

      if (result.status == 'failed') {
        failureCount++;

        var failure =
          createDom('div', {className: 'jasmine-spec-detail jasmine-failed'},
            createDom('div', {className: 'jasmine-description'},
              createDom('a', {title: result.fullName, href: specHref(result)}, result.fullName)
            ),
            createDom('div', {className: 'jasmine-messages'})
          );
        var messages = failure.childNodes[1];

        for (var i = 0; i < result.failedExpectations.length; i++) {
          var expectation = result.failedExpectations[i];
          messages.appendChild(createDom('div', {className: 'jasmine-result-message'}, expectation.message));
          messages.appendChild(createDom('div', {className: 'jasmine-stack-trace'}, expectation.stack));
        }

        failures.push(failure);
      }

      if (result.status == 'pending') {
        pendingSpecCount++;
      }
    };

    this.jasmineDone = function(doneResult) {
      var banner = find('.jasmine-banner');
      var alert = find('.jasmine-alert');
      var order = doneResult && doneResult.order;
      alert.appendChild(createDom('span', {className: 'jasmine-duration'}, 'finished in ' + timer.elapsed() / 1000 + 's'));

      banner.appendChild(
        createDom('div', { className: 'jasmine-run-options' },
          createDom('span', { className: 'jasmine-trigger' }, 'Options'),
          createDom('div', { className: 'jasmine-payload' },
            createDom('div', { className: 'jasmine-exceptions' },
              createDom('input', {
                className: 'jasmine-raise',
                id: 'jasmine-raise-exceptions',
                type: 'checkbox'
              }),
              createDom('label', { className: 'jasmine-label', 'for': 'jasmine-raise-exceptions' }, 'raise exceptions')),
            createDom('div', { className: 'jasmine-throw-failures' },
              createDom('input', {
                className: 'jasmine-throw',
                id: 'jasmine-throw-failures',
                type: 'checkbox'
              }),
              createDom('label', { className: 'jasmine-label', 'for': 'jasmine-throw-failures' }, 'stop spec on expectation failure')),
            createDom('div', { className: 'jasmine-random-order' },
              createDom('input', {
                className: 'jasmine-random',
                id: 'jasmine-random-order',
                type: 'checkbox'
              }),
              createDom('label', { className: 'jasmine-label', 'for': 'jasmine-random-order' }, 'run tests in random order'))
          )
        ));

      var raiseCheckbox = find('#jasmine-raise-exceptions');

      raiseCheckbox.checked = !env.catchingExceptions();
      raiseCheckbox.onclick = onRaiseExceptionsClick;

      var throwCheckbox = find('#jasmine-throw-failures');
      throwCheckbox.checked = env.throwingExpectationFailures();
      throwCheckbox.onclick = onThrowExpectationsClick;

      var randomCheckbox = find('#jasmine-random-order');
      randomCheckbox.checked = env.randomTests();
      randomCheckbox.onclick = onRandomClick;

      var optionsMenu = find('.jasmine-run-options'),
          optionsTrigger = optionsMenu.querySelector('.jasmine-trigger'),
          optionsPayload = optionsMenu.querySelector('.jasmine-payload'),
          isOpen = /\bjasmine-open\b/;

      optionsTrigger.onclick = function() {
        if (isOpen.test(optionsPayload.className)) {
          optionsPayload.className = optionsPayload.className.replace(isOpen, '');
        } else {
          optionsPayload.className += ' jasmine-open';
        }
      };

      if (specsExecuted < totalSpecsDefined) {
        var skippedMessage = 'Ran ' + specsExecuted + ' of ' + totalSpecsDefined + ' specs - run all';
        var skippedLink = order && order.random ? '?random=true' : '?';
        alert.appendChild(
          createDom('span', {className: 'jasmine-bar jasmine-skipped'},
            createDom('a', {href: skippedLink, title: 'Run all specs'}, skippedMessage)
          )
        );
      }
      var statusBarMessage = '';
      var statusBarClassName = 'jasmine-bar ';

      if (totalSpecsDefined > 0) {
        statusBarMessage += pluralize('spec', specsExecuted) + ', ' + pluralize('failure', failureCount);
        if (pendingSpecCount) { statusBarMessage += ', ' + pluralize('pending spec', pendingSpecCount); }
        statusBarClassName += (failureCount > 0) ? 'jasmine-failed' : 'jasmine-passed';
      } else {
        statusBarClassName += 'jasmine-skipped';
        statusBarMessage += 'No specs found';
      }

      var seedBar;
      if (order && order.random) {
        seedBar = createDom('span', {className: 'jasmine-seed-bar'},
          ', randomized with seed ',
          createDom('a', {title: 'randomized with seed ' + order.seed, href: seedHref(order.seed)}, order.seed)
        );
      }

      alert.appendChild(createDom('span', {className: statusBarClassName}, statusBarMessage, seedBar));

      var errorBarClassName = 'jasmine-bar jasmine-errored';
      var errorBarMessagePrefix = 'AfterAll ';

      for(var i = 0; i < failedSuites.length; i++) {
        var failedSuite = failedSuites[i];
        for(var j = 0; j < failedSuite.failedExpectations.length; j++) {
          alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessagePrefix + failedSuite.failedExpectations[j].message));
        }
      }

      var globalFailures = (doneResult && doneResult.failedExpectations) || [];
      for(i = 0; i < globalFailures.length; i++) {
        var failure = globalFailures[i];
        alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessagePrefix + failure.message));
      }

      var results = find('.jasmine-results');
      results.appendChild(summary);

      summaryList(topResults, summary);

      function summaryList(resultsTree, domParent) {
        var specListNode;
        for (var i = 0; i < resultsTree.children.length; i++) {
          var resultNode = resultsTree.children[i];
          if (resultNode.type == 'suite') {
            var suiteListNode = createDom('ul', {className: 'jasmine-suite', id: 'suite-' + resultNode.result.id},
              createDom('li', {className: 'jasmine-suite-detail'},
                createDom('a', {href: specHref(resultNode.result)}, resultNode.result.description)
              )
            );

            summaryList(resultNode, suiteListNode);
            domParent.appendChild(suiteListNode);
          }
          if (resultNode.type == 'spec') {
            if (domParent.getAttribute('class') != 'jasmine-specs') {
              specListNode = createDom('ul', {className: 'jasmine-specs'});
              domParent.appendChild(specListNode);
            }
            var specDescription = resultNode.result.description;
            if(noExpectations(resultNode.result)) {
              specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;
            }
            if(resultNode.result.status === 'pending' && resultNode.result.pendingReason !== '') {
              specDescription = specDescription + ' PENDING WITH MESSAGE: ' + resultNode.result.pendingReason;
            }
            specListNode.appendChild(
              createDom('li', {
                  className: 'jasmine-' + resultNode.result.status,
                  id: 'spec-' + resultNode.result.id
                },
                createDom('a', {href: specHref(resultNode.result)}, specDescription)
              )
            );
          }
        }
      }

      if (failures.length) {
        alert.appendChild(
          createDom('span', {className: 'jasmine-menu jasmine-bar jasmine-spec-list'},
            createDom('span', {}, 'Spec List | '),
            createDom('a', {className: 'jasmine-failures-menu', href: '#'}, 'Failures')));
        alert.appendChild(
          createDom('span', {className: 'jasmine-menu jasmine-bar jasmine-failure-list'},
            createDom('a', {className: 'jasmine-spec-list-menu', href: '#'}, 'Spec List'),
            createDom('span', {}, ' | Failures ')));

        find('.jasmine-failures-menu').onclick = function() {
          setMenuModeTo('jasmine-failure-list');
        };
        find('.jasmine-spec-list-menu').onclick = function() {
          setMenuModeTo('jasmine-spec-list');
        };

        setMenuModeTo('jasmine-failure-list');

        var failureNode = find('.jasmine-failures');
        for (i = 0; i < failures.length; i++) {
          failureNode.appendChild(failures[i]);
        }
      }
    };

    return this;

    function find(selector) {
      return getContainer().querySelector('.jasmine_html-reporter ' + selector);
    }

    function clearPrior() {
      // return the reporter
      var oldReporter = find('');

      if(oldReporter) {
        getContainer().removeChild(oldReporter);
      }
    }

    function createDom(type, attrs, childrenVarArgs) {
      var el = createElement(type);

      for (var i = 2; i < arguments.length; i++) {
        var child = arguments[i];

        if (typeof child === 'string') {
          el.appendChild(createTextNode(child));
        } else {
          if (child) {
            el.appendChild(child);
          }
        }
      }

      for (var attr in attrs) {
        if (attr == 'className') {
          el[attr] = attrs[attr];
        } else {
          el.setAttribute(attr, attrs[attr]);
        }
      }

      return el;
    }

    function pluralize(singular, count) {
      var word = (count == 1 ? singular : singular + 's');

      return '' + count + ' ' + word;
    }

    function specHref(result) {
      return addToExistingQueryString('spec', result.fullName);
    }

    function seedHref(seed) {
      return addToExistingQueryString('seed', seed);
    }

    function defaultQueryString(key, value) {
      return '?' + key + '=' + value;
    }

    function setMenuModeTo(mode) {
      htmlReporterMain.setAttribute('class', 'jasmine_html-reporter ' + mode);
    }

    function noExpectations(result) {
      return (result.failedExpectations.length + result.passedExpectations.length) === 0 &&
        result.status === 'passed';
    }
  }

  return HtmlReporter;
};

jasmineRequire.HtmlSpecFilter = function() {
  function HtmlSpecFilter(options) {
    var filterString = options && options.filterString() && options.filterString().replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    var filterPattern = new RegExp(filterString);

    this.matches = function(specName) {
      return filterPattern.test(specName);
    };
  }

  return HtmlSpecFilter;
};

jasmineRequire.ResultsNode = function() {
  function ResultsNode(result, type, parent) {
    this.result = result;
    this.type = type;
    this.parent = parent;

    this.children = [];

    this.addChild = function(result, type) {
      this.children.push(new ResultsNode(result, type, this));
    };

    this.last = function() {
      return this.children[this.children.length - 1];
    };
  }

  return ResultsNode;
};

jasmineRequire.QueryString = function() {
  function QueryString(options) {

    this.navigateWithNewParam = function(key, value) {
      options.getWindowLocation().search = this.fullStringWithNewParam(key, value);
    };

    this.fullStringWithNewParam = function(key, value) {
      var paramMap = queryStringToParamMap();
      paramMap[key] = value;
      return toQueryString(paramMap);
    };

    this.getParam = function(key) {
      return queryStringToParamMap()[key];
    };

    return this;

    function toQueryString(paramMap) {
      var qStrPairs = [];
      for (var prop in paramMap) {
        qStrPairs.push(encodeURIComponent(prop) + '=' + encodeURIComponent(paramMap[prop]));
      }
      return '?' + qStrPairs.join('&');
    }

    function queryStringToParamMap() {
      var paramStr = options.getWindowLocation().search.substring(1),
        params = [],
        paramMap = {};

      if (paramStr.length > 0) {
        params = paramStr.split('&');
        for (var i = 0; i < params.length; i++) {
          var p = params[i].split('=');
          var value = decodeURIComponent(p[1]);
          if (value === 'true' || value === 'false') {
            value = JSON.parse(value);
          }
          paramMap[decodeURIComponent(p[0])] = value;
        }
      }

      return paramMap;
    }

  }

  return QueryString;
};


Node-path: trunk/sumatoria-cubo/WebContent/dependencias/jasmine.css
Node-kind: file
Node-action: add
Text-content-md5: 3b23989f6ca030c3cf3d95107d4665f9
Text-content-sha1: 580452d3024022a22d892991b556d5c56a8ecf11
Prop-content-length: 10
Text-content-length: 20297
Content-length: 20307

PROPS-END
body { overflow-y: scroll; }

.jasmine_html-reporter { background-color: #eee; padding: 5px; margin: -8px; font-size: 11px; font-family: Monaco, "Lucida Console", monospace; line-height: 14px; color: #333; }
.jasmine_html-reporter a { text-decoration: none; }
.jasmine_html-reporter a:hover { text-decoration: underline; }
.jasmine_html-reporter p, .jasmine_html-reporter h1, .jasmine_html-reporter h2, .jasmine_html-reporter h3, .jasmine_html-reporter h4, .jasmine_html-reporter h5, .jasmine_html-reporter h6 { margin: 0; line-height: 14px; }
.jasmine_html-reporter .jasmine-banner, .jasmine_html-reporter .jasmine-symbol-summary, .jasmine_html-reporter .jasmine-summary, .jasmine_html-reporter .jasmine-result-message, .jasmine_html-reporter .jasmine-spec .jasmine-description, .jasmine_html-reporter .jasmine-spec-detail .jasmine-description, .jasmine_html-reporter .jasmine-alert .jasmine-bar, .jasmine_html-reporter .jasmine-stack-trace { padding-left: 9px; padding-right: 9px; }
.jasmine_html-reporter .jasmine-banner { position: relative; }
.jasmine_html-reporter .jasmine-banner .jasmine-title { background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFoAAAAZCAMAAACGusnyAAACdlBMVEX/////AP+AgICqVaqAQICZM5mAVYCSSZKAQICOOY6ATYCLRouAQICJO4mSSYCIRIiPQICHPIeOR4CGQ4aMQICGPYaLRoCFQ4WKQICPPYWJRYCOQoSJQICNPoSIRICMQoSHQICHRICKQoOHQICKPoOJO4OJQYOMQICMQ4CIQYKLQICIPoKLQ4CKQICNPoKJQISMQ4KJQoSLQYKJQISLQ4KIQoSKQYKIQICIQISMQoSKQYKLQIOLQoOJQYGLQIOKQIOMQoGKQYOLQYGKQIOLQoGJQYOJQIOKQYGJQIOKQoGKQIGLQIKLQ4KKQoGLQYKJQIGKQYKJQIGKQIKJQoGKQYKLQIGKQYKLQIOJQoKKQoOJQYKKQIOJQoKKQoOKQIOLQoKKQYOLQYKJQIOKQoKKQYKKQoKJQYOKQYKLQIOKQoKLQYOKQYKLQIOJQoGKQYKJQYGJQoGKQYKLQoGLQYGKQoGJQYKKQYGJQIKKQoGJQYKLQIKKQYGLQYKKQYGKQYGKQYKJQYOKQoKJQYOKQYKLQYOLQYOKQYKLQYOKQoKKQYKKQYOKQYOJQYKKQYKLQYKKQIKKQoKKQYKKQYKKQoKJQIKKQYKLQYKKQYKKQIKKQYKKQYKKQYKKQIKKQYKJQYGLQYGKQYKKQYKKQYGKQIKKQYGKQYOJQoKKQYOLQYKKQYOKQoKKQYKKQoKKQYKKQYKJQYKLQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKJQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKLQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKKQYKmIDpEAAAA0XRSTlMAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAiIyQlJycoKissLS4wMTQ1Njc4OTo7PDw+P0BCQ0RISUpLTE1OUFNUVVdYWFlaW15fYGFiY2ZnaGlqa2xtb3BxcnN0dnh5ent8fX5/gIGChIWIioyNjo+QkZOUlZaYmZqbnJ2eoKGio6WmqKmsra6vsLGztre4ubq7vL2+wMHDxMjJysvNzs/Q0dLU1tfY2dvc3t/g4eLj5ebn6Onq6+zt7u/w8vP09fb3+Pn6+/z9/vkVQXAAAAMaSURBVHhe5dXxV1N1GMfxz2ABbDgIAm5VDJOyVDIJLUMaVpBWUZUaGbmqoGpZRSiGiRWp6KoZ5AB0ZY50RImZQIlahKkMYXv/R90dBvET/rJfOr3Ouc8v99zPec59zvf56j+vYKlViSf7250X4Mr3O29Tgq08BdGB4DhcekEJ5YkQKFsgWZdtj9JpV+I8xPjLFqkrsEIqO8PHSpis36jWazcqjEsfJjkvRssVU37SdIOu4XCf5vEJPsnwJpnRNU9JmxhMk8l1gehIrq7hTFjzOD+Vf88629qKMJVNltInFeRexRQyJlNeqd1iGDlSzrIUIyXbyFfm3RYprcQRe7lqtWyGYbfc6dT0R2vmdOOkX3u55C1rP37ftiH+tDby4r/RBT0w8TyEkr+epB9XgPDmSYYWbrhCuFYaIyw3fDQAXTnSkh+ANofiHmWf9l+FY1I90FdQTetstO00o23novzVsJ7uB3/C5TkbjRwZ5JerwV4iRWq9HFbFMaK/d0TYqayRiQPuIxxS3Bu8JWU90/60tKi7vkhaznez0a/TbVOKj5CaOZh6fWG6/Lyv9B/ZLR1gw/S/fpbeVD3MCW1li6SvWDOn65tr99/uvWtBS0XDm4s1t+sOHpG0kpBKx/l77wOSnxLpcx6TXmXLTPQOKYOf9Q1dfr8/SJ2mFdCvl1Yl93DiHUZvXeLJbGSzYu5gVJ2slbSakOR8dxCq5adQ2oFLqsE9Ex3L4qQO0eOPeU5x56bypXp4onSEb5OkICX6lDat55TeoztNKQcJaakrz9KCb95oD69IKq+yKW4XPjknaS52V0TZqE2cTtXjcHSCRmUO88e+85hj3EP74i9p8pylw7lxgMDyyl6OV7ZejnjNMfatu87LxRbH0IS35gt2a4ZjmGpVBdKK3Wr6INk8jWWSGqbA55CKgjBRC6E9w78ydTg3ABS3AFV1QN0Y4Aa2pgEjWnQURj9L0ayK6R2ysEqxHUKzYnLvvyU+i9KM2JHJzE4vyZOyDcOwOsySajeLPc8sNvPJkFlyJd20wpqAzZeAfZ3oWybxd+P/3j+SG3uSBdf2VQAAAABJRU5ErkJggg==') no-repeat; background: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgdmVyc2lvbj0iMS4xIgogICB3aWR0aD0iNjgxLjk2MjUyIgogICBoZWlnaHQ9IjE4Ny41IgogICBpZD0ic3ZnMiIKICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhOCI+PHJkZjpSREY+PGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPjxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PjxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz48L2NjOldvcms+PC9yZGY6UkRGPjwvbWV0YWRhdGE+PGRlZnMKICAgICBpZD0iZGVmczYiPjxjbGlwUGF0aAogICAgICAgaWQ9ImNsaXBQYXRoMTgiPjxwYXRoCiAgICAgICAgIGQ9Ik0gMCwxNTAwIDAsMCBsIDU0NTUuNzQsMCAwLDE1MDAgTCAwLDE1MDAgeiIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgaWQ9InBhdGgyMCIgLz48L2NsaXBQYXRoPjwvZGVmcz48ZwogICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMjUsMCwwLC0xLjI1LDAsMTg3LjUpIgogICAgIGlkPSJnMTAiPjxnCiAgICAgICB0cmFuc2Zvcm09InNjYWxlKDAuMSwwLjEpIgogICAgICAgaWQ9ImcxMiI+PGcKICAgICAgICAgaWQ9ImcxNCI+PGcKICAgICAgICAgICBjbGlwLXBhdGg9InVybCgjY2xpcFBhdGgxOCkiCiAgICAgICAgICAgaWQ9ImcxNiI+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTU0NCw1OTkuNDM0IGMgMC45MiwtNDAuMzUyIDI1LjY4LC04MS42MDIgNzEuNTMsLTgxLjYwMiAyNy41MSwwIDQ3LjY4LDEyLjgzMiA2MS40NCwzNS43NTQgMTIuODMsMjIuOTMgMTIuODMsNTYuODUyIDEyLjgzLDgyLjUyNyBsIDAsMzI5LjE4NCAtNzEuNTIsMCAwLDEwNC41NDMgMjY2LjgzLDAgMCwtMTA0LjU0MyAtNzAuNiwwIDAsLTM0NC43NyBjIDAsLTU4LjY5MSAtMy42OCwtMTA0LjUzMSAtNDQuOTMsLTE1Mi4yMTggLTM2LjY4LC00Mi4xOCAtOTYuMjgsLTY2LjAyIC0xNTMuMTQsLTY2LjAyIC0xMTcuMzcsMCAtMjA3LjI0LDc3Ljk0MSAtMjAyLjY0LDE5Ny4xNDUgbCAxMzAuMiwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMjIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDIzMDEuNCw2NjIuNjk1IGMgMCw4MC43MDMgLTY2Ljk0LDE0NS44MTMgLTE0Ny42MywxNDUuODEzIC04My40NCwwIC0xNDcuNjMsLTY4Ljc4MSAtMTQ3LjYzLC0xNTEuMzAxIDAsLTc5Ljc4NSA2Ni45NCwtMTQ1LjgwMSAxNDUuOCwtMTQ1LjgwMSA4NC4zNSwwIDE0OS40Niw2Ny44NTIgMTQ5LjQ2LDE1MS4yODkgeiBtIC0xLjgzLC0xODEuNTQ3IGMgLTM1Ljc3LC01NC4wOTcgLTkzLjUzLC03OC44NTkgLTE1Ny43MiwtNzguODU5IC0xNDAuMywwIC0yNTEuMjQsMTE2LjQ0OSAtMjUxLjI0LDI1NC45MTggMCwxNDIuMTI5IDExMy43LDI2MC40MSAyNTYuNzQsMjYwLjQxIDYzLjI3LDAgMTE4LjI5LC0yOS4zMzYgMTUyLjIyLC04Mi41MjMgbCAwLDY5LjY4NyAxNzUuMTQsMCAwLC0xMDQuNTI3IC02MS40NCwwIDAsLTI4MC41OTggNjEuNDQsMCAwLC0xMDQuNTI3IC0xNzUuMTQsMCAwLDY2LjAxOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAyNjIyLjMzLDU1Ny4yNTggYyAzLjY3LC00NC4wMTYgMzMuMDEsLTczLjM0OCA3OC44NiwtNzMuMzQ4IDMzLjkzLDAgNjYuOTMsMjMuODI0IDY2LjkzLDYwLjUwNCAwLDQ4LjYwNiAtNDUuODQsNTYuODU2IC04My40NCw2Ni45NDEgLTg1LjI4LDIyLjAwNCAtMTc4LjgxLDQ4LjYwNiAtMTc4LjgxLDE1NS44NzkgMCw5My41MzYgNzguODYsMTQ3LjYzMyAxNjUuOTgsMTQ3LjYzMyA0NCwwIDgzLjQzLC05LjE3NiAxMTAuOTQsLTQ0LjAwOCBsIDAsMzMuOTIyIDgyLjUzLDAgMCwtMTMyLjk2NSAtMTA4LjIxLDAgYyAtMS44MywzNC44NTYgLTI4LjQyLDU3Ljc3NCAtNjMuMjYsNTcuNzc0IC0zMC4yNiwwIC02Mi4zNSwtMTcuNDIyIC02Mi4zNSwtNTEuMzQ4IDAsLTQ1Ljg0NyA0NC45MywtNTUuOTMgODAuNjksLTY0LjE4IDg4LjAyLC0yMC4xNzUgMTgyLjQ3LC00Ny42OTUgMTgyLjQ3LC0xNTcuNzM0IDAsLTk5LjAyNyAtODMuNDQsLTE1NC4wMzkgLTE3NS4xMywtMTU0LjAzOSAtNDkuNTMsMCAtOTQuNDYsMTUuNTgyIC0xMjYuNTUsNTMuMTggbCAwLC00MC4zNCAtODUuMjcsMCAwLDE0Mi4xMjkgMTE0LjYyLDAiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGgyNiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMjk4OC4xOCw4MDAuMjU0IC02My4yNiwwIDAsMTA0LjUyNyAxNjUuMDUsMCAwLC03My4zNTUgYyAzMS4xOCw1MS4zNDcgNzguODYsODUuMjc3IDE0MS4yMSw4NS4yNzcgNjcuODUsMCAxMjQuNzEsLTQxLjI1OCAxNTIuMjEsLTEwMi42OTkgMjYuNiw2Mi4zNTEgOTIuNjIsMTAyLjY5OSAxNjAuNDcsMTAyLjY5OSA1My4xOSwwIDEwNS40NiwtMjIgMTQxLjIxLC02Mi4zNTEgMzguNTIsLTQ0LjkzOCAzOC41MiwtOTMuNTMyIDM4LjUyLC0xNDkuNDU3IGwgMCwtMTg1LjIzOSA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40MiwwIDAsMTA0LjUyNyA2My4yOCwwIDAsMTU3LjcxNSBjIDAsMzIuMTAyIDAsNjAuNTI3IC0xNC42Nyw4OC45NTcgLTE4LjM0LDI2LjU4MiAtNDguNjEsNDAuMzQ0IC03OS43Nyw0MC4zNDQgLTMwLjI2LDAgLTYzLjI4LC0xMi44NDQgLTgyLjUzLC0zNi42NzIgLTIyLjkzLC0yOS4zNTUgLTIyLjkzLC01Ni44NjMgLTIyLjkzLC05Mi42MjkgbCAwLC0xNTcuNzE1IDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM4LjQxLDAgMCwxMDQuNTI3IDYzLjI4LDAgMCwxNTAuMzgzIGMgMCwyOS4zNDggMCw2Ni4wMjMgLTE0LjY3LDkxLjY5OSAtMTUuNTksMjkuMzM2IC00Ny42OSw0NC45MzQgLTgwLjcsNDQuOTM0IC0zMS4xOCwwIC01Ny43NywtMTEuMDA4IC03Ny45NCwtMzUuNzc0IC0yNC43NywtMzAuMjUzIC0yNi42LC02Mi4zNDMgLTI2LjYsLTk5Ljk0MSBsIDAsLTE1MS4zMDEgNjMuMjcsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNiwwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDI4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSAzOTk4LjY2LDk1MS41NDcgLTExMS44NywwIDAsMTE4LjI5MyAxMTEuODcsMCAwLC0xMTguMjkzIHogbSAwLC00MzEuODkxIDYzLjI3LDAgMCwtMTA0LjUyNyAtMjM5LjMzLDAgMCwxMDQuNTI3IDY0LjE5LDAgMCwyODAuNTk4IC02My4yNywwIDAsMTA0LjUyNyAxNzUuMTQsMCAwLC0zODUuMTI1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzAiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDQxNTkuMTIsODAwLjI1NCAtNjMuMjcsMCAwLDEwNC41MjcgMTc1LjE0LDAgMCwtNjkuNjg3IGMgMjkuMzUsNTQuMTAxIDg0LjM2LDgwLjY5OSAxNDQuODcsODAuNjk5IDUzLjE5LDAgMTA1LjQ1LC0yMi4wMTYgMTQxLjIyLC02MC41MjcgNDAuMzQsLTQ0LjkzNCA0MS4yNiwtODguMDMyIDQxLjI2LC0xNDMuOTU3IGwgMCwtMTkxLjY1MyA2My4yNywwIDAsLTEwNC41MjcgLTIzOC40LDAgMCwxMDQuNTI3IDYzLjI2LDAgMCwxNTguNjM3IGMgMCwzMC4yNjIgMCw2MS40MzQgLTE5LjI2LDg4LjAzNSAtMjAuMTcsMjYuNTgyIC01My4xOCwzOS40MTQgLTg2LjE5LDM5LjQxNCAtMzMuOTMsMCAtNjguNzcsLTEzLjc1IC04OC45NCwtNDEuMjUgLTIxLjA5LC0yNy41IC0yMS4wOSwtNjkuNjg3IC0yMS4wOSwtMTAyLjcwNyBsIDAsLTE0Mi4xMjkgNjMuMjYsMCAwLC0xMDQuNTI3IC0yMzguNCwwIDAsMTA0LjUyNyA2My4yNywwIDAsMjgwLjU5OCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDMyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA1MDgyLjQ4LDcwMy45NjUgYyAtMTkuMjQsNzAuNjA1IC04MS42LDExNS41NDcgLTE1NC4wNCwxMTUuNTQ3IC02Ni4wNCwwIC0xMjkuMywtNTEuMzQ4IC0xNDMuMDUsLTExNS41NDcgbCAyOTcuMDksMCB6IG0gODUuMjcsLTE0NC44ODMgYyAtMzguNTEsLTkzLjUyMyAtMTI5LjI3LC0xNTYuNzkzIC0yMzEuMDUsLTE1Ni43OTMgLTE0My4wNywwIC0yNTcuNjgsMTExLjg3MSAtMjU3LjY4LDI1NS44MzYgMCwxNDQuODgzIDEwOS4xMiwyNjEuMzI4IDI1NC45MSwyNjEuMzI4IDY3Ljg3LDAgMTM1LjcyLC0zMC4yNTggMTgzLjM5LC03OC44NjMgNDguNjIsLTUxLjM0NCA2OC43OSwtMTEzLjY5NSA2OC43OSwtMTgzLjM4MyBsIC0zLjY3LC0zOS40MzQgLTM5Ni4xMywwIGMgMTQuNjcsLTY3Ljg2MyA3Ny4wMywtMTE3LjM2MyAxNDYuNzIsLTExNy4zNjMgNDguNTksMCA5MC43NiwxOC4zMjggMTE4LjI4LDU4LjY3MiBsIDExNi40NCwwIgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDY5MC44OTUsODUwLjcwMyA5MC43NSwwIDIyLjU0MywzMS4wMzUgMCwyNDMuMTIyIC0xMzUuODI5LDAgMCwtMjQzLjE0MSAyMi41MzYsLTMxLjAxNiIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDM2IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA2MzIuMzk1LDc0Mi4yNTggMjguMDM5LDg2LjMwNCAtMjIuNTUxLDMxLjA0IC0yMzEuMjIzLDc1LjEyOCAtNDEuOTc2LC0xMjkuMTgzIDIzMS4yNTcsLTc1LjEzNyAzNi40NTQsMTEuODQ4IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoMzgiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDcxNy40NDksNjUzLjEwNSAtNzMuNDEsNTMuMzYgLTM2LjQ4OCwtMTEuODc1IC0xNDIuOTAzLC0xOTYuNjkyIDEwOS44ODMsLTc5LjgyOCAxNDIuOTE4LDE5Ni43MDMgMCwzOC4zMzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0MCIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gODI4LjUyLDcwNi40NjUgLTczLjQyNiwtNTMuMzQgMC4wMTEsLTM4LjM1OSBMIDg5OC4wMDQsNDE4LjA3IDEwMDcuOSw0OTcuODk4IDg2NC45NzMsNjk0LjYwOSA4MjguNTIsNzA2LjQ2NSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQyIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA4MTIuMDg2LDgyOC41ODYgMjguMDU1LC04Ni4zMiAzNi40ODQsLTExLjgzNiAyMzEuMjI1LDc1LjExNyAtNDEuOTcsMTI5LjE4MyAtMjMxLjIzOSwtNzUuMTQgLTIyLjU1NSwtMzEuMDA0IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNDQiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDczNi4zMDEsMTMzNS44OCBjIC0zMjMuMDQ3LDAgLTU4NS44NzUsLTI2Mi43OCAtNTg1Ljg3NSwtNTg1Ljc4MiAwLC0zMjMuMTE4IDI2Mi44MjgsLTU4NS45NzcgNTg1Ljg3NSwtNTg1Ljk3NyAzMjMuMDE5LDAgNTg1LjgwOSwyNjIuODU5IDU4NS44MDksNTg1Ljk3NyAwLDMyMy4wMDIgLTI2Mi43OSw1ODUuNzgyIC01ODUuODA5LDU4NS43ODIgbCAwLDAgeiBtIDAsLTExOC42MSBjIDI1Ny45NzIsMCA0NjcuMTg5LC0yMDkuMTMgNDY3LjE4OSwtNDY3LjE3MiAwLC0yNTguMTI5IC0yMDkuMjE3LC00NjcuMzQ4IC00NjcuMTg5LC00NjcuMzQ4IC0yNTguMDc0LDAgLTQ2Ny4yNTQsMjA5LjIxOSAtNDY3LjI1NCw0NjcuMzQ4IDAsMjU4LjA0MiAyMDkuMTgsNDY3LjE3MiA0NjcuMjU0LDQ2Ny4xNzIiCiAgICAgICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICAgICAgaWQ9InBhdGg0NiIKICAgICAgICAgICAgIHN0eWxlPSJmaWxsOiM4YTQxODI7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOm5vbnplcm87c3Ryb2tlOm5vbmUiIC8+PHBhdGgKICAgICAgICAgICAgIGQ9Im0gMTA5MS4xMyw2MTkuODgzIC0xNzUuNzcxLDU3LjEyMSAxMS42MjksMzUuODA4IDE3NS43NjIsLTU3LjEyMSAtMTEuNjIsLTM1LjgwOCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDQ4IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA4NjYuOTU3LDkwMi4wNzQgODM2LjUsOTI0LjE5OSA5NDUuMTIxLDEwNzMuNzMgOTc1LjU4NiwxMDUxLjYxIDg2Ni45NTcsOTAyLjA3NCIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDUwIgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0iTSA2MDcuNDY1LDkwMy40NDUgNDk4Ljg1NSwxMDUyLjk3IDUyOS4zMiwxMDc1LjEgNjM3LjkzLDkyNS41NjYgNjA3LjQ2NSw5MDMuNDQ1IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTIiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjxwYXRoCiAgICAgICAgICAgICBkPSJtIDM4MC42ODgsNjIyLjEyOSAtMTEuNjI2LDM1LjgwMSAxNzUuNzU4LDU3LjA5IDExLjYyMSwtMzUuODAxIC0xNzUuNzUzLC01Ny4wOSIKICAgICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgICBpZD0icGF0aDU0IgogICAgICAgICAgICAgc3R5bGU9ImZpbGw6IzhhNDE4MjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6bm9uemVybztzdHJva2U6bm9uZSIgLz48cGF0aAogICAgICAgICAgICAgZD0ibSA3MTYuMjg5LDM3Ni41OSAzNy42NDA2LDAgMCwxODQuODE2IC0zNy42NDA2LDAgMCwtMTg0LjgxNiB6IgogICAgICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgICAgICAgIGlkPSJwYXRoNTYiCiAgICAgICAgICAgICBzdHlsZT0iZmlsbDojOGE0MTgyO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lIiAvPjwvZz48L2c+PC9nPjwvZz48L3N2Zz4=') no-repeat, none; -moz-background-size: 100%; -o-background-size: 100%; -webkit-background-size: 100%; background-size: 100%; display: block; float: left; width: 90px; height: 25px; }
.jasmine_html-reporter .jasmine-banner .jasmine-version { margin-left: 14px; position: relative; top: 6px; }
.jasmine_html-reporter #jasmine_content { position: fixed; right: 100%; }
.jasmine_html-reporter .jasmine-version { color: #aaa; }
.jasmine_html-reporter .jasmine-banner { margin-top: 14px; }
.jasmine_html-reporter .jasmine-duration { color: #fff; float: right; line-height: 28px; padding-right: 9px; }
.jasmine_html-reporter .jasmine-symbol-summary { overflow: hidden; *zoom: 1; margin: 14px 0; }
.jasmine_html-reporter .jasmine-symbol-summary li { display: inline-block; height: 10px; width: 14px; font-size: 16px; }
.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-passed { font-size: 14px; }
.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-passed:before { color: #007069; content: "\02022"; }
.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-failed { line-height: 9px; }
.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-failed:before { color: #ca3a11; content: "\d7"; font-weight: bold; margin-left: -1px; }
.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-disabled { font-size: 14px; }
.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-disabled:before { color: #bababa; content: "\02022"; }
.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-pending { line-height: 17px; }
.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-pending:before { color: #ba9d37; content: "*"; }
.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-empty { font-size: 14px; }
.jasmine_html-reporter .jasmine-symbol-summary li.jasmine-empty:before { color: #ba9d37; content: "\02022"; }
.jasmine_html-reporter .jasmine-run-options { float: right; margin-right: 5px; border: 1px solid #8a4182; color: #8a4182; position: relative; line-height: 20px; }
.jasmine_html-reporter .jasmine-run-options .jasmine-trigger { cursor: pointer; padding: 8px 16px; }
.jasmine_html-reporter .jasmine-run-options .jasmine-payload { position: absolute; display: none; right: -1px; border: 1px solid #8a4182; background-color: #eee; white-space: nowrap; padding: 4px 8px; }
.jasmine_html-reporter .jasmine-run-options .jasmine-payload.jasmine-open { display: block; }
.jasmine_html-reporter .jasmine-bar { line-height: 28px; font-size: 14px; display: block; color: #eee; }
.jasmine_html-reporter .jasmine-bar.jasmine-failed { background-color: #ca3a11; }
.jasmine_html-reporter .jasmine-bar.jasmine-passed { background-color: #007069; }
.jasmine_html-reporter .jasmine-bar.jasmine-skipped { background-color: #bababa; }
.jasmine_html-reporter .jasmine-bar.jasmine-errored { background-color: #ca3a11; }
.jasmine_html-reporter .jasmine-bar.jasmine-menu { background-color: #fff; color: #aaa; }
.jasmine_html-reporter .jasmine-bar.jasmine-menu a { color: #333; }
.jasmine_html-reporter .jasmine-bar a { color: white; }
.jasmine_html-reporter.jasmine-spec-list .jasmine-bar.jasmine-menu.jasmine-failure-list, .jasmine_html-reporter.jasmine-spec-list .jasmine-results .jasmine-failures { display: none; }
.jasmine_html-reporter.jasmine-failure-list .jasmine-bar.jasmine-menu.jasmine-spec-list, .jasmine_html-reporter.jasmine-failure-list .jasmine-summary { display: none; }
.jasmine_html-reporter .jasmine-results { margin-top: 14px; }
.jasmine_html-reporter .jasmine-summary { margin-top: 14px; }
.jasmine_html-reporter .jasmine-summary ul { list-style-type: none; margin-left: 14px; padding-top: 0; padding-left: 0; }
.jasmine_html-reporter .jasmine-summary ul.jasmine-suite { margin-top: 7px; margin-bottom: 7px; }
.jasmine_html-reporter .jasmine-summary li.jasmine-passed a { color: #007069; }
.jasmine_html-reporter .jasmine-summary li.jasmine-failed a { color: #ca3a11; }
.jasmine_html-reporter .jasmine-summary li.jasmine-empty a { color: #ba9d37; }
.jasmine_html-reporter .jasmine-summary li.jasmine-pending a { color: #ba9d37; }
.jasmine_html-reporter .jasmine-summary li.jasmine-disabled a { color: #bababa; }
.jasmine_html-reporter .jasmine-description + .jasmine-suite { margin-top: 0; }
.jasmine_html-reporter .jasmine-suite { margin-top: 14px; }
.jasmine_html-reporter .jasmine-suite a { color: #333; }
.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail { margin-bottom: 28px; }
.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail .jasmine-description { background-color: #ca3a11; }
.jasmine_html-reporter .jasmine-failures .jasmine-spec-detail .jasmine-description a { color: white; }
.jasmine_html-reporter .jasmine-result-message { padding-top: 14px; color: #333; white-space: pre; }
.jasmine_html-reporter .jasmine-result-message span.jasmine-result { display: block; }
.jasmine_html-reporter .jasmine-stack-trace { margin: 5px 0 0 0; max-height: 224px; overflow: auto; line-height: 18px; color: #666; border: 1px solid #ddd; background: white; white-space: pre; }


Node-path: trunk/sumatoria-cubo/WebContent/dependencias/jasmine.js
Node-kind: file
Node-action: add
Text-content-md5: c9067cede1ee3c27129dc0f0afdc611f
Text-content-sha1: 916005cc407925f4764668d61d04888d59258f5d
Prop-content-length: 10
Text-content-length: 97717
Content-length: 97727

PROPS-END
/*
Copyright (c) 2008-2016 Pivotal Labs

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var getJasmineRequireObj = (function (jasmineGlobal) {
  var jasmineRequire;

  if (typeof module !== 'undefined' && module.exports && typeof exports !== 'undefined') {
    if (typeof global !== 'undefined') {
      jasmineGlobal = global;
    } else {
      jasmineGlobal = {};
    }
    jasmineRequire = exports;
  } else {
    if (typeof window !== 'undefined' && typeof window.toString === 'function' && window.toString() === '[object GjsGlobal]') {
      jasmineGlobal = window;
    }
    jasmineRequire = jasmineGlobal.jasmineRequire = jasmineGlobal.jasmineRequire || {};
  }

  function getJasmineRequire() {
    return jasmineRequire;
  }

  getJasmineRequire().core = function(jRequire) {
    var j$ = {};

    jRequire.base(j$, jasmineGlobal);
    j$.util = jRequire.util();
    j$.errors = jRequire.errors();
    j$.formatErrorMsg = jRequire.formatErrorMsg();
    j$.Any = jRequire.Any(j$);
    j$.Anything = jRequire.Anything(j$);
    j$.CallTracker = jRequire.CallTracker(j$);
    j$.MockDate = jRequire.MockDate();
    j$.Clock = jRequire.Clock();
    j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();
    j$.Env = jRequire.Env(j$);
    j$.ExceptionFormatter = jRequire.ExceptionFormatter();
    j$.Expectation = jRequire.Expectation();
    j$.buildExpectationResult = jRequire.buildExpectationResult();
    j$.JsApiReporter = jRequire.JsApiReporter();
    j$.matchersUtil = jRequire.matchersUtil(j$);
    j$.ObjectContaining = jRequire.ObjectContaining(j$);
    j$.ArrayContaining = jRequire.ArrayContaining(j$);
    j$.pp = jRequire.pp(j$);
    j$.QueueRunner = jRequire.QueueRunner(j$);
    j$.ReportDispatcher = jRequire.ReportDispatcher();
    j$.Spec = jRequire.Spec(j$);
    j$.SpyRegistry = jRequire.SpyRegistry(j$);
    j$.SpyStrategy = jRequire.SpyStrategy(j$);
    j$.StringMatching = jRequire.StringMatching(j$);
    j$.Suite = jRequire.Suite(j$);
    j$.Timer = jRequire.Timer();
    j$.TreeProcessor = jRequire.TreeProcessor();
    j$.version = jRequire.version();
    j$.Order = jRequire.Order();

    j$.matchers = jRequire.requireMatchers(jRequire, j$);

    return j$;
  };

  return getJasmineRequire;
})(this);

getJasmineRequireObj().requireMatchers = function(jRequire, j$) {
  var availableMatchers = [
      'toBe',
      'toBeCloseTo',
      'toBeDefined',
      'toBeFalsy',
      'toBeGreaterThan',
      'toBeGreaterThanOrEqual',
      'toBeLessThanOrEqual',
      'toBeLessThan',
      'toBeNaN',
      'toBeNull',
      'toBeTruthy',
      'toBeUndefined',
      'toContain',
      'toEqual',
      'toHaveBeenCalled',
      'toHaveBeenCalledWith',
      'toHaveBeenCalledTimes',
      'toMatch',
      'toThrow',
      'toThrowError'
    ],
    matchers = {};

  for (var i = 0; i < availableMatchers.length; i++) {
    var name = availableMatchers[i];
    matchers[name] = jRequire[name](j$);
  }

  return matchers;
};

getJasmineRequireObj().base = function(j$, jasmineGlobal) {
  j$.unimplementedMethod_ = function() {
    throw new Error('unimplemented method');
  };

  j$.MAX_PRETTY_PRINT_DEPTH = 40;
  j$.MAX_PRETTY_PRINT_ARRAY_LENGTH = 100;
  j$.DEFAULT_TIMEOUT_INTERVAL = 5000;

  j$.getGlobal = function() {
    return jasmineGlobal;
  };

  j$.getEnv = function(options) {
    var env = j$.currentEnv_ = j$.currentEnv_ || new j$.Env(options);
    //jasmine. singletons in here (setTimeout blah blah).
    return env;
  };

  j$.isArray_ = function(value) {
    return j$.isA_('Array', value);
  };

  j$.isString_ = function(value) {
    return j$.isA_('String', value);
  };

  j$.isNumber_ = function(value) {
    return j$.isA_('Number', value);
  };

  j$.isFunction_ = function(value) {
    return j$.isA_('Function', value);
  };

  j$.isA_ = function(typeName, value) {
    return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';
  };

  j$.isDomNode = function(obj) {
    return obj.nodeType > 0;
  };

  j$.fnNameFor = function(func) {
    if (func.name) {
      return func.name;
    }

    var matches = func.toString().match(/^\s*function\s*(\w*)\s*\(/);
    return matches ? matches[1] : '<anonymous>';
  };

  j$.any = function(clazz) {
    return new j$.Any(clazz);
  };

  j$.anything = function() {
    return new j$.Anything();
  };

  j$.objectContaining = function(sample) {
    return new j$.ObjectContaining(sample);
  };

  j$.stringMatching = function(expected) {
    return new j$.StringMatching(expected);
  };

  j$.arrayContaining = function(sample) {
    return new j$.ArrayContaining(sample);
  };

  j$.createSpy = function(name, originalFn) {

    var spyStrategy = new j$.SpyStrategy({
        name: name,
        fn: originalFn,
        getSpy: function() { return spy; }
      }),
      callTracker = new j$.CallTracker(),
      spy = function() {
        var callData = {
          object: this,
          args: Array.prototype.slice.apply(arguments)
        };

        callTracker.track(callData);
        var returnValue = spyStrategy.exec.apply(this, arguments);
        callData.returnValue = returnValue;

        return returnValue;
      };

    for (var prop in originalFn) {
      if (prop === 'and' || prop === 'calls') {
        throw new Error('Jasmine spies would overwrite the \'and\' and \'calls\' properties on the object being spied upon');
      }

      spy[prop] = originalFn[prop];
    }

    spy.and = spyStrategy;
    spy.calls = callTracker;

    return spy;
  };

  j$.isSpy = function(putativeSpy) {
    if (!putativeSpy) {
      return false;
    }
    return putativeSpy.and instanceof j$.SpyStrategy &&
      putativeSpy.calls instanceof j$.CallTracker;
  };

  j$.createSpyObj = function(baseName, methodNames) {
    if (j$.isArray_(baseName) && j$.util.isUndefined(methodNames)) {
      methodNames = baseName;
      baseName = 'unknown';
    }

    if (!j$.isArray_(methodNames) || methodNames.length === 0) {
      throw 'createSpyObj requires a non-empty array of method names to create spies for';
    }
    var obj = {};
    for (var i = 0; i < methodNames.length; i++) {
      obj[methodNames[i]] = j$.createSpy(baseName + '.' + methodNames[i]);
    }
    return obj;
  };
};

getJasmineRequireObj().util = function() {

  var util = {};

  util.inherit = function(childClass, parentClass) {
    var Subclass = function() {
    };
    Subclass.prototype = parentClass.prototype;
    childClass.prototype = new Subclass();
  };

  util.htmlEscape = function(str) {
    if (!str) {
      return str;
    }
    return str.replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
  };

  util.argsToArray = function(args) {
    var arrayOfArgs = [];
    for (var i = 0; i < args.length; i++) {
      arrayOfArgs.push(args[i]);
    }
    return arrayOfArgs;
  };

  util.isUndefined = function(obj) {
    return obj === void 0;
  };

  util.arrayContains = function(array, search) {
    var i = array.length;
    while (i--) {
      if (array[i] === search) {
        return true;
      }
    }
    return false;
  };

  util.clone = function(obj) {
    if (Object.prototype.toString.apply(obj) === '[object Array]') {
      return obj.slice();
    }

    var cloned = {};
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        cloned[prop] = obj[prop];
      }
    }

    return cloned;
  };

  return util;
};

getJasmineRequireObj().Spec = function(j$) {
  function Spec(attrs) {
    this.expectationFactory = attrs.expectationFactory;
    this.resultCallback = attrs.resultCallback || function() {};
    this.id = attrs.id;
    this.description = attrs.description || '';
    this.queueableFn = attrs.queueableFn;
    this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };
    this.userContext = attrs.userContext || function() { return {}; };
    this.onStart = attrs.onStart || function() {};
    this.getSpecName = attrs.getSpecName || function() { return ''; };
    this.expectationResultFactory = attrs.expectationResultFactory || function() { };
    this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};
    this.catchingExceptions = attrs.catchingExceptions || function() { return true; };
    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;

    if (!this.queueableFn.fn) {
      this.pend();
    }

    this.result = {
      id: this.id,
      description: this.description,
      fullName: this.getFullName(),
      failedExpectations: [],
      passedExpectations: [],
      pendingReason: ''
    };
  }

  Spec.prototype.addExpectationResult = function(passed, data, isError) {
    var expectationResult = this.expectationResultFactory(data);
    if (passed) {
      this.result.passedExpectations.push(expectationResult);
    } else {
      this.result.failedExpectations.push(expectationResult);

      if (this.throwOnExpectationFailure && !isError) {
        throw new j$.errors.ExpectationFailed();
      }
    }
  };

  Spec.prototype.expect = function(actual) {
    return this.expectationFactory(actual, this);
  };

  Spec.prototype.execute = function(onComplete, enabled) {
    var self = this;

    this.onStart(this);

    if (!this.isExecutable() || this.markedPending || enabled === false) {
      complete(enabled);
      return;
    }

    var fns = this.beforeAndAfterFns();
    var allFns = fns.befores.concat(this.queueableFn).concat(fns.afters);

    this.queueRunnerFactory({
      queueableFns: allFns,
      onException: function() { self.onException.apply(self, arguments); },
      onComplete: complete,
      userContext: this.userContext()
    });

    function complete(enabledAgain) {
      self.result.status = self.status(enabledAgain);
      self.resultCallback(self.result);

      if (onComplete) {
        onComplete();
      }
    }
  };

  Spec.prototype.onException = function onException(e) {
    if (Spec.isPendingSpecException(e)) {
      this.pend(extractCustomPendingMessage(e));
      return;
    }

    if (e instanceof j$.errors.ExpectationFailed) {
      return;
    }

    this.addExpectationResult(false, {
      matcherName: '',
      passed: false,
      expected: '',
      actual: '',
      error: e
    }, true);
  };

  Spec.prototype.disable = function() {
    this.disabled = true;
  };

  Spec.prototype.pend = function(message) {
    this.markedPending = true;
    if (message) {
      this.result.pendingReason = message;
    }
  };

  Spec.prototype.getResult = function() {
    this.result.status = this.status();
    return this.result;
  };

  Spec.prototype.status = function(enabled) {
    if (this.disabled || enabled === false) {
      return 'disabled';
    }

    if (this.markedPending) {
      return 'pending';
    }

    if (this.result.failedExpectations.length > 0) {
      return 'failed';
    } else {
      return 'passed';
    }
  };

  Spec.prototype.isExecutable = function() {
    return !this.disabled;
  };

  Spec.prototype.getFullName = function() {
    return this.getSpecName(this);
  };

  var extractCustomPendingMessage = function(e) {
    var fullMessage = e.toString(),
        boilerplateStart = fullMessage.indexOf(Spec.pendingSpecExceptionMessage),
        boilerplateEnd = boilerplateStart + Spec.pendingSpecExceptionMessage.length;

    return fullMessage.substr(boilerplateEnd);
  };

  Spec.pendingSpecExceptionMessage = '=> marked Pending';

  Spec.isPendingSpecException = function(e) {
    return !!(e && e.toString && e.toString().indexOf(Spec.pendingSpecExceptionMessage) !== -1);
  };

  return Spec;
};

if (typeof window == void 0 && typeof exports == 'object') {
  exports.Spec = jasmineRequire.Spec;
}

/*jshint bitwise: false*/

getJasmineRequireObj().Order = function() {
  function Order(options) {
    this.random = 'random' in options ? options.random : true;
    var seed = this.seed = options.seed || generateSeed();
    this.sort = this.random ? randomOrder : naturalOrder;

    function naturalOrder(items) {
      return items;
    }

    function randomOrder(items) {
      var copy = items.slice();
      copy.sort(function(a, b) {
        return jenkinsHash(seed + a.id) - jenkinsHash(seed + b.id);
      });
      return copy;
    }

    function generateSeed() {
      return String(Math.random()).slice(-5);
    }

    // Bob Jenkins One-at-a-Time Hash algorithm is a non-cryptographic hash function
    // used to get a different output when the key changes slighly.
    // We use your return to sort the children randomly in a consistent way when
    // used in conjunction with a seed

    function jenkinsHash(key) {
      var hash, i;
      for(hash = i = 0; i < key.length; ++i) {
        hash += key.charCodeAt(i);
        hash += (hash << 10);
        hash ^= (hash >> 6);
      }
      hash += (hash << 3);
      hash ^= (hash >> 11);
      hash += (hash << 15);
      return hash;
    }

  }

  return Order;
};

getJasmineRequireObj().Env = function(j$) {
  function Env(options) {
    options = options || {};

    var self = this;
    var global = options.global || j$.getGlobal();

    var totalSpecsDefined = 0;

    var catchExceptions = true;

    var realSetTimeout = j$.getGlobal().setTimeout;
    var realClearTimeout = j$.getGlobal().clearTimeout;
    this.clock = new j$.Clock(global, function () { return new j$.DelayedFunctionScheduler(); }, new j$.MockDate(global));

    var runnableResources = {};

    var currentSpec = null;
    var currentlyExecutingSuites = [];
    var currentDeclarationSuite = null;
    var throwOnExpectationFailure = false;
    var random = false;
    var seed = null;

    var currentSuite = function() {
      return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];
    };

    var currentRunnable = function() {
      return currentSpec || currentSuite();
    };

    var reporter = new j$.ReportDispatcher([
      'jasmineStarted',
      'jasmineDone',
      'suiteStarted',
      'suiteDone',
      'specStarted',
      'specDone'
    ]);

    this.specFilter = function() {
      return true;
    };

    this.addCustomEqualityTester = function(tester) {
      if(!currentRunnable()) {
        throw new Error('Custom Equalities must be added in a before function or a spec');
      }
      runnableResources[currentRunnable().id].customEqualityTesters.push(tester);
    };

    this.addMatchers = function(matchersToAdd) {
      if(!currentRunnable()) {
        throw new Error('Matchers must be added in a before function or a spec');
      }
      var customMatchers = runnableResources[currentRunnable().id].customMatchers;
      for (var matcherName in matchersToAdd) {
        customMatchers[matcherName] = matchersToAdd[matcherName];
      }
    };

    j$.Expectation.addCoreMatchers(j$.matchers);

    var nextSpecId = 0;
    var getNextSpecId = function() {
      return 'spec' + nextSpecId++;
    };

    var nextSuiteId = 0;
    var getNextSuiteId = function() {
      return 'suite' + nextSuiteId++;
    };

    var expectationFactory = function(actual, spec) {
      return j$.Expectation.Factory({
        util: j$.matchersUtil,
        customEqualityTesters: runnableResources[spec.id].customEqualityTesters,
        customMatchers: runnableResources[spec.id].customMatchers,
        actual: actual,
        addExpectationResult: addExpectationResult
      });

      function addExpectationResult(passed, result) {
        return spec.addExpectationResult(passed, result);
      }
    };

    var defaultResourcesForRunnable = function(id, parentRunnableId) {
      var resources = {spies: [], customEqualityTesters: [], customMatchers: {}};

      if(runnableResources[parentRunnableId]){
        resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);
        resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);
      }

      runnableResources[id] = resources;
    };

    var clearResourcesForRunnable = function(id) {
        spyRegistry.clearSpies();
        delete runnableResources[id];
    };

    var beforeAndAfterFns = function(suite) {
      return function() {
        var befores = [],
          afters = [];

        while(suite) {
          befores = befores.concat(suite.beforeFns);
          afters = afters.concat(suite.afterFns);

          suite = suite.parentSuite;
        }

        return {
          befores: befores.reverse(),
          afters: afters
        };
      };
    };

    var getSpecName = function(spec, suite) {
      var fullName = [spec.description],
          suiteFullName = suite.getFullName();

      if (suiteFullName !== '') {
        fullName.unshift(suiteFullName);
      }
      return fullName.join(' ');
    };

    // TODO: we may just be able to pass in the fn instead of wrapping here
    var buildExpectationResult = j$.buildExpectationResult,
        exceptionFormatter = new j$.ExceptionFormatter(),
        expectationResultFactory = function(attrs) {
          attrs.messageFormatter = exceptionFormatter.message;
          attrs.stackFormatter = exceptionFormatter.stack;

          return buildExpectationResult(attrs);
        };

    // TODO: fix this naming, and here's where the value comes in
    this.catchExceptions = function(value) {
      catchExceptions = !!value;
      return catchExceptions;
    };

    this.catchingExceptions = function() {
      return catchExceptions;
    };

    var maximumSpecCallbackDepth = 20;
    var currentSpecCallbackDepth = 0;

    function clearStack(fn) {
      currentSpecCallbackDepth++;
      if (currentSpecCallbackDepth >= maximumSpecCallbackDepth) {
        currentSpecCallbackDepth = 0;
        realSetTimeout(fn, 0);
      } else {
        fn();
      }
    }

    var catchException = function(e) {
      return j$.Spec.isPendingSpecException(e) || catchExceptions;
    };

    this.throwOnExpectationFailure = function(value) {
      throwOnExpectationFailure = !!value;
    };

    this.throwingExpectationFailures = function() {
      return throwOnExpectationFailure;
    };

    this.randomizeTests = function(value) {
      random = !!value;
    };

    this.randomTests = function() {
      return random;
    };

    this.seed = function(value) {
      if (value) {
        seed = value;
      }
      return seed;
    };

    var queueRunnerFactory = function(options) {
      options.catchException = catchException;
      options.clearStack = options.clearStack || clearStack;
      options.timeout = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};
      options.fail = self.fail;

      new j$.QueueRunner(options).execute();
    };

    var topSuite = new j$.Suite({
      env: this,
      id: getNextSuiteId(),
      description: 'Jasmine__TopLevel__Suite',
      expectationFactory: expectationFactory,
      expectationResultFactory: expectationResultFactory
    });
    defaultResourcesForRunnable(topSuite.id);
    currentDeclarationSuite = topSuite;

    this.topSuite = function() {
      return topSuite;
    };

    this.execute = function(runnablesToRun) {
      if(!runnablesToRun) {
        if (focusedRunnables.length) {
          runnablesToRun = focusedRunnables;
        } else {
          runnablesToRun = [topSuite.id];
        }
      }

      var order = new j$.Order({
        random: random,
        seed: seed
      });

      var processor = new j$.TreeProcessor({
        tree: topSuite,
        runnableIds: runnablesToRun,
        queueRunnerFactory: queueRunnerFactory,
        nodeStart: function(suite) {
          currentlyExecutingSuites.push(suite);
          defaultResourcesForRunnable(suite.id, suite.parentSuite.id);
          reporter.suiteStarted(suite.result);
        },
        nodeComplete: function(suite, result) {
          if (!suite.disabled) {
            clearResourcesForRunnable(suite.id);
          }
          currentlyExecutingSuites.pop();
          reporter.suiteDone(result);
        },
        orderChildren: function(node) {
          return order.sort(node.children);
        }
      });

      if(!processor.processTree().valid) {
        throw new Error('Invalid order: would cause a beforeAll or afterAll to be run multiple times');
      }

      reporter.jasmineStarted({
        totalSpecsDefined: totalSpecsDefined
      });

      currentlyExecutingSuites.push(topSuite);

      processor.execute(function() {
        clearResourcesForRunnable(topSuite.id);
        currentlyExecutingSuites.pop();

        reporter.jasmineDone({
          order: order,
          failedExpectations: topSuite.result.failedExpectations
        });
      });
    };

    this.addReporter = function(reporterToAdd) {
      reporter.addReporter(reporterToAdd);
    };

    this.provideFallbackReporter = function(reporterToAdd) {
      reporter.provideFallbackReporter(reporterToAdd);
    };

    this.clearReporters = function() {
      reporter.clearReporters();
    };

    var spyRegistry = new j$.SpyRegistry({currentSpies: function() {
      if(!currentRunnable()) {
        throw new Error('Spies must be created in a before function or a spec');
      }
      return runnableResources[currentRunnable().id].spies;
    }});

    this.allowRespy = function(allow){
      spyRegistry.allowRespy(allow);
    };

    this.spyOn = function() {
      return spyRegistry.spyOn.apply(spyRegistry, arguments);
    };

    var suiteFactory = function(description) {
      var suite = new j$.Suite({
        env: self,
        id: getNextSuiteId(),
        description: description,
        parentSuite: currentDeclarationSuite,
        expectationFactory: expectationFactory,
        expectationResultFactory: expectationResultFactory,
        throwOnExpectationFailure: throwOnExpectationFailure
      });

      return suite;
    };

    this.describe = function(description, specDefinitions) {
      var suite = suiteFactory(description);
      if (specDefinitions.length > 0) {
        throw new Error('describe does not expect any arguments');
      }
      if (currentDeclarationSuite.markedPending) {
        suite.pend();
      }
      addSpecsToSuite(suite, specDefinitions);
      return suite;
    };

    this.xdescribe = function(description, specDefinitions) {
      var suite = suiteFactory(description);
      suite.pend();
      addSpecsToSuite(suite, specDefinitions);
      return suite;
    };

    var focusedRunnables = [];

    this.fdescribe = function(description, specDefinitions) {
      var suite = suiteFactory(description);
      suite.isFocused = true;

      focusedRunnables.push(suite.id);
      unfocusAncestor();
      addSpecsToSuite(suite, specDefinitions);

      return suite;
    };

    function addSpecsToSuite(suite, specDefinitions) {
      var parentSuite = currentDeclarationSuite;
      parentSuite.addChild(suite);
      currentDeclarationSuite = suite;

      var declarationError = null;
      try {
        specDefinitions.call(suite);
      } catch (e) {
        declarationError = e;
      }

      if (declarationError) {
        self.it('encountered a declaration exception', function() {
          throw declarationError;
        });
      }

      currentDeclarationSuite = parentSuite;
    }

    function findFocusedAncestor(suite) {
      while (suite) {
        if (suite.isFocused) {
          return suite.id;
        }
        suite = suite.parentSuite;
      }

      return null;
    }

    function unfocusAncestor() {
      var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);
      if (focusedAncestor) {
        for (var i = 0; i < focusedRunnables.length; i++) {
          if (focusedRunnables[i] === focusedAncestor) {
            focusedRunnables.splice(i, 1);
            break;
          }
        }
      }
    }

    var specFactory = function(description, fn, suite, timeout) {
      totalSpecsDefined++;
      var spec = new j$.Spec({
        id: getNextSpecId(),
        beforeAndAfterFns: beforeAndAfterFns(suite),
        expectationFactory: expectationFactory,
        resultCallback: specResultCallback,
        getSpecName: function(spec) {
          return getSpecName(spec, suite);
        },
        onStart: specStarted,
        description: description,
        expectationResultFactory: expectationResultFactory,
        queueRunnerFactory: queueRunnerFactory,
        userContext: function() { return suite.clonedSharedUserContext(); },
        queueableFn: {
          fn: fn,
          timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }
        },
        throwOnExpectationFailure: throwOnExpectationFailure
      });

      if (!self.specFilter(spec)) {
        spec.disable();
      }

      return spec;

      function specResultCallback(result) {
        clearResourcesForRunnable(spec.id);
        currentSpec = null;
        reporter.specDone(result);
      }

      function specStarted(spec) {
        currentSpec = spec;
        defaultResourcesForRunnable(spec.id, suite.id);
        reporter.specStarted(spec.result);
      }
    };

    this.it = function(description, fn, timeout) {
      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);
      if (currentDeclarationSuite.markedPending) {
        spec.pend();
      }
      currentDeclarationSuite.addChild(spec);
      return spec;
    };

    this.xit = function() {
      var spec = this.it.apply(this, arguments);
      spec.pend('Temporarily disabled with xit');
      return spec;
    };

    this.fit = function(description, fn, timeout){
      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);
      currentDeclarationSuite.addChild(spec);
      focusedRunnables.push(spec.id);
      unfocusAncestor();
      return spec;
    };

    this.expect = function(actual) {
      if (!currentRunnable()) {
        throw new Error('\'expect\' was used when there was no current spec, this could be because an asynchronous test timed out');
      }

      return currentRunnable().expect(actual);
    };

    this.beforeEach = function(beforeEachFunction, timeout) {
      currentDeclarationSuite.beforeEach({
        fn: beforeEachFunction,
        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }
      });
    };

    this.beforeAll = function(beforeAllFunction, timeout) {
      currentDeclarationSuite.beforeAll({
        fn: beforeAllFunction,
        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }
      });
    };

    this.afterEach = function(afterEachFunction, timeout) {
      currentDeclarationSuite.afterEach({
        fn: afterEachFunction,
        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }
      });
    };

    this.afterAll = function(afterAllFunction, timeout) {
      currentDeclarationSuite.afterAll({
        fn: afterAllFunction,
        timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }
      });
    };

    this.pending = function(message) {
      var fullMessage = j$.Spec.pendingSpecExceptionMessage;
      if(message) {
        fullMessage += message;
      }
      throw fullMessage;
    };

    this.fail = function(error) {
      var message = 'Failed';
      if (error) {
        message += ': ';
        message += error.message || error;
      }

      currentRunnable().addExpectationResult(false, {
        matcherName: '',
        passed: false,
        expected: '',
        actual: '',
        message: message,
        error: error && error.message ? error : null
      });
    };
  }

  return Env;
};

getJasmineRequireObj().JsApiReporter = function() {

  var noopTimer = {
    start: function(){},
    elapsed: function(){ return 0; }
  };

  function JsApiReporter(options) {
    var timer = options.timer || noopTimer,
        status = 'loaded';

    this.started = false;
    this.finished = false;
    this.runDetails = {};

    this.jasmineStarted = function() {
      this.started = true;
      status = 'started';
      timer.start();
    };

    var executionTime;

    this.jasmineDone = function(runDetails) {
      this.finished = true;
      this.runDetails = runDetails;
      executionTime = timer.elapsed();
      status = 'done';
    };

    this.status = function() {
      return status;
    };

    var suites = [],
      suites_hash = {};

    this.suiteStarted = function(result) {
      suites_hash[result.id] = result;
    };

    this.suiteDone = function(result) {
      storeSuite(result);
    };

    this.suiteResults = function(index, length) {
      return suites.slice(index, index + length);
    };

    function storeSuite(result) {
      suites.push(result);
      suites_hash[result.id] = result;
    }

    this.suites = function() {
      return suites_hash;
    };

    var specs = [];

    this.specDone = function(result) {
      specs.push(result);
    };

    this.specResults = function(index, length) {
      return specs.slice(index, index + length);
    };

    this.specs = function() {
      return specs;
    };

    this.executionTime = function() {
      return executionTime;
    };

  }

  return JsApiReporter;
};

getJasmineRequireObj().CallTracker = function(j$) {

  function CallTracker() {
    var calls = [];
    var opts = {};

    function argCloner(context) {
      var clonedArgs = [];
      var argsAsArray = j$.util.argsToArray(context.args);
      for(var i = 0; i < argsAsArray.length; i++) {
        if(Object.prototype.toString.apply(argsAsArray[i]).match(/^\[object/)) {
          clonedArgs.push(j$.util.clone(argsAsArray[i]));
        } else {
          clonedArgs.push(argsAsArray[i]);
        }
      }
      context.args = clonedArgs;
    }

    this.track = function(context) {
      if(opts.cloneArgs) {
        argCloner(context);
      }
      calls.push(context);
    };

    this.any = function() {
      return !!calls.length;
    };

    this.count = function() {
      return calls.length;
    };

    this.argsFor = function(index) {
      var call = calls[index];
      return call ? call.args : [];
    };

    this.all = function() {
      return calls;
    };

    this.allArgs = function() {
      var callArgs = [];
      for(var i = 0; i < calls.length; i++){
        callArgs.push(calls[i].args);
      }

      return callArgs;
    };

    this.first = function() {
      return calls[0];
    };

    this.mostRecent = function() {
      return calls[calls.length - 1];
    };

    this.reset = function() {
      calls = [];
    };

    this.saveArgumentsByValue = function() {
      opts.cloneArgs = true;
    };

  }

  return CallTracker;
};

getJasmineRequireObj().Clock = function() {
  function Clock(global, delayedFunctionSchedulerFactory, mockDate) {
    var self = this,
      realTimingFunctions = {
        setTimeout: global.setTimeout,
        clearTimeout: global.clearTimeout,
        setInterval: global.setInterval,
        clearInterval: global.clearInterval
      },
      fakeTimingFunctions = {
        setTimeout: setTimeout,
        clearTimeout: clearTimeout,
        setInterval: setInterval,
        clearInterval: clearInterval
      },
      installed = false,
      delayedFunctionScheduler,
      timer;


    self.install = function() {
      if(!originalTimingFunctionsIntact()) {
        throw new Error('Jasmine Clock was unable to install over custom global timer functions. Is the clock already installed?');
      }
      replace(global, fakeTimingFunctions);
      timer = fakeTimingFunctions;
      delayedFunctionScheduler = delayedFunctionSchedulerFactory();
      installed = true;

      return self;
    };

    self.uninstall = function() {
      delayedFunctionScheduler = null;
      mockDate.uninstall();
      replace(global, realTimingFunctions);

      timer = realTimingFunctions;
      installed = false;
    };

    self.withMock = function(closure) {
      this.install();
      try {
        closure();
      } finally {
        this.uninstall();
      }
    };

    self.mockDate = function(initialDate) {
      mockDate.install(initialDate);
    };

    self.setTimeout = function(fn, delay, params) {
      if (legacyIE()) {
        if (arguments.length > 2) {
          throw new Error('IE < 9 cannot support extra params to setTimeout without a polyfill');
        }
        return timer.setTimeout(fn, delay);
      }
      return Function.prototype.apply.apply(timer.setTimeout, [global, arguments]);
    };

    self.setInterval = function(fn, delay, params) {
      if (legacyIE()) {
        if (arguments.length > 2) {
          throw new Error('IE < 9 cannot support extra params to setInterval without a polyfill');
        }
        return timer.setInterval(fn, delay);
      }
      return Function.prototype.apply.apply(timer.setInterval, [global, arguments]);
    };

    self.clearTimeout = function(id) {
      return Function.prototype.call.apply(timer.clearTimeout, [global, id]);
    };

    self.clearInterval = function(id) {
      return Function.prototype.call.apply(timer.clearInterval, [global, id]);
    };

    self.tick = function(millis) {
      if (installed) {
        delayedFunctionScheduler.tick(millis, function(millis) { mockDate.tick(millis); });
      } else {
        throw new Error('Mock clock is not installed, use jasmine.clock().install()');
      }
    };

    return self;

    function originalTimingFunctionsIntact() {
      return global.setTimeout === realTimingFunctions.setTimeout &&
        global.clearTimeout === realTimingFunctions.clearTimeout &&
        global.setInterval === realTimingFunctions.setInterval &&
        global.clearInterval === realTimingFunctions.clearInterval;
    }

    function legacyIE() {
      //if these methods are polyfilled, apply will be present
      return !(realTimingFunctions.setTimeout || realTimingFunctions.setInterval).apply;
    }

    function replace(dest, source) {
      for (var prop in source) {
        dest[prop] = source[prop];
      }
    }

    function setTimeout(fn, delay) {
      return delayedFunctionScheduler.scheduleFunction(fn, delay, argSlice(arguments, 2));
    }

    function clearTimeout(id) {
      return delayedFunctionScheduler.removeFunctionWithId(id);
    }

    function setInterval(fn, interval) {
      return delayedFunctionScheduler.scheduleFunction(fn, interval, argSlice(arguments, 2), true);
    }

    function clearInterval(id) {
      return delayedFunctionScheduler.removeFunctionWithId(id);
    }

    function argSlice(argsObj, n) {
      return Array.prototype.slice.call(argsObj, n);
    }
  }

  return Clock;
};

getJasmineRequireObj().DelayedFunctionScheduler = function() {
  function DelayedFunctionScheduler() {
    var self = this;
    var scheduledLookup = [];
    var scheduledFunctions = {};
    var currentTime = 0;
    var delayedFnCount = 0;

    self.tick = function(millis, tickDate) {
      millis = millis || 0;
      var endTime = currentTime + millis;

      runScheduledFunctions(endTime, tickDate);
      currentTime = endTime;
    };

    self.scheduleFunction = function(funcToCall, millis, params, recurring, timeoutKey, runAtMillis) {
      var f;
      if (typeof(funcToCall) === 'string') {
        /* jshint evil: true */
        f = function() { return eval(funcToCall); };
        /* jshint evil: false */
      } else {
        f = funcToCall;
      }

      millis = millis || 0;
      timeoutKey = timeoutKey || ++delayedFnCount;
      runAtMillis = runAtMillis || (currentTime + millis);

      var funcToSchedule = {
        runAtMillis: runAtMillis,
        funcToCall: f,
        recurring: recurring,
        params: params,
        timeoutKey: timeoutKey,
        millis: millis
      };

      if (runAtMillis in scheduledFunctions) {
        scheduledFunctions[runAtMillis].push(funcToSchedule);
      } else {
        scheduledFunctions[runAtMillis] = [funcToSchedule];
        scheduledLookup.push(runAtMillis);
        scheduledLookup.sort(function (a, b) {
          return a - b;
        });
      }

      return timeoutKey;
    };

    self.removeFunctionWithId = function(timeoutKey) {
      for (var runAtMillis in scheduledFunctions) {
        var funcs = scheduledFunctions[runAtMillis];
        var i = indexOfFirstToPass(funcs, function (func) {
          return func.timeoutKey === timeoutKey;
        });

        if (i > -1) {
          if (funcs.length === 1) {
            delete scheduledFunctions[runAtMillis];
            deleteFromLookup(runAtMillis);
          } else {
            funcs.splice(i, 1);
          }

          // intervals get rescheduled when executed, so there's never more
          // than a single scheduled function with a given timeoutKey
          break;
        }
      }
    };

    return self;

    function indexOfFirstToPass(array, testFn) {
      var index = -1;

      for (var i = 0; i < array.length; ++i) {
        if (testFn(array[i])) {
          index = i;
          break;
        }
      }

      return index;
    }

    function deleteFromLookup(key) {
      var value = Number(key);
      var i = indexOfFirstToPass(scheduledLookup, function (millis) {
        return millis === value;
      });

      if (i > -1) {
        scheduledLookup.splice(i, 1);
      }
    }

    function reschedule(scheduledFn) {
      self.scheduleFunction(scheduledFn.funcToCall,
        scheduledFn.millis,
        scheduledFn.params,
        true,
        scheduledFn.timeoutKey,
        scheduledFn.runAtMillis + scheduledFn.millis);
    }

    function forEachFunction(funcsToRun, callback) {
      for (var i = 0; i < funcsToRun.length; ++i) {
        callback(funcsToRun[i]);
      }
    }

    function runScheduledFunctions(endTime, tickDate) {
      tickDate = tickDate || function() {};
      if (scheduledLookup.length === 0 || scheduledLookup[0] > endTime) {
        tickDate(endTime - currentTime);
        return;
      }

      do {
        var newCurrentTime = scheduledLookup.shift();
        tickDate(newCurrentTime - currentTime);

        currentTime = newCurrentTime;

        var funcsToRun = scheduledFunctions[currentTime];
        delete scheduledFunctions[currentTime];

        forEachFunction(funcsToRun, function(funcToRun) {
          if (funcToRun.recurring) {
            reschedule(funcToRun);
          }
        });

        forEachFunction(funcsToRun, function(funcToRun) {
          funcToRun.funcToCall.apply(null, funcToRun.params || []);
        });
      } while (scheduledLookup.length > 0 &&
              // checking first if we're out of time prevents setTimeout(0)
              // scheduled in a funcToRun from forcing an extra iteration
                 currentTime !== endTime  &&
                 scheduledLookup[0] <= endTime);

      // ran out of functions to call, but still time left on the clock
      if (currentTime !== endTime) {
        tickDate(endTime - currentTime);
      }
    }
  }

  return DelayedFunctionScheduler;
};

getJasmineRequireObj().ExceptionFormatter = function() {
  function ExceptionFormatter() {
    this.message = function(error) {
      var message = '';

      if (error.name && error.message) {
        message += error.name + ': ' + error.message;
      } else {
        message += error.toString() + ' thrown';
      }

      if (error.fileName || error.sourceURL) {
        message += ' in ' + (error.fileName || error.sourceURL);
      }

      if (error.line || error.lineNumber) {
        message += ' (line ' + (error.line || error.lineNumber) + ')';
      }

      return message;
    };

    this.stack = function(error) {
      return error ? error.stack : null;
    };
  }

  return ExceptionFormatter;
};

getJasmineRequireObj().Expectation = function() {

  function Expectation(options) {
    this.util = options.util || { buildFailureMessage: function() {} };
    this.customEqualityTesters = options.customEqualityTesters || [];
    this.actual = options.actual;
    this.addExpectationResult = options.addExpectationResult || function(){};
    this.isNot = options.isNot;

    var customMatchers = options.customMatchers || {};
    for (var matcherName in customMatchers) {
      this[matcherName] = Expectation.prototype.wrapCompare(matcherName, customMatchers[matcherName]);
    }
  }

  Expectation.prototype.wrapCompare = function(name, matcherFactory) {
    return function() {
      var args = Array.prototype.slice.call(arguments, 0),
        expected = args.slice(0),
        message = '';

      args.unshift(this.actual);

      var matcher = matcherFactory(this.util, this.customEqualityTesters),
          matcherCompare = matcher.compare;

      function defaultNegativeCompare() {
        var result = matcher.compare.apply(null, args);
        result.pass = !result.pass;
        return result;
      }

      if (this.isNot) {
        matcherCompare = matcher.negativeCompare || defaultNegativeCompare;
      }

      var result = matcherCompare.apply(null, args);

      if (!result.pass) {
        if (!result.message) {
          args.unshift(this.isNot);
          args.unshift(name);
          message = this.util.buildFailureMessage.apply(null, args);
        } else {
          if (Object.prototype.toString.apply(result.message) === '[object Function]') {
            message = result.message();
          } else {
            message = result.message;
          }
        }
      }

      if (expected.length == 1) {
        expected = expected[0];
      }

      // TODO: how many of these params are needed?
      this.addExpectationResult(
        result.pass,
        {
          matcherName: name,
          passed: result.pass,
          message: message,
          actual: this.actual,
          expected: expected // TODO: this may need to be arrayified/sliced
        }
      );
    };
  };

  Expectation.addCoreMatchers = function(matchers) {
    var prototype = Expectation.prototype;
    for (var matcherName in matchers) {
      var matcher = matchers[matcherName];
      prototype[matcherName] = prototype.wrapCompare(matcherName, matcher);
    }
  };

  Expectation.Factory = function(options) {
    options = options || {};

    var expect = new Expectation(options);

    // TODO: this would be nice as its own Object - NegativeExpectation
    // TODO: copy instead of mutate options
    options.isNot = true;
    expect.not = new Expectation(options);

    return expect;
  };

  return Expectation;
};

//TODO: expectation result may make more sense as a presentation of an expectation.
getJasmineRequireObj().buildExpectationResult = function() {
  function buildExpectationResult(options) {
    var messageFormatter = options.messageFormatter || function() {},
      stackFormatter = options.stackFormatter || function() {};

    var result = {
      matcherName: options.matcherName,
      message: message(),
      stack: stack(),
      passed: options.passed
    };

    if(!result.passed) {
      result.expected = options.expected;
      result.actual = options.actual;
    }

    return result;

    function message() {
      if (options.passed) {
        return 'Passed.';
      } else if (options.message) {
        return options.message;
      } else if (options.error) {
        return messageFormatter(options.error);
      }
      return '';
    }

    function stack() {
      if (options.passed) {
        return '';
      }

      var error = options.error;
      if (!error) {
        try {
          throw new Error(message());
        } catch (e) {
          error = e;
        }
      }
      return stackFormatter(error);
    }
  }

  return buildExpectationResult;
};

getJasmineRequireObj().MockDate = function() {
  function MockDate(global) {
    var self = this;
    var currentTime = 0;

    if (!global || !global.Date) {
      self.install = function() {};
      self.tick = function() {};
      self.uninstall = function() {};
      return self;
    }

    var GlobalDate = global.Date;

    self.install = function(mockDate) {
      if (mockDate instanceof GlobalDate) {
        currentTime = mockDate.getTime();
      } else {
        currentTime = new GlobalDate().getTime();
      }

      global.Date = FakeDate;
    };

    self.tick = function(millis) {
      millis = millis || 0;
      currentTime = currentTime + millis;
    };

    self.uninstall = function() {
      currentTime = 0;
      global.Date = GlobalDate;
    };

    createDateProperties();

    return self;

    function FakeDate() {
      switch(arguments.length) {
        case 0:
          return new GlobalDate(currentTime);
        case 1:
          return new GlobalDate(arguments[0]);
        case 2:
          return new GlobalDate(arguments[0], arguments[1]);
        case 3:
          return new GlobalDate(arguments[0], arguments[1], arguments[2]);
        case 4:
          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3]);
        case 5:
          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],
                                arguments[4]);
        case 6:
          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],
                                arguments[4], arguments[5]);
        default:
          return new GlobalDate(arguments[0], arguments[1], arguments[2], arguments[3],
                                arguments[4], arguments[5], arguments[6]);
      }
    }

    function createDateProperties() {
      FakeDate.prototype = GlobalDate.prototype;

      FakeDate.now = function() {
        if (GlobalDate.now) {
          return currentTime;
        } else {
          throw new Error('Browser does not support Date.now()');
        }
      };

      FakeDate.toSource = GlobalDate.toSource;
      FakeDate.toString = GlobalDate.toString;
      FakeDate.parse = GlobalDate.parse;
      FakeDate.UTC = GlobalDate.UTC;
    }
	}

  return MockDate;
};

getJasmineRequireObj().pp = function(j$) {

  function PrettyPrinter() {
    this.ppNestLevel_ = 0;
    this.seen = [];
  }

  PrettyPrinter.prototype.format = function(value) {
    this.ppNestLevel_++;
    try {
      if (j$.util.isUndefined(value)) {
        this.emitScalar('undefined');
      } else if (value === null) {
        this.emitScalar('null');
      } else if (value === 0 && 1/value === -Infinity) {
        this.emitScalar('-0');
      } else if (value === j$.getGlobal()) {
        this.emitScalar('<global>');
      } else if (value.jasmineToString) {
        this.emitScalar(value.jasmineToString());
      } else if (typeof value === 'string') {
        this.emitString(value);
      } else if (j$.isSpy(value)) {
        this.emitScalar('spy on ' + value.and.identity());
      } else if (value instanceof RegExp) {
        this.emitScalar(value.toString());
      } else if (typeof value === 'function') {
        this.emitScalar('Function');
      } else if (typeof value.nodeType === 'number') {
        this.emitScalar('HTMLNode');
      } else if (value instanceof Date) {
        this.emitScalar('Date(' + value + ')');
      } else if (value.toString && typeof value === 'object' && !(value instanceof Array) && value.toString !== Object.prototype.toString) {
        this.emitScalar(value.toString());
      } else if (j$.util.arrayContains(this.seen, value)) {
        this.emitScalar('<circular reference: ' + (j$.isArray_(value) ? 'Array' : 'Object') + '>');
      } else if (j$.isArray_(value) || j$.isA_('Object', value)) {
        this.seen.push(value);
        if (j$.isArray_(value)) {
          this.emitArray(value);
        } else {
          this.emitObject(value);
        }
        this.seen.pop();
      } else {
        this.emitScalar(value.toString());
      }
    } finally {
      this.ppNestLevel_--;
    }
  };

  PrettyPrinter.prototype.iterateObject = function(obj, fn) {
    for (var property in obj) {
      if (!Object.prototype.hasOwnProperty.call(obj, property)) { continue; }
      fn(property, obj.__lookupGetter__ ? (!j$.util.isUndefined(obj.__lookupGetter__(property)) &&
          obj.__lookupGetter__(property) !== null) : false);
    }
  };

  PrettyPrinter.prototype.emitArray = j$.unimplementedMethod_;
  PrettyPrinter.prototype.emitObject = j$.unimplementedMethod_;
  PrettyPrinter.prototype.emitScalar = j$.unimplementedMethod_;
  PrettyPrinter.prototype.emitString = j$.unimplementedMethod_;

  function StringPrettyPrinter() {
    PrettyPrinter.call(this);

    this.string = '';
  }

  j$.util.inherit(StringPrettyPrinter, PrettyPrinter);

  StringPrettyPrinter.prototype.emitScalar = function(value) {
    this.append(value);
  };

  StringPrettyPrinter.prototype.emitString = function(value) {
    this.append('\'' + value + '\'');
  };

  StringPrettyPrinter.prototype.emitArray = function(array) {
    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      this.append('Array');
      return;
    }
    var length = Math.min(array.length, j$.MAX_PRETTY_PRINT_ARRAY_LENGTH);
    this.append('[ ');
    for (var i = 0; i < length; i++) {
      if (i > 0) {
        this.append(', ');
      }
      this.format(array[i]);
    }
    if(array.length > length){
      this.append(', ...');
    }

    var self = this;
    var first = array.length === 0;
    this.iterateObject(array, function(property, isGetter) {
      if (property.match(/^\d+$/)) {
        return;
      }

      if (first) {
        first = false;
      } else {
        self.append(', ');
      }

      self.formatProperty(array, property, isGetter);
    });

    this.append(' ]');
  };

  StringPrettyPrinter.prototype.emitObject = function(obj) {
    var constructorName = obj.constructor ? j$.fnNameFor(obj.constructor) : 'null';
    this.append(constructorName);

    if (this.ppNestLevel_ > j$.MAX_PRETTY_PRINT_DEPTH) {
      return;
    }

    var self = this;
    this.append('({ ');
    var first = true;

    this.iterateObject(obj, function(property, isGetter) {
      if (first) {
        first = false;
      } else {
        self.append(', ');
      }

      self.formatProperty(obj, property, isGetter);
    });

    this.append(' })');
  };

  StringPrettyPrinter.prototype.formatProperty = function(obj, property, isGetter) {
      this.append(property);
      this.append(': ');
      if (isGetter) {
        this.append('<getter>');
      } else {
        this.format(obj[property]);
      }
  };

  StringPrettyPrinter.prototype.append = function(value) {
    this.string += value;
  };

  return function(value) {
    var stringPrettyPrinter = new StringPrettyPrinter();
    stringPrettyPrinter.format(value);
    return stringPrettyPrinter.string;
  };
};

getJasmineRequireObj().QueueRunner = function(j$) {

  function once(fn) {
    var called = false;
    return function() {
      if (!called) {
        called = true;
        fn();
      }
      return null;
    };
  }

  function QueueRunner(attrs) {
    this.queueableFns = attrs.queueableFns || [];
    this.onComplete = attrs.onComplete || function() {};
    this.clearStack = attrs.clearStack || function(fn) {fn();};
    this.onException = attrs.onException || function() {};
    this.catchException = attrs.catchException || function() { return true; };
    this.userContext = attrs.userContext || {};
    this.timeout = attrs.timeout || {setTimeout: setTimeout, clearTimeout: clearTimeout};
    this.fail = attrs.fail || function() {};
  }

  QueueRunner.prototype.execute = function() {
    this.run(this.queueableFns, 0);
  };

  QueueRunner.prototype.run = function(queueableFns, recursiveIndex) {
    var length = queueableFns.length,
      self = this,
      iterativeIndex;


    for(iterativeIndex = recursiveIndex; iterativeIndex < length; iterativeIndex++) {
      var queueableFn = queueableFns[iterativeIndex];
      if (queueableFn.fn.length > 0) {
        attemptAsync(queueableFn);
        return;
      } else {
        attemptSync(queueableFn);
      }
    }

    var runnerDone = iterativeIndex >= length;

    if (runnerDone) {
      this.clearStack(this.onComplete);
    }

    function attemptSync(queueableFn) {
      try {
        queueableFn.fn.call(self.userContext);
      } catch (e) {
        handleException(e, queueableFn);
      }
    }

    function attemptAsync(queueableFn) {
      var clearTimeout = function () {
          Function.prototype.apply.apply(self.timeout.clearTimeout, [j$.getGlobal(), [timeoutId]]);
        },
        next = once(function () {
          clearTimeout(timeoutId);
          self.run(queueableFns, iterativeIndex + 1);
        }),
        timeoutId;

      next.fail = function() {
        self.fail.apply(null, arguments);
        next();
      };

      if (queueableFn.timeout) {
        timeoutId = Function.prototype.apply.apply(self.timeout.setTimeout, [j$.getGlobal(), [function() {
          var error = new Error('Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.');
          onException(error);
          next();
        }, queueableFn.timeout()]]);
      }

      try {
        queueableFn.fn.call(self.userContext, next);
      } catch (e) {
        handleException(e, queueableFn);
        next();
      }
    }

    function onException(e) {
      self.onException(e);
    }

    function handleException(e, queueableFn) {
      onException(e);
      if (!self.catchException(e)) {
        //TODO: set a var when we catch an exception and
        //use a finally block to close the loop in a nice way..
        throw e;
      }
    }
  };

  return QueueRunner;
};

getJasmineRequireObj().ReportDispatcher = function() {
  function ReportDispatcher(methods) {

    var dispatchedMethods = methods || [];

    for (var i = 0; i < dispatchedMethods.length; i++) {
      var method = dispatchedMethods[i];
      this[method] = (function(m) {
        return function() {
          dispatch(m, arguments);
        };
      }(method));
    }

    var reporters = [];
    var fallbackReporter = null;

    this.addReporter = function(reporter) {
      reporters.push(reporter);
    };

    this.provideFallbackReporter = function(reporter) {
      fallbackReporter = reporter;
    };

    this.clearReporters = function() {
      reporters = [];
    };

    return this;

    function dispatch(method, args) {
      if (reporters.length === 0 && fallbackReporter !== null) {
          reporters.push(fallbackReporter);
      }
      for (var i = 0; i < reporters.length; i++) {
        var reporter = reporters[i];
        if (reporter[method]) {
          reporter[method].apply(reporter, args);
        }
      }
    }
  }

  return ReportDispatcher;
};


getJasmineRequireObj().SpyRegistry = function(j$) {

  var getErrorMsg = j$.formatErrorMsg('<spyOn>', 'spyOn(<object>, <methodName>)');

  function SpyRegistry(options) {
    options = options || {};
    var currentSpies = options.currentSpies || function() { return []; };

    this.allowRespy = function(allow){
      this.respy = allow;
    };

    this.spyOn = function(obj, methodName) {

      if (j$.util.isUndefined(obj)) {
        throw new Error(getErrorMsg('could not find an object to spy upon for ' + methodName + '()'));
      }

      if (j$.util.isUndefined(methodName)) {
        throw new Error(getErrorMsg('No method name supplied'));
      }

      if (j$.util.isUndefined(obj[methodName])) {
        throw new Error(getErrorMsg(methodName + '() method does not exist'));
      }

      if (obj[methodName] && j$.isSpy(obj[methodName])  ) {
        if ( !!this.respy ){
          return obj[methodName];
        }else {
          throw new Error(getErrorMsg(methodName + ' has already been spied upon'));
        }
      }

      var descriptor;
      try {
        descriptor = Object.getOwnPropertyDescriptor(obj, methodName);
      } catch(e) {
        // IE 8 doesn't support `definePropery` on non-DOM nodes
      }

      if (descriptor && !(descriptor.writable || descriptor.set)) {
        throw new Error(getErrorMsg(methodName + ' is not declared writable or has no setter'));
      }

      var originalMethod = obj[methodName],
        spiedMethod = j$.createSpy(methodName, originalMethod),
        restoreStrategy;

      if (Object.prototype.hasOwnProperty.call(obj, methodName)) {
        restoreStrategy = function() {
          obj[methodName] = originalMethod;
        };
      } else {
        restoreStrategy = function() {
          if (!delete obj[methodName]) {
            obj[methodName] = originalMethod;
          }
        };
      }

      currentSpies().push({
        restoreObjectToOriginalState: restoreStrategy
      });

      obj[methodName] = spiedMethod;

      return spiedMethod;
    };

    this.clearSpies = function() {
      var spies = currentSpies();
      for (var i = spies.length - 1; i >= 0; i--) {
        var spyEntry = spies[i];
        spyEntry.restoreObjectToOriginalState();
      }
    };
  }

  return SpyRegistry;
};

getJasmineRequireObj().SpyStrategy = function(j$) {

  function SpyStrategy(options) {
    options = options || {};

    var identity = options.name || 'unknown',
        originalFn = options.fn || function() {},
        getSpy = options.getSpy || function() {},
        plan = function() {};

    this.identity = function() {
      return identity;
    };

    this.exec = function() {
      return plan.apply(this, arguments);
    };

    this.callThrough = function() {
      plan = originalFn;
      return getSpy();
    };

    this.returnValue = function(value) {
      plan = function() {
        return value;
      };
      return getSpy();
    };

    this.returnValues = function() {
      var values = Array.prototype.slice.call(arguments);
      plan = function () {
        return values.shift();
      };
      return getSpy();
    };

    this.throwError = function(something) {
      var error = (something instanceof Error) ? something : new Error(something);
      plan = function() {
        throw error;
      };
      return getSpy();
    };

    this.callFake = function(fn) {
      if(!j$.isFunction_(fn)) {
        throw new Error('Argument passed to callFake should be a function, got ' + fn);
      }
      plan = fn;
      return getSpy();
    };

    this.stub = function(fn) {
      plan = function() {};
      return getSpy();
    };
  }

  return SpyStrategy;
};

getJasmineRequireObj().Suite = function(j$) {
  function Suite(attrs) {
    this.env = attrs.env;
    this.id = attrs.id;
    this.parentSuite = attrs.parentSuite;
    this.description = attrs.description;
    this.expectationFactory = attrs.expectationFactory;
    this.expectationResultFactory = attrs.expectationResultFactory;
    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;

    this.beforeFns = [];
    this.afterFns = [];
    this.beforeAllFns = [];
    this.afterAllFns = [];
    this.disabled = false;

    this.children = [];

    this.result = {
      id: this.id,
      description: this.description,
      fullName: this.getFullName(),
      failedExpectations: []
    };
  }

  Suite.prototype.expect = function(actual) {
    return this.expectationFactory(actual, this);
  };

  Suite.prototype.getFullName = function() {
    var fullName = [];
    for (var parentSuite = this; parentSuite; parentSuite = parentSuite.parentSuite) {
      if (parentSuite.parentSuite) {
        fullName.unshift(parentSuite.description);
      }
    }
    return fullName.join(' ');
  };

  Suite.prototype.disable = function() {
    this.disabled = true;
  };

  Suite.prototype.pend = function(message) {
    this.markedPending = true;
  };

  Suite.prototype.beforeEach = function(fn) {
    this.beforeFns.unshift(fn);
  };

  Suite.prototype.beforeAll = function(fn) {
    this.beforeAllFns.push(fn);
  };

  Suite.prototype.afterEach = function(fn) {
    this.afterFns.unshift(fn);
  };

  Suite.prototype.afterAll = function(fn) {
    this.afterAllFns.push(fn);
  };

  Suite.prototype.addChild = function(child) {
    this.children.push(child);
  };

  Suite.prototype.status = function() {
    if (this.disabled) {
      return 'disabled';
    }

    if (this.markedPending) {
      return 'pending';
    }

    if (this.result.failedExpectations.length > 0) {
      return 'failed';
    } else {
      return 'finished';
    }
  };

  Suite.prototype.isExecutable = function() {
    return !this.disabled;
  };

  Suite.prototype.canBeReentered = function() {
    return this.beforeAllFns.length === 0 && this.afterAllFns.length === 0;
  };

  Suite.prototype.getResult = function() {
    this.result.status = this.status();
    return this.result;
  };

  Suite.prototype.sharedUserContext = function() {
    if (!this.sharedContext) {
      this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};
    }

    return this.sharedContext;
  };

  Suite.prototype.clonedSharedUserContext = function() {
    return clone(this.sharedUserContext());
  };

  Suite.prototype.onException = function() {
    if (arguments[0] instanceof j$.errors.ExpectationFailed) {
      return;
    }

    if(isAfterAll(this.children)) {
      var data = {
        matcherName: '',
        passed: false,
        expected: '',
        actual: '',
        error: arguments[0]
      };
      this.result.failedExpectations.push(this.expectationResultFactory(data));
    } else {
      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        child.onException.apply(child, arguments);
      }
    }
  };

  Suite.prototype.addExpectationResult = function () {
    if(isAfterAll(this.children) && isFailure(arguments)){
      var data = arguments[1];
      this.result.failedExpectations.push(this.expectationResultFactory(data));
      if(this.throwOnExpectationFailure) {
        throw new j$.errors.ExpectationFailed();
      }
    } else {
      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        try {
          child.addExpectationResult.apply(child, arguments);
        } catch(e) {
          // keep going
        }
      }
    }
  };

  function isAfterAll(children) {
    return children && children[0].result.status;
  }

  function isFailure(args) {
    return !args[0];
  }

  function clone(obj) {
    var clonedObj = {};
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        clonedObj[prop] = obj[prop];
      }
    }

    return clonedObj;
  }

  return Suite;
};

if (typeof window == void 0 && typeof exports == 'object') {
  exports.Suite = jasmineRequire.Suite;
}

getJasmineRequireObj().Timer = function() {
  var defaultNow = (function(Date) {
    return function() { return new Date().getTime(); };
  })(Date);

  function Timer(options) {
    options = options || {};

    var now = options.now || defaultNow,
      startTime;

    this.start = function() {
      startTime = now();
    };

    this.elapsed = function() {
      return now() - startTime;
    };
  }

  return Timer;
};

getJasmineRequireObj().TreeProcessor = function() {
  function TreeProcessor(attrs) {
    var tree = attrs.tree,
        runnableIds = attrs.runnableIds,
        queueRunnerFactory = attrs.queueRunnerFactory,
        nodeStart = attrs.nodeStart || function() {},
        nodeComplete = attrs.nodeComplete || function() {},
        orderChildren = attrs.orderChildren || function(node) { return node.children; },
        stats = { valid: true },
        processed = false,
        defaultMin = Infinity,
        defaultMax = 1 - Infinity;

    this.processTree = function() {
      processNode(tree, false);
      processed = true;
      return stats;
    };

    this.execute = function(done) {
      if (!processed) {
        this.processTree();
      }

      if (!stats.valid) {
        throw 'invalid order';
      }

      var childFns = wrapChildren(tree, 0);

      queueRunnerFactory({
        queueableFns: childFns,
        userContext: tree.sharedUserContext(),
        onException: function() {
          tree.onException.apply(tree, arguments);
        },
        onComplete: done
      });
    };

    function runnableIndex(id) {
      for (var i = 0; i < runnableIds.length; i++) {
        if (runnableIds[i] === id) {
          return i;
        }
      }
    }

    function processNode(node, parentEnabled) {
      var executableIndex = runnableIndex(node.id);

      if (executableIndex !== undefined) {
        parentEnabled = true;
      }

      parentEnabled = parentEnabled && node.isExecutable();

      if (!node.children) {
        stats[node.id] = {
          executable: parentEnabled && node.isExecutable(),
          segments: [{
            index: 0,
            owner: node,
            nodes: [node],
            min: startingMin(executableIndex),
            max: startingMax(executableIndex)
          }]
        };
      } else {
        var hasExecutableChild = false;

        var orderedChildren = orderChildren(node);

        for (var i = 0; i < orderedChildren.length; i++) {
          var child = orderedChildren[i];

          processNode(child, parentEnabled);

          if (!stats.valid) {
            return;
          }

          var childStats = stats[child.id];

          hasExecutableChild = hasExecutableChild || childStats.executable;
        }

        stats[node.id] = {
          executable: hasExecutableChild
        };

        segmentChildren(node, orderedChildren, stats[node.id], executableIndex);

        if (!node.canBeReentered() && stats[node.id].segments.length > 1) {
          stats = { valid: false };
        }
      }
    }

    function startingMin(executableIndex) {
      return executableIndex === undefined ? defaultMin : executableIndex;
    }

    function startingMax(executableIndex) {
      return executableIndex === undefined ? defaultMax : executableIndex;
    }

    function segmentChildren(node, orderedChildren, nodeStats, executableIndex) {
      var currentSegment = { index: 0, owner: node, nodes: [], min: startingMin(executableIndex), max: startingMax(executableIndex) },
          result = [currentSegment],
          lastMax = defaultMax,
          orderedChildSegments = orderChildSegments(orderedChildren);

      function isSegmentBoundary(minIndex) {
        return lastMax !== defaultMax && minIndex !== defaultMin && lastMax < minIndex - 1;
      }

      for (var i = 0; i < orderedChildSegments.length; i++) {
        var childSegment = orderedChildSegments[i],
          maxIndex = childSegment.max,
          minIndex = childSegment.min;

        if (isSegmentBoundary(minIndex)) {
          currentSegment = {index: result.length, owner: node, nodes: [], min: defaultMin, max: defaultMax};
          result.push(currentSegment);
        }

        currentSegment.nodes.push(childSegment);
        currentSegment.min = Math.min(currentSegment.min, minIndex);
        currentSegment.max = Math.max(currentSegment.max, maxIndex);
        lastMax = maxIndex;
      }

      nodeStats.segments = result;
    }

    function orderChildSegments(children) {
      var specifiedOrder = [],
          unspecifiedOrder = [];

      for (var i = 0; i < children.length; i++) {
        var child = children[i],
            segments = stats[child.id].segments;

        for (var j = 0; j < segments.length; j++) {
          var seg = segments[j];

          if (seg.min === defaultMin) {
            unspecifiedOrder.push(seg);
          } else {
            specifiedOrder.push(seg);
          }
        }
      }

      specifiedOrder.sort(function(a, b) {
        return a.min - b.min;
      });

      return specifiedOrder.concat(unspecifiedOrder);
    }

    function executeNode(node, segmentNumber) {
      if (node.children) {
        return {
          fn: function(done) {
            nodeStart(node);

            queueRunnerFactory({
              onComplete: function() {
                nodeComplete(node, node.getResult());
                done();
              },
              queueableFns: wrapChildren(node, segmentNumber),
              userContext: node.sharedUserContext(),
              onException: function() {
                node.onException.apply(node, arguments);
              }
            });
          }
        };
      } else {
        return {
          fn: function(done) { node.execute(done, stats[node.id].executable); }
        };
      }
    }

    function wrapChildren(node, segmentNumber) {
      var result = [],
          segmentChildren = stats[node.id].segments[segmentNumber].nodes;

      for (var i = 0; i < segmentChildren.length; i++) {
        result.push(executeNode(segmentChildren[i].owner, segmentChildren[i].index));
      }

      if (!stats[node.id].executable) {
        return result;
      }

      return node.beforeAllFns.concat(result).concat(node.afterAllFns);
    }
  }

  return TreeProcessor;
};

getJasmineRequireObj().Any = function(j$) {

  function Any(expectedObject) {
    if (typeof expectedObject === 'undefined') {
      throw new TypeError(
        'jasmine.any() expects to be passed a constructor function. ' +
        'Please pass one or use jasmine.anything() to match any object.'
      );
    }
    this.expectedObject = expectedObject;
  }

  Any.prototype.asymmetricMatch = function(other) {
    if (this.expectedObject == String) {
      return typeof other == 'string' || other instanceof String;
    }

    if (this.expectedObject == Number) {
      return typeof other == 'number' || other instanceof Number;
    }

    if (this.expectedObject == Function) {
      return typeof other == 'function' || other instanceof Function;
    }

    if (this.expectedObject == Object) {
      return typeof other == 'object';
    }

    if (this.expectedObject == Boolean) {
      return typeof other == 'boolean';
    }

    return other instanceof this.expectedObject;
  };

  Any.prototype.jasmineToString = function() {
    return '<jasmine.any(' + j$.fnNameFor(this.expectedObject) + ')>';
  };

  return Any;
};

getJasmineRequireObj().Anything = function(j$) {

  function Anything() {}

  Anything.prototype.asymmetricMatch = function(other) {
    return !j$.util.isUndefined(other) && other !== null;
  };

  Anything.prototype.jasmineToString = function() {
    return '<jasmine.anything>';
  };

  return Anything;
};

getJasmineRequireObj().ArrayContaining = function(j$) {
  function ArrayContaining(sample) {
    this.sample = sample;
  }

  ArrayContaining.prototype.asymmetricMatch = function(other) {
    var className = Object.prototype.toString.call(this.sample);
    if (className !== '[object Array]') { throw new Error('You must provide an array to arrayContaining, not \'' + this.sample + '\'.'); }

    for (var i = 0; i < this.sample.length; i++) {
      var item = this.sample[i];
      if (!j$.matchersUtil.contains(other, item)) {
        return false;
      }
    }

    return true;
  };

  ArrayContaining.prototype.jasmineToString = function () {
    return '<jasmine.arrayContaining(' + jasmine.pp(this.sample) +')>';
  };

  return ArrayContaining;
};

getJasmineRequireObj().ObjectContaining = function(j$) {

  function ObjectContaining(sample) {
    this.sample = sample;
  }

  function getPrototype(obj) {
    if (Object.getPrototypeOf) {
      return Object.getPrototypeOf(obj);
    }

    if (obj.constructor.prototype == obj) {
      return null;
    }

    return obj.constructor.prototype;
  }

  function hasProperty(obj, property) {
    if (!obj) {
      return false;
    }

    if (Object.prototype.hasOwnProperty.call(obj, property)) {
      return true;
    }

    return hasProperty(getPrototype(obj), property);
  }

  ObjectContaining.prototype.asymmetricMatch = function(other) {
    if (typeof(this.sample) !== 'object') { throw new Error('You must provide an object to objectContaining, not \''+this.sample+'\'.'); }

    for (var property in this.sample) {
      if (!hasProperty(other, property) ||
          !j$.matchersUtil.equals(this.sample[property], other[property])) {
        return false;
      }
    }

    return true;
  };

  ObjectContaining.prototype.jasmineToString = function() {
    return '<jasmine.objectContaining(' + j$.pp(this.sample) + ')>';
  };

  return ObjectContaining;
};

getJasmineRequireObj().StringMatching = function(j$) {

  function StringMatching(expected) {
    if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {
      throw new Error('Expected is not a String or a RegExp');
    }

    this.regexp = new RegExp(expected);
  }

  StringMatching.prototype.asymmetricMatch = function(other) {
    return this.regexp.test(other);
  };

  StringMatching.prototype.jasmineToString = function() {
    return '<jasmine.stringMatching(' + this.regexp + ')>';
  };

  return StringMatching;
};

getJasmineRequireObj().errors = function() {
  function ExpectationFailed() {}

  ExpectationFailed.prototype = new Error();
  ExpectationFailed.prototype.constructor = ExpectationFailed;

  return {
    ExpectationFailed: ExpectationFailed
  };
};
getJasmineRequireObj().formatErrorMsg = function() {
  function generateErrorMsg(domain, usage) {
    var usageDefinition = usage ? '\nUsage: ' + usage : '';

    return function errorMsg(msg) {
      return domain + ' : ' + msg + usageDefinition;
    };
  }

  return generateErrorMsg;
};

getJasmineRequireObj().matchersUtil = function(j$) {
  // TODO: what to do about jasmine.pp not being inject? move to JSON.stringify? gut PrettyPrinter?

  return {
    equals: function(a, b, customTesters) {
      customTesters = customTesters || [];

      return eq(a, b, [], [], customTesters);
    },

    contains: function(haystack, needle, customTesters) {
      customTesters = customTesters || [];

      if ((Object.prototype.toString.apply(haystack) === '[object Array]') ||
        (!!haystack && !haystack.indexOf))
      {
        for (var i = 0; i < haystack.length; i++) {
          if (eq(haystack[i], needle, [], [], customTesters)) {
            return true;
          }
        }
        return false;
      }

      return !!haystack && haystack.indexOf(needle) >= 0;
    },

    buildFailureMessage: function() {
      var args = Array.prototype.slice.call(arguments, 0),
        matcherName = args[0],
        isNot = args[1],
        actual = args[2],
        expected = args.slice(3),
        englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });

      var message = 'Expected ' +
        j$.pp(actual) +
        (isNot ? ' not ' : ' ') +
        englishyPredicate;

      if (expected.length > 0) {
        for (var i = 0; i < expected.length; i++) {
          if (i > 0) {
            message += ',';
          }
          message += ' ' + j$.pp(expected[i]);
        }
      }

      return message + '.';
    }
  };

  function isAsymmetric(obj) {
    return obj && j$.isA_('Function', obj.asymmetricMatch);
  }

  function asymmetricMatch(a, b) {
    var asymmetricA = isAsymmetric(a),
        asymmetricB = isAsymmetric(b);

    if (asymmetricA && asymmetricB) {
      return undefined;
    }

    if (asymmetricA) {
      return a.asymmetricMatch(b);
    }

    if (asymmetricB) {
      return b.asymmetricMatch(a);
    }
  }

  // Equality function lovingly adapted from isEqual in
  //   [Underscore](http://underscorejs.org)
  function eq(a, b, aStack, bStack, customTesters) {
    var result = true;

    var asymmetricResult = asymmetricMatch(a, b);
    if (!j$.util.isUndefined(asymmetricResult)) {
      return asymmetricResult;
    }

    for (var i = 0; i < customTesters.length; i++) {
      var customTesterResult = customTesters[i](a, b);
      if (!j$.util.isUndefined(customTesterResult)) {
        return customTesterResult;
      }
    }

    if (a instanceof Error && b instanceof Error) {
      return a.message == b.message;
    }

    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) { return a !== 0 || 1 / a == 1 / b; }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) { return a === b; }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) { return false; }
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a === 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
          a.global == b.global &&
          a.multiline == b.multiline &&
          a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') { return false; }

    var aIsDomNode = j$.isDomNode(a);
    var bIsDomNode = j$.isDomNode(b);
    if (aIsDomNode && bIsDomNode) {
      // At first try to use DOM3 method isEqualNode
      if (a.isEqualNode) {
        return a.isEqualNode(b);
      }
      // IE8 doesn't support isEqualNode, try to use outerHTML && innerText
      var aIsElement = a instanceof Element;
      var bIsElement = b instanceof Element;
      if (aIsElement && bIsElement) {
        return a.outerHTML == b.outerHTML;
      }
      if (aIsElement || bIsElement) {
        return false;
      }
      return a.innerText == b.innerText && a.textContent == b.textContent;
    }
    if (aIsDomNode || bIsDomNode) {
      return false;
    }

    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) { return bStack[length] == b; }
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0;
    // Recursively compare objects and arrays.
    // Compare array lengths to determine if a deep comparison is necessary.
    if (className == '[object Array]') {
      size = a.length;
      if (size !== b.length) {
        return false;
      }

      while (size--) {
        result = eq(a[size], b[size], aStack, bStack, customTesters);
        if (!result) {
          return false;
        }
      }
    } else {

      // Objects with different constructors are not equivalent, but `Object`s
      // or `Array`s from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(isObjectConstructor(aCtor) &&
                               isObjectConstructor(bCtor))) {
        return false;
      }
    }

    // Deep compare objects.
    var aKeys = keys(a, className == '[object Array]'), key;
    size = aKeys.length;

    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b, className == '[object Array]').length !== size) { return false; }

    while (size--) {
      key = aKeys[size];
      // Deep compare each member
      result = has(b, key) && eq(a[key], b[key], aStack, bStack, customTesters);

      if (!result) {
        return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();

    return result;

    function keys(obj, isArray) {
      var allKeys = Object.keys ? Object.keys(obj) :
        (function(o) {
            var keys = [];
            for (var key in o) {
                if (has(o, key)) {
                    keys.push(key);
                }
            }
            return keys;
        })(obj);

      if (!isArray) {
        return allKeys;
      }

      var extraKeys = [];
      if (allKeys.length === 0) {
          return allKeys;
      }

      for (var x = 0; x < allKeys.length; x++) {
          if (!allKeys[x].match(/^[0-9]+$/)) {
              extraKeys.push(allKeys[x]);
          }
      }

      return extraKeys;
    }
  }

  function has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }

  function isFunction(obj) {
    return typeof obj === 'function';
  }

  function isObjectConstructor(ctor) {
    // aCtor instanceof aCtor is true for the Object and Function
    // constructors (since a constructor is-a Function and a function is-a
    // Object). We don't just compare ctor === Object because the constructor
    // might come from a different frame with different globals.
    return isFunction(ctor) && ctor instanceof ctor;
  }
};

getJasmineRequireObj().toBe = function() {
  function toBe() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual === expected
        };
      }
    };
  }

  return toBe;
};

getJasmineRequireObj().toBeCloseTo = function() {

  function toBeCloseTo() {
    return {
      compare: function(actual, expected, precision) {
        if (precision !== 0) {
          precision = precision || 2;
        }

        return {
          pass: Math.abs(expected - actual) < (Math.pow(10, -precision) / 2)
        };
      }
    };
  }

  return toBeCloseTo;
};

getJasmineRequireObj().toBeDefined = function() {
  function toBeDefined() {
    return {
      compare: function(actual) {
        return {
          pass: (void 0 !== actual)
        };
      }
    };
  }

  return toBeDefined;
};

getJasmineRequireObj().toBeFalsy = function() {
  function toBeFalsy() {
    return {
      compare: function(actual) {
        return {
          pass: !!!actual
        };
      }
    };
  }

  return toBeFalsy;
};

getJasmineRequireObj().toBeGreaterThan = function() {

  function toBeGreaterThan() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual > expected
        };
      }
    };
  }

  return toBeGreaterThan;
};


getJasmineRequireObj().toBeGreaterThanOrEqual = function() {

  function toBeGreaterThanOrEqual() {
    return {
      compare: function(actual, expected) {
        return {
          pass: actual >= expected
        };
      }
    };
  }

  return toBeGreaterThanOrEqual;
};

getJasmineRequireObj().toBeLessThan = function() {
  function toBeLessThan() {
    return {

      compare: function(actual, expected) {
        return {
          pass: actual < expected
        };
      }
    };
  }

  return toBeLessThan;
};
getJasmineRequireObj().toBeLessThanOrEqual = function() {
  function toBeLessThanOrEqual() {
    return {

      compare: function(actual, expected) {
        return {
          pass: actual <= expected
        };
      }
    };
  }

  return toBeLessThanOrEqual;
};

getJasmineRequireObj().toBeNaN = function(j$) {

  function toBeNaN() {
    return {
      compare: function(actual) {
        var result = {
          pass: (actual !== actual)
        };

        if (result.pass) {
          result.message = 'Expected actual not to be NaN.';
        } else {
          result.message = function() { return 'Expected ' + j$.pp(actual) + ' to be NaN.'; };
        }

        return result;
      }
    };
  }

  return toBeNaN;
};

getJasmineRequireObj().toBeNull = function() {

  function toBeNull() {
    return {
      compare: function(actual) {
        return {
          pass: actual === null
        };
      }
    };
  }

  return toBeNull;
};

getJasmineRequireObj().toBeTruthy = function() {

  function toBeTruthy() {
    return {
      compare: function(actual) {
        return {
          pass: !!actual
        };
      }
    };
  }

  return toBeTruthy;
};

getJasmineRequireObj().toBeUndefined = function() {

  function toBeUndefined() {
    return {
      compare: function(actual) {
        return {
          pass: void 0 === actual
        };
      }
    };
  }

  return toBeUndefined;
};

getJasmineRequireObj().toContain = function() {
  function toContain(util, customEqualityTesters) {
    customEqualityTesters = customEqualityTesters || [];

    return {
      compare: function(actual, expected) {

        return {
          pass: util.contains(actual, expected, customEqualityTesters)
        };
      }
    };
  }

  return toContain;
};

getJasmineRequireObj().toEqual = function() {

  function toEqual(util, customEqualityTesters) {
    customEqualityTesters = customEqualityTesters || [];

    return {
      compare: function(actual, expected) {
        var result = {
          pass: false
        };

        result.pass = util.equals(actual, expected, customEqualityTesters);

        return result;
      }
    };
  }

  return toEqual;
};

getJasmineRequireObj().toHaveBeenCalled = function(j$) {

  var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalled>', 'expect(<spyObj>).toHaveBeenCalled()');

  function toHaveBeenCalled() {
    return {
      compare: function(actual) {
        var result = {};

        if (!j$.isSpy(actual)) {
          throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(actual) + '.'));
        }

        if (arguments.length > 1) {
          throw new Error(getErrorMsg('Does not take arguments, use toHaveBeenCalledWith'));
        }

        result.pass = actual.calls.any();

        result.message = result.pass ?
          'Expected spy ' + actual.and.identity() + ' not to have been called.' :
          'Expected spy ' + actual.and.identity() + ' to have been called.';

        return result;
      }
    };
  }

  return toHaveBeenCalled;
};

getJasmineRequireObj().toHaveBeenCalledTimes = function(j$) {

  var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalledTimes>', 'expect(<spyObj>).toHaveBeenCalledTimes(<Number>)');

  function toHaveBeenCalledTimes() {
    return {
      compare: function(actual, expected) {
        if (!j$.isSpy(actual)) {
          throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(actual) + '.'));
        }

        var args = Array.prototype.slice.call(arguments, 0),
          result = { pass: false };

        if (!j$.isNumber_(expected)){
          throw new Error(getErrorMsg('The expected times failed is a required argument and must be a number.'));
        }

        actual = args[0];
        var calls = actual.calls.count();
        var timesMessage = expected === 1 ? 'once' : expected + ' times';
        result.pass = calls === expected;
        result.message = result.pass ?
          'Expected spy ' + actual.and.identity() + ' not to have been called ' + timesMessage + '. It was called ' +  calls + ' times.' :
          'Expected spy ' + actual.and.identity() + ' to have been called ' + timesMessage + '. It was called ' +  calls + ' times.';
        return result;
      }
    };
  }

  return toHaveBeenCalledTimes;
};

getJasmineRequireObj().toHaveBeenCalledWith = function(j$) {

  var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalledWith>', 'expect(<spyObj>).toHaveBeenCalledWith(...arguments)');

  function toHaveBeenCalledWith(util, customEqualityTesters) {
    return {
      compare: function() {
        var args = Array.prototype.slice.call(arguments, 0),
          actual = args[0],
          expectedArgs = args.slice(1),
          result = { pass: false };

        if (!j$.isSpy(actual)) {
          throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(actual) + '.'));
        }

        if (!actual.calls.any()) {
          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but it was never called.'; };
          return result;
        }

        if (util.contains(actual.calls.allArgs(), expectedArgs, customEqualityTesters)) {
          result.pass = true;
          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' not to have been called with ' + j$.pp(expectedArgs) + ' but it was.'; };
        } else {
          result.message = function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but actual calls were ' + j$.pp(actual.calls.allArgs()).replace(/^\[ | \]$/g, '') + '.'; };
        }

        return result;
      }
    };
  }

  return toHaveBeenCalledWith;
};

getJasmineRequireObj().toMatch = function(j$) {

  var getErrorMsg = j$.formatErrorMsg('<toMatch>', 'expect(<expectation>).toMatch(<string> || <regexp>)');

  function toMatch() {
    return {
      compare: function(actual, expected) {
        if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {
          throw new Error(getErrorMsg('Expected is not a String or a RegExp'));
        }

        var regexp = new RegExp(expected);

        return {
          pass: regexp.test(actual)
        };
      }
    };
  }

  return toMatch;
};

getJasmineRequireObj().toThrow = function(j$) {

  var getErrorMsg = j$.formatErrorMsg('<toThrow>', 'expect(function() {<expectation>}).toThrow()');

  function toThrow(util) {
    return {
      compare: function(actual, expected) {
        var result = { pass: false },
          threw = false,
          thrown;

        if (typeof actual != 'function') {
          throw new Error(getErrorMsg('Actual is not a Function'));
        }

        try {
          actual();
        } catch (e) {
          threw = true;
          thrown = e;
        }

        if (!threw) {
          result.message = 'Expected function to throw an exception.';
          return result;
        }

        if (arguments.length == 1) {
          result.pass = true;
          result.message = function() { return 'Expected function not to throw, but it threw ' + j$.pp(thrown) + '.'; };

          return result;
        }

        if (util.equals(thrown, expected)) {
          result.pass = true;
          result.message = function() { return 'Expected function not to throw ' + j$.pp(expected) + '.'; };
        } else {
          result.message = function() { return 'Expected function to throw ' + j$.pp(expected) + ', but it threw ' +  j$.pp(thrown) + '.'; };
        }

        return result;
      }
    };
  }

  return toThrow;
};

getJasmineRequireObj().toThrowError = function(j$) {

  var getErrorMsg =  j$.formatErrorMsg('<toThrowError>', 'expect(function() {<expectation>}).toThrowError(<ErrorConstructor>, <message>)');

  function toThrowError () {
    return {
      compare: function(actual) {
        var threw = false,
          pass = {pass: true},
          fail = {pass: false},
          thrown;

        if (typeof actual != 'function') {
          throw new Error(getErrorMsg('Actual is not a Function'));
        }

        var errorMatcher = getMatcher.apply(null, arguments);

        try {
          actual();
        } catch (e) {
          threw = true;
          thrown = e;
        }

        if (!threw) {
          fail.message = 'Expected function to throw an Error.';
          return fail;
        }

        if (!(thrown instanceof Error)) {
          fail.message = function() { return 'Expected function to throw an Error, but it threw ' + j$.pp(thrown) + '.'; };
          return fail;
        }

        if (errorMatcher.hasNoSpecifics()) {
          pass.message = 'Expected function not to throw an Error, but it threw ' + j$.fnNameFor(thrown) + '.';
          return pass;
        }

        if (errorMatcher.matches(thrown)) {
          pass.message = function() {
            return 'Expected function not to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() + '.';
          };
          return pass;
        } else {
          fail.message = function() {
            return 'Expected function to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() +
              ', but it threw ' + errorMatcher.thrownDescription(thrown) + '.';
          };
          return fail;
        }
      }
    };

    function getMatcher() {
      var expected = null,
          errorType = null;

      if (arguments.length == 2) {
        expected = arguments[1];
        if (isAnErrorType(expected)) {
          errorType = expected;
          expected = null;
        }
      } else if (arguments.length > 2) {
        errorType = arguments[1];
        expected = arguments[2];
        if (!isAnErrorType(errorType)) {
          throw new Error(getErrorMsg('Expected error type is not an Error.'));
        }
      }

      if (expected && !isStringOrRegExp(expected)) {
        if (errorType) {
          throw new Error(getErrorMsg('Expected error message is not a string or RegExp.'));
        } else {
          throw new Error(getErrorMsg('Expected is not an Error, string, or RegExp.'));
        }
      }

      function messageMatch(message) {
        if (typeof expected == 'string') {
          return expected == message;
        } else {
          return expected.test(message);
        }
      }

      return {
        errorTypeDescription: errorType ? j$.fnNameFor(errorType) : 'an exception',
        thrownDescription: function(thrown) {
          var thrownName = errorType ? j$.fnNameFor(thrown.constructor) : 'an exception',
              thrownMessage = '';

          if (expected) {
            thrownMessage = ' with message ' + j$.pp(thrown.message);
          }

          return thrownName + thrownMessage;
        },
        messageDescription: function() {
          if (expected === null) {
            return '';
          } else if (expected instanceof RegExp) {
            return ' with a message matching ' + j$.pp(expected);
          } else {
            return ' with message ' + j$.pp(expected);
          }
        },
        hasNoSpecifics: function() {
          return expected === null && errorType === null;
        },
        matches: function(error) {
          return (errorType === null || error instanceof errorType) &&
            (expected === null || messageMatch(error.message));
        }
      };
    }

    function isStringOrRegExp(potential) {
      return potential instanceof RegExp || (typeof potential == 'string');
    }

    function isAnErrorType(type) {
      if (typeof type !== 'function') {
        return false;
      }

      var Surrogate = function() {};
      Surrogate.prototype = type.prototype;
      return (new Surrogate()) instanceof Error;
    }
  }

  return toThrowError;
};

getJasmineRequireObj().interface = function(jasmine, env) {
  var jasmineInterface = {
    describe: function(description, specDefinitions) {
      return env.describe(description, specDefinitions);
    },

    xdescribe: function(description, specDefinitions) {
      return env.xdescribe(description, specDefinitions);
    },

    fdescribe: function(description, specDefinitions) {
      return env.fdescribe(description, specDefinitions);
    },

    it: function() {
      return env.it.apply(env, arguments);
    },

    xit: function() {
      return env.xit.apply(env, arguments);
    },

    fit: function() {
      return env.fit.apply(env, arguments);
    },

    beforeEach: function() {
      return env.beforeEach.apply(env, arguments);
    },

    afterEach: function() {
      return env.afterEach.apply(env, arguments);
    },

    beforeAll: function() {
      return env.beforeAll.apply(env, arguments);
    },

    afterAll: function() {
      return env.afterAll.apply(env, arguments);
    },

    expect: function(actual) {
      return env.expect(actual);
    },

    pending: function() {
      return env.pending.apply(env, arguments);
    },

    fail: function() {
      return env.fail.apply(env, arguments);
    },

    spyOn: function(obj, methodName) {
      return env.spyOn(obj, methodName);
    },

    jsApiReporter: new jasmine.JsApiReporter({
      timer: new jasmine.Timer()
    }),

    jasmine: jasmine
  };

  jasmine.addCustomEqualityTester = function(tester) {
    env.addCustomEqualityTester(tester);
  };

  jasmine.addMatchers = function(matchers) {
    return env.addMatchers(matchers);
  };

  jasmine.clock = function() {
    return env.clock;
  };

  return jasmineInterface;
};

getJasmineRequireObj().version = function() {
  return '2.5.2';
};


Node-path: trunk/sumatoria-cubo/WebContent/dependencias/jasmine_favicon.png
Node-kind: file
Node-action: add
Text-content-md5: 1f362dce075a4baf7de02117606aeeb2
Text-content-sha1: 80423b4687f3ae39d8ffd0abebbe383f5109eaac
Prop-content-length: 59
Text-content-length: 1486
Content-length: 1545

K 13
svn:mime-type
V 24
application/octet-stream
PROPS-END
‰PNG

   IHDR           D¤ŠÆ  OPLTEÿÿÿÿ ÿ€€€ªUª€@€™f™€U€’I’€`€™M€‹]‹•U€‰N‰’[€ˆUˆP€‡Z‡”Q†’U†‹Q€Y…ŠU€R…ŽU„’R€X„‘U€ŒR„X€‹UƒS€‘SƒUƒŒS€WƒŽS‚‘Q€ŽU‚S€S‚ŒU‚ŽS„R‚ŽU„S‚R„T„R‚ŽT‚R„ŽU‚TƒRUƒTŒUŽTƒSŽUƒSƒTƒŽSUƒŽTSƒUƒTUŽT‚SŽU‚TS‚UT‚ŽSU‚S‚ŽUT‚SU‚TƒŽT‚SƒŽU‚TƒS‚ŽSƒŽTƒT‚TƒŽT‚UƒŽT‚TƒŽU‚TƒŽS‚TŽT‚SŽT‚TŽS‚TT‚S‚ŽTŽSTŽS‚TŽT‚SŽT‚TŽS‚ŽTƒŽSƒT‚ŽTƒS‚ŽTƒT‚ŽSƒTƒŽS‚TƒŽT‚SƒŽU‚ŽT‚ŽT‚U‚ŽT‚ŽT‚ŽU‚ŽT‚ŽT‚U‚T‚ŽU‚ŽT‚ŽT‚ŽU‚ŽT‚ŽT‚UTŽU‚ŽT‚ŽUŽT‚ŽTU‚ŽTT‚ŽUƒŽT‚ŽU‚UƒŽT‚ŽS‚ŽT‚ŽT‚ŽS‚ŽT‚ŽT‚S‚ŽT‚ŽS‚ŽT‚ŽT‚ŽT‚ŽT‚T‚ŽT‚ŽT‚ŽT‚ŽT‚ŽT‚ŽT‚ŽT‚ŽT‚ŽT‚ŽT‚ŽT‚ŽT‚ŽT‚ŽT‚ŽT‚ŽT‚ŽT‚ŽT‚ŽT‚ŽT‚Óþ0É   ÄtRNS 
 !"%'()+,-.1345678:;=>?@ABCEFGHJLMNOPTUWXYZ[\]^_`bcdefgjklmnqstwz{|}~‚ƒ„…†‡ˆ‹Ž’“”•–—˜™šœžŸ ¡¢¤¥¦§¨¬­®¯°³µ¶·¸º»¼½¾¿ÀÁÃÄÆÇÈÉÊËÌÍÎÐÓÕÖ×ØÙÚÛÜÝßàáãäåæèéêëìíïðñòóöøùúüýþX¯F  jIDATx^mÐé[ŒQ‡ñïÌTSFE’ìZd§Dö=$;B {!;DDv(% íRƒ÷æ9Ï\Jø¼9×ï:÷‹s~êœš{ûmSãëë;'¹ô¯þZéP¿­‡º
ÊþF-+õ§¨r ßýœ%©33öUü(
U‡¡u@[vù)æÈwày¤ü4°¸j±ññCeR
Tzds?¶ÉÖd.É¶Ø*%îêöÆÈyX$Ë v(”ÔóãŒßAÆË)¸ê¬Syð9B–	ýüÁ–‘²ŒòA–äù[äpJÚ~×ewe¦$—t^H³¡=B±µ&¸rÃLµßÚú©†p†é0”H»Æüä€'P2û‚X,G-¬Ö#ûUØNFÆ'tŒíŠtŽ«æÊs¾ãœ,Ï0öKÙP"/$IrO?Ù³dÙ­IZOÕSeó$/”%4=Ñ%[”©JŠX^üÁ±ùNŒ4öQZï†¼dÓî„bÝƒ9®{†Íƒ/ãÒ|´ÇÞTÑ²C*„£Ê…‡ÒønRt0?¨öXÓD¹š`™¦o€,»®ÐwÀIðs ÜŸ`¯äßUs¿c	ßí-YŠ¡TÒø:HýHÕ©Ú x#¥)@š¤^^¸ ÇúvÊÎ›´Î‘ÂßÃûßk|IqWƒí@}Š¢¤à[@Šg	p"H†	láæþüzVeÃe„¸eL~Ü’Ÿú¾|§ãäçLº†¹Q‡°"Œš³[Ven¿Ü„q(PJo¢‹êýÅ³®ŠeKô#²
nW”ßÈ[­N¿ ·tXZ,u[{    IEND®B`‚

Node-path: trunk/sumatoria-cubo/WebContent/sumatoriacubo.js
Node-kind: file
Node-action: change
Text-content-md5: e1fde74cbd3ad0544c7fdba90ec1fe40
Text-content-sha1: 7daf17df509c1fa11feaca0105b66599b8c4d0ee
Text-content-length: 3394
Content-length: 3394


(function(sumatoriacubo) {
var sumatoriacubo = sumatoriacubo || {};

sumatoriacubo.procesar = function()
{
	var cadenaResultado = ''; 
	
	var comandos = document.getElementById('Comandos').value.trim();
	var lineaActual = 0;
	var comandosComoLineas = comandos.split('\n');
	var numeroPruebas = parseInt( comandosComoLineas[lineaActual++].trim() );
	for(var i = 0; i < numeroPruebas ; i++)
	{
		var matriz = new Map();
		var dimesionMatrizSentencias = comandosComoLineas[lineaActual++].trim().split(' ');
		var dimensionMatriz =  parseInt( dimesionMatrizSentencias[0] );
		var numeroSentencias =  parseInt( dimesionMatrizSentencias[1] );
		for(var j = 0; j < numeroSentencias ;  j++)
		{
			var comando = comandosComoLineas[lineaActual++].trim();
			if( comando.substring(0,6) === 'UPDATE' )
			{
				var tokens = comando.split(' ');
				matriz.set(tokens[1] + '|' + tokens[2] + '|' + tokens[3], parseInt(tokens[4]) );
			}
			else if( comando.substring(0,5) === 'QUERY' )
			{
				var tokens = comando.split(' ');
				var x1 = parseInt(tokens[1]);
				var y1 = parseInt(tokens[2]);
				var z1 = parseInt(tokens[3]);
				var x2 = parseInt(tokens[4]);
				var y2 = parseInt(tokens[5]);
				var z2 = parseInt(tokens[6]);
				var suma = 0;
				for (var [key, value] of matriz) 
				{
					var keyTokens = key.split('|');
					var x = parseInt(keyTokens[0]);
					var y = parseInt(keyTokens[1]);
					var z = parseInt(keyTokens[2]);					
					if ( (x >= x1 && x <= x2) && (y >= y1 && y <= y2) && (z >= z1 && z <= z2)  )
					{
						suma += value;
					}
				}
				cadenaResultado += suma + '\n';
			}
		}		
	}
	
	document.getElementById('Resultado').value = cadenaResultado;
}


/**
 * Convierte un string en un entero. Regresa un objeto con la estructura {estado,mensaje,datos}. Si la operacion es
 * exitosa regresa: {estado:'EXITO',mensaje:'Operacion exitosa',datos:valor} donde valor corresponde al valor convertido.
 * En caso de fallar regresa lo siguiente:
 * - Si no se ingresa un valor : {estado:'ERROR_VALOR_IDEFENIDO',mensaje:'Valor indefinido'};
 * - Si se envia null: {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
 * - Si se envia un valor que no es un string: { estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
 * - Si se envia una cadena con valor que no corresponde a un string se regresa:
 *   {estado:'ERROR_VALOR_NO_ENTERO',mensaje:'Valor [' + numeroComoCadena + '] no es entero'} donde numeroComoCadena
 *   corresponde al valor enviado a la funcion.
 */
sumatoriacubo.stringToEntero = function(numeroComoCadena)
{
	if(numeroComoCadena === undefined)
	{
		return {estado:'ERROR_VALOR_IDEFENIDO',mensaje:'Valor indefinido'};
	}
	if(numeroComoCadena === null)
	{
		return {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
	}
	if (typeof numeroComoCadena !== 'string') 
	{
		return { estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
	}
		
	var valor = parseInt(numeroComoCadena);
	if( isNaN(valor) )
	{
		return {estado:'ERROR_VALOR_NO_ENTERO',mensaje:'Valor [' + numeroComoCadena + '] no es entero'};
	}
	else if(new String(valor) != numeroComoCadena.trim() )
	{
		return {estado:'ERROR_VALOR_NO_ENTERO',mensaje:'Valor [' + numeroComoCadena + '] no es entero'};
	}
	else
	{
		return {estado:'EXITO',mensaje:'Operacion exitosa',datos:valor};
	}	
};

})(window.sumatoriacubo || (window.sumatoriacubo = {}));

Node-path: trunk/sumatoria-cubo/WebContent/testsumatoriacubo.html
Node-kind: file
Node-action: add
Text-content-md5: ad0e8593904617f3ce7349287eb7cf21
Text-content-sha1: 4be6e35464a442e8a5f5e9b8a4cbf6eda0c95d76
Prop-content-length: 10
Text-content-length: 534
Content-length: 544

PROPS-END
<!DOCTYPE html>
<html>
	<meta charset="utf-8">
	<title>Jasmine Spec Runner v2.5.2</title>

	<link rel="shortcut icon" type="image/png" href="dependencias/jasmine_favicon.png">
	<link rel="stylesheet" href="dependencias/jasmine.css">

	<script src="dependencias/jasmine.js"></script>
	<script src="dependencias/jasmine-html.js"></script>
	<script src="dependencias/boot.js"></script>

	<script src="sumatoriacubo.js"></script>
	<script src="testsumatoriacubo.js"></script>

</head>
<body>
	<h1>Test Sumatoria cubo</h1>

</body>
</html>

Node-path: trunk/sumatoria-cubo/WebContent/testsumatoriacubo.js
Node-kind: file
Node-action: add
Text-content-md5: 8025cc496b9944c4697bc8b62d3550ac
Text-content-sha1: 051d058da3a6bbb13a1bfb3d9ce5d929d9052f75
Prop-content-length: 10
Text-content-length: 2410
Content-length: 2420

PROPS-END

(function(sumatoriacubo) {
var sumatoriacubo = sumatoriacubo || {};

describe("Sumatoria cubo - Conversion de cadenas a numeros", function() 
{
	describe("Cuando se intentar convertir un valor idefinido o nulo a entero", function() 
	{
		it("Debe indicar que no se ingreso un valor", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero();
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_IDEFENIDO');
		});
		
		it("Debe indicar que se ingreso un valor nulo", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero(null);
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NULO');
		});
	});
	
	describe("Cuando se intenta convertir a entero una cadena con un valor no numerico", function() 
	{
		it("Debe indicar que no se ingreso una cadena con un valor entero para el valor ['1a']", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero('1a');
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que no se ingreso una cadena con un valor entero para el valor ['a1']", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero('a1');
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que no se ingreso una cadena con un valor entero para el valor ['']", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero('');
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que no se ingreso una cadena", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero(1);
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_STRING');
		});
	});
	
	describe("Cuando se intenta convertir una cadena con un valor valido", function() 
	{
		var numero = Math.floor((Math.random() *  Number.MAX_SAFE_INTEGER ) );
		var stringNumero = numero + '';
		it("Debe indicar que la operacion es exitosa y regresar el valor correctamente si se envia el valor ['" + numero + "']", function() 
		{			
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero(stringNumero);
		    expect(resultadoValorIndefinido.estado).toBe('EXITO');
		    expect(resultadoValorIndefinido.datos).toBe(numero);
		});
	});
});

})(window.sumatoriacubo || (window.sumatoriacubo = {}));

Revision-number: 11
Prop-content-length: 208
Content-length: 208

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-28T16:45:16.637000Z
K 7
svn:log
V 106
- Se agrega codigo que lee el numero de pruebas
- Se agegan pruebas al codigo que lee el numero de pruebas
PROPS-END

Node-path: trunk/sumatoria-cubo/WebContent/sumatoriacubo.html
Node-kind: file
Node-action: change
Text-content-md5: 3a5938faac51696918ff2318cb0004b3
Text-content-sha1: c78604f0ccda8d15bf50f21cbf2eb4a9dd4ca841
Text-content-length: 954
Content-length: 954

<!DOCTYPE html>
<html>
	<head>
	<meta charset="UTF-8">
	<title>Sumatoria cubo</title>
	<link rel="stylesheet" type="text/css" href="dependencias/foundation.min.css" />
</head>
<body>	
	<h1>Sumatoria cubo</h1>
	<h4 id="MensajeResultado"></h4>
	<form>
		<div class="row">
			<div class="medium-5 columns">
				<label>
					Entrada:
					<textarea id="Comandos" rows="15">
2
4 5
UPDATE 2 2 2 4
QUERY 1 1 1 3 3 3
UPDATE 1 1 1 23
QUERY 2 2 2 4 4 4
QUERY 1 1 1 3 3 3
2 4
UPDATE 2 2 2 1
QUERY 1 1 1 1 1 1
QUERY 1 1 1 2 2 2
QUERY 2 2 2 2 2 2
					</textarea>
				</label>
			</div>
			<div class="medium-2 columns">
				<input class="button" type="button" onclick="sumatoriacubo.procesar()" value="Procesar" />
			</div>
			<div class="medium-5 columns">
				<label>
					Salida:
					<textarea id="Resultado" rows="15">		
					</textarea>
				</label>
			</div>
		</div>
	</form>
	<script type="text/javascript" src="sumatoriacubo.js"></script>	
</body>
</html>

Node-path: trunk/sumatoria-cubo/WebContent/sumatoriacubo.js
Node-kind: file
Node-action: change
Text-content-md5: 256f2e76b2a0521c083a0ddcf8376737
Text-content-sha1: 30b3089c02edc3a0bde9a767a8b05658ec70001c
Text-content-length: 5336
Content-length: 5336


(function(sumatoriacubo) {
var sumatoriacubo = sumatoriacubo || {};

sumatoriacubo.procesar = function()
{
	document.getElementById('MensajeResultado').innerHTML = '';	
	var resultado = sumatoriacubo.procesarUsandoClase();
	if( resultado.estado === 'EXITO' )
	{
		document.getElementById('Resultado').value = resultado.datos;
	}
	else
	{
		var mensaje;
		if(resultado.mensajeAdicional)
		{
			mensaje = resultado.mensajeAdicional + ' ' + resultado.mensaje;
		}
		else
		{
			mensaje =  resultado.mensaje;
		}
		document.getElementById('MensajeResultado').innerHTML = mensaje;
		document.getElementById('Resultado').value = '';
	}
};

sumatoriacubo.procesarUsandoClase = function()
{
	var cadenaResultado = ''; 
	var lineaActual = 0;
	
	var comandos = document.getElementById('Comandos').value.trim();	
	var lectorPruebas = new sumatoriacubo.LectorPruebas(comandos);
	
	var comandosComoLineas = comandos.split('\n');
		
	var resultadosNumeroPruebas = lectorPruebas.leerNumeroPruebas( comandosComoLineas[lineaActual++] );
	if(resultadosNumeroPruebas.estado !== 'EXITO')
	{
		return resultadosNumeroPruebas;
	}	
	var numeroPruebas = resultadosNumeroPruebas.datos;
	
	for(var i = 0; i < numeroPruebas ; i++)
	{
		var matriz = new Map();
		var dimesionMatrizSentencias = comandosComoLineas[lineaActual++].trim().split(' ');
		var dimensionMatriz =  parseInt( dimesionMatrizSentencias[0] );
		var numeroSentencias =  parseInt( dimesionMatrizSentencias[1] );
		for(var j = 0; j < numeroSentencias ;  j++)
		{
			var comando = comandosComoLineas[lineaActual++].trim();
			if( comando.substring(0,6) === 'UPDATE' )
			{
				var tokens = comando.split(' ');
				matriz.set(tokens[1] + '|' + tokens[2] + '|' + tokens[3], parseInt(tokens[4]) );
			}
			else if( comando.substring(0,5) === 'QUERY' )
			{
				var tokens = comando.split(' ');
				var x1 = parseInt(tokens[1]);
				var y1 = parseInt(tokens[2]);
				var z1 = parseInt(tokens[3]);
				var x2 = parseInt(tokens[4]);
				var y2 = parseInt(tokens[5]);
				var z2 = parseInt(tokens[6]);
				var suma = 0;
				for (var [key, value] of matriz) 
				{
					var keyTokens = key.split('|');
					var x = parseInt(keyTokens[0]);
					var y = parseInt(keyTokens[1]);
					var z = parseInt(keyTokens[2]);					
					if ( (x >= x1 && x <= x2) && (y >= y1 && y <= y2) && (z >= z1 && z <= z2)  )
					{
						suma += value;
					}
				}
				cadenaResultado += suma + '\n';
			}
		}		
	}
	
	return { estado:'EXITO',mensaje:'Operacion exitosa', datos:cadenaResultado};
}

/**
 * Clase que procesa las pruebas.
 * @param comandos Texto con los comandos a procesar.
 */
sumatoriacubo.LectorPruebas = function(comandos)
{
	this.comandos = comandos;
};

/**
 * Metodo que lee el numero de pruebas de una cadena de texto.
 * @param comando Cadena con el numero de pruebas
 * @return Regresa un objeto con el resultado de la prueba. El objeto tiene la estructura {estado,mensaje,datos}.
 * Si el valor no es numerico regresa un objeto con la estructura regresada por la funcion sumatoriacubo.stringToEntero,
 * Si el valor no esta en el rango entre 1 y 50 regresa en el estado el valor 'ERROR_RANGO_INVALIDO'
 */
sumatoriacubo.LectorPruebas.prototype.leerNumeroPruebas = function(comando)
{
	var resultado = sumatoriacubo.stringToEntero(comando);
	if( resultado.estado === 'EXITO' )
	{
		if ( resultado.datos < 1 || resultado.datos > 50 )
		{
			return {estado:'ERROR_RANGO_INVALIDO',mensaje:'El numero de pruebas no esta entre 1 y 50.'};
		}		
		return resultado;
	}
	else
	{
		resultado.mensajeAdicional = 'El numero de pruebas no es un numero entero valido.';
		return resultado;
	}	
};

/**
 * Convierte un string en un entero. Regresa un objeto con la estructura {estado,mensaje,datos}. Si la operacion es
 * exitosa regresa: {estado:'EXITO',mensaje:'Operacion exitosa',datos:valor} donde valor corresponde al valor convertido.
 * En caso de fallar regresa lo siguiente:
 * - Si no se ingresa un valor : {estado:'ERROR_VALOR_IDEFENIDO',mensaje:'Valor indefinido'};
 * - Si se envia null: {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
 * - Si se envia un valor que no es un string: { estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
 * - Si se envia una cadena con valor que no corresponde a un string se regresa:
 *   {estado:'ERROR_VALOR_NO_ENTERO',mensaje:'Valor [' + numeroComoCadena + '] no es entero'} donde numeroComoCadena
 *   corresponde al valor enviado a la funcion.
 */
sumatoriacubo.stringToEntero = function(numeroComoCadena)
{
	if(numeroComoCadena === undefined)
	{
		return {estado:'ERROR_VALOR_IDEFENIDO',mensaje:'Valor indefinido'};
	}
	if(numeroComoCadena === null)
	{
		return {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
	}
	if (typeof numeroComoCadena !== 'string') 
	{
		return { estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
	}
		
	var valor = parseInt(numeroComoCadena);
	if( isNaN(valor) )
	{
		return {estado:'ERROR_VALOR_NO_ENTERO',mensaje:'Valor [' + numeroComoCadena + '] no es entero'};
	}
	else if(new String(valor) != numeroComoCadena.trim() )
	{
		return {estado:'ERROR_VALOR_NO_ENTERO',mensaje:'Valor [' + numeroComoCadena + '] no es entero'};
	}
	else
	{
		return {estado:'EXITO',mensaje:'Operacion exitosa',datos:valor};
	}	
};

})(window.sumatoriacubo || (window.sumatoriacubo = {}));

Node-path: trunk/sumatoria-cubo/WebContent/testsumatoriacubo.html
Node-kind: file
Node-action: change
Text-content-md5: fa58ba14ba07f83d197c368ab1ca0d36
Text-content-sha1: 6bbd1efb7af7086079d1039e915c05b3830eb9ef
Text-content-length: 533
Content-length: 533

<!DOCTYPE html>
<html>
	<meta charset="utf-8">
	<title>Jasmine Spec Runner v2.5.2</title>

	<link rel="shortcut icon" type="image/png" href="dependencias/jasmine_favicon.png">
	<link rel="stylesheet" href="dependencias/jasmine.css">

	<script src="dependencias/jasmine.js"></script>
	<script src="dependencias/jasmine-html.js"></script>
	<script src="dependencias/boot.js"></script>

	<script src="sumatoriacubo.js"></script>
	<script src="testsumatoriacubo.js"></script>

</head>
<body>
	<h1>Test Sumatoria cubo</h1>
</body>
</html>

Node-path: trunk/sumatoria-cubo/WebContent/testsumatoriacubo.js
Node-kind: file
Node-action: change
Text-content-md5: 17a27177292fd6e91a1d664bc216c386
Text-content-sha1: 3a15c0f625ac6b88616d06156c1998efd77b0522
Text-content-length: 3935
Content-length: 3935


(function(sumatoriacubo) {
var sumatoriacubo = sumatoriacubo || {};

describe("Sumatoria cubo - Conversion de cadenas a numeros", function() 
{
	describe("Cuando se intentar convertir un valor idefinido o nulo a entero", function() 
	{
		it("Debe indicar que no se ingreso un valor", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero();
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_IDEFENIDO');
		});
		
		it("Debe indicar que se ingreso un valor nulo", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero(null);
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NULO');
		});
	});
	
	describe("Cuando se intenta convertir a entero una cadena con un valor no numerico", function() 
	{
		it("Debe indicar que no se ingreso una cadena con un valor entero para el valor ['1a']", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero('1a');
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que no se ingreso una cadena con un valor entero para el valor ['a1']", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero('a1');
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que no se ingreso una cadena con un valor entero para el valor ['']", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero('');
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que no se ingreso una cadena", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero(1);
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_STRING');
		});
	});
	
	describe("Cuando se intenta convertir una cadena con un valor valido", function() 
	{
		var numero = Math.floor((Math.random() *  Number.MAX_SAFE_INTEGER ) );
		var stringNumero = numero + '';
		it("Debe indicar que la operacion es exitosa y regresar el valor correctamente si se envia el valor ['" + numero + "']", function() 
		{			
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero(stringNumero);
		    expect(resultadoValorIndefinido.estado).toBe('EXITO');
		    expect(resultadoValorIndefinido.datos).toBe(numero);
		});
	});
		
	describe("Cuando el numero de pruebas a leer es invalido", function() 
	{
		it("Debe indicar que el numero de pruebas es invalido si envia texto en lugar de un numero", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas('w').estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que el numero de pruebas es invalido si envia texto vacio", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas('').estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que el numero de pruebas es invalido si envia texto un valor menor a 1", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas('0').estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar que el numero de pruebas es invalido si envia texto un valor mayor a 50", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas('51').estado).toBe('ERROR_RANGO_INVALIDO');
		});		
		
		var numero = Math.floor((Math.random() *  50 ) + 1 );
		var stringNumero = numero + '';
		it("Debe indicar que el numero de pruebas es valido si envia texto un valor [" + stringNumero +"] el cual esta entre 1 y 50", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas(stringNumero).estado).toBe('EXITO');
		});
	});
});

})(window.sumatoriacubo || (window.sumatoriacubo = {}));

Revision-number: 12
Prop-content-length: 294
Content-length: 294

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-28T18:42:25.224000Z
K 7
svn:log
V 192
- Se agrega metodo que permite la lectura de la dimension de la matriz y el numero de setencias en la prueba
- Se agregan pruebas para el motodo
- Se mejora los nombres de las suits de pruebas
PROPS-END

Node-path: trunk/sumatoria-cubo/WebContent/sumatoriacubo.js
Node-kind: file
Node-action: change
Text-content-md5: a7360fa2a9b7e27e1355340e2a0d4bfe
Text-content-sha1: 22a7dd1516d872e9cc0172fc09bd61e0e4647630
Text-content-length: 8493
Content-length: 8493


(function(sumatoriacubo) {
var sumatoriacubo = sumatoriacubo || {};

sumatoriacubo.procesar = function()
{
	document.getElementById('MensajeResultado').innerHTML = '';	
	var resultado = sumatoriacubo.procesarUsandoClase();
	if( resultado.estado === 'EXITO' )
	{
		document.getElementById('Resultado').value = resultado.datos;
	}
	else
	{
		var mensaje;
		if(resultado.mensajeAdicional)
		{
			mensaje = resultado.mensajeAdicional + ' ' + resultado.mensaje;
		}
		else
		{
			mensaje =  resultado.mensaje;
		}
		document.getElementById('MensajeResultado').innerHTML = mensaje;
		document.getElementById('Resultado').value = '';
	}
};

sumatoriacubo.procesarUsandoClase = function()
{
	var cadenaResultado = ''; 
	var lineaActual = 0;
	
	var comandos = document.getElementById('Comandos').value.trim();	
	var lectorPruebas = new sumatoriacubo.LectorPruebas(comandos);
	
	var comandosComoLineas = comandos.split('\n');
		
	var resultadosNumeroPruebas = lectorPruebas.leerNumeroPruebas( comandosComoLineas[lineaActual++] );
	if(resultadosNumeroPruebas.estado !== 'EXITO')
	{
		return resultadosNumeroPruebas;
	}	
	var numeroPruebas = resultadosNumeroPruebas.datos;
	
	for(var i = 0; i < numeroPruebas ; i++)
	{
		var resultadosLecturaDimensionMatrizSentencias = lectorPruebas.leerDimensionMatrizSentencias(comandosComoLineas[lineaActual++]);
		if(resultadosLecturaDimensionMatrizSentencias.estado !== 'EXITO')
		{
			return resultadosLecturaDimensionMatrizSentencias;
		}
		
		var dimensionMatriz = resultadosLecturaDimensionMatrizSentencias.datos.dimensionMatriz;
		var numeroSentencias = resultadosLecturaDimensionMatrizSentencias.datos.numeroSentencias;
		var matriz = new Map();
		
		for(var j = 0; j < numeroSentencias ;  j++)
		{
			var comando = comandosComoLineas[lineaActual++].trim();
			if( comando.substring(0,6) === 'UPDATE' )
			{
				var tokens = comando.split(' ');
				matriz.set(tokens[1] + '|' + tokens[2] + '|' + tokens[3], parseInt(tokens[4]) );
			}
			else if( comando.substring(0,5) === 'QUERY' )
			{
				var tokens = comando.split(' ');
				var x1 = parseInt(tokens[1]);
				var y1 = parseInt(tokens[2]);
				var z1 = parseInt(tokens[3]);
				var x2 = parseInt(tokens[4]);
				var y2 = parseInt(tokens[5]);
				var z2 = parseInt(tokens[6]);
				var suma = 0;
				for (var [key, value] of matriz) 
				{
					var keyTokens = key.split('|');
					var x = parseInt(keyTokens[0]);
					var y = parseInt(keyTokens[1]);
					var z = parseInt(keyTokens[2]);					
					if ( (x >= x1 && x <= x2) && (y >= y1 && y <= y2) && (z >= z1 && z <= z2)  )
					{
						suma += value;
					}
				}
				cadenaResultado += suma + '\n';
			}
		}		
	}
	
	return { estado:'EXITO',mensaje:'Operacion exitosa', datos:cadenaResultado};
};

/**
 * Clase que procesa las pruebas.
 * @param comandos Texto con los comandos a procesar.
 */
sumatoriacubo.LectorPruebas = function(comandos)
{
	this.comandos = comandos;
};

/**
 * Metodo que lee el numero de pruebas de una cadena de texto.
 * @param comando Cadena con el numero de pruebas
 * @return Regresa un objeto con el resultado de la prueba. El objeto tiene la estructura {estado,mensaje,datos}.
 * Si el valor no es numerico regresa un objeto con la estructura regresada por la funcion sumatoriacubo.stringToEntero,
 * Si el valor no esta en el rango entre 1 y 50 regresa en el estado el valor 'ERROR_RANGO_INVALIDO'
 */
sumatoriacubo.LectorPruebas.prototype.leerNumeroPruebas = function(comando)
{
	var resultado = sumatoriacubo.stringToEntero(comando);
	if( resultado.estado === 'EXITO' )
	{
		if ( resultado.datos < 1 || resultado.datos > 50 )
		{
			return {estado:'ERROR_RANGO_INVALIDO',mensaje:'El numero de pruebas no esta entre 1 y 50.'};
		}		
		return resultado;
	}
	else
	{
		resultado.mensajeAdicional = 'El numero de pruebas no es un numero entero valido.';
		return resultado;
	}	
};

/**
 * Lee la dimension de la matriz y el numero de sentencias de la prueba.
 * @param comando Cadena con el texto
 * @return Regresa un objeto con la estructura {estado,mensaje, datos:{dimensionMatriz,numeroSentencias}}.
 * - Si alguno de los valores no es numerico regresa un objeto con la estructura que se indica del metodo sumatoriacubo.stringToEntero
 * - Si la cadena enviada a la funcion no contiene dos valores, entonces se regresa estado = 'ERROR_DIMENSION_MATRIZ_SENTENCIA'
 * - Si la dimension de la matriz no esta en el rango entre 1 y 100 regresa estado = 'ERROR_RANGO_INVALIDO'
 * - Si el numero de sentencias no esta en el rango entre 1 y 1000 regresa estado =  'ERROR_RANGO_INVALIDO'
 * - Si no se define valor se regresa estado = 'ERROR_VALOR_IDEFENIDO'
 * - Si el valor es nulo regresa estado = 'ERROR_VALOR_NULO'
 * - Si el valor no es string regresa estado = 'ERROR_VALOR_NO_STRING'
 */
sumatoriacubo.LectorPruebas.prototype.leerDimensionMatrizSentencias = function(comando)
{
	if(comando === undefined)
	{
		return {estado:'ERROR_VALOR_IDEFENIDO',mensaje:'Valor indefinido'};
	}
	if(comando === null)
	{
		return {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
	}
	if (typeof comando !== 'string') 
	{
		return { estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
	}	
	
	var dimesionMatrizSentencias = comando.trim().split(' ');
	if( dimesionMatrizSentencias.length != 2 )
	{
		return {estado:'ERROR_DIMENSION_MATRIZ_SENTENCIA',mensaje:'El valor [' + comando +'] no contiene un valor valido con la dimension de la matriz y el numero de sentencias.'};
	}
	
	// Procesar el valor con la dimension de la matriz
	var resultadoDimensionMatriz = sumatoriacubo.stringToEntero( dimesionMatrizSentencias[0] );
	if( resultadoDimensionMatriz.estado === 'EXITO' )
	{
		if ( resultadoDimensionMatriz.datos < 1 || resultadoDimensionMatriz.datos > 100 )
		{
			return {estado:'ERROR_RANGO_INVALIDO',mensaje:'La dimension de la matriz no esta entre 1 y 100.'};
		}
	}
	else
	{
		resultadoDimensionMatriz.mensajeAdicional = 'La dimension de la matriz no es un numero entero valido.';
		return resultadoDimensionMatriz;
	}
	
	// Procesar el valor con el numero de sentencias
	var resultadoNumeroSentencias =  sumatoriacubo.stringToEntero( dimesionMatrizSentencias[1] );
	if( resultadoNumeroSentencias.estado === 'EXITO' )
	{
		if ( resultadoNumeroSentencias.datos < 1 || resultadoNumeroSentencias.datos > 1000 )
		{
			return {estado:'ERROR_RANGO_INVALIDO',mensaje:'El numero de sentencias no esta entre 1 y 1000.'};
		}
	}
	else
	{
		resultadoNumeroSentencias.mensajeAdicional = 'El numero de sentencias no es un numero entero valido.';
		return resultadoNumeroSentencias;
	}	
	
	// Regresar los datos si estos son validos
	return {estado:'EXITO',mensaje:'Operacion exitosa', datos:{dimensionMatriz:resultadoDimensionMatriz.datos,numeroSentencias:resultadoNumeroSentencias.datos}}
};


/**
 * Convierte un string en un entero. Regresa un objeto con la estructura {estado,mensaje,datos}. Si la operacion es
 * exitosa regresa: {estado:'EXITO',mensaje:'Operacion exitosa',datos:valor} donde valor corresponde al valor convertido.
 * En caso de fallar regresa lo siguiente:
 * - Si no se ingresa un valor : {estado:'ERROR_VALOR_IDEFENIDO',mensaje:'Valor indefinido'};
 * - Si se envia null: {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
 * - Si se envia un valor que no es un string: { estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
 * - Si se envia una cadena con valor que no corresponde a un string se regresa:
 *   {estado:'ERROR_VALOR_NO_ENTERO',mensaje:'Valor [' + numeroComoCadena + '] no es entero'} donde numeroComoCadena
 *   corresponde al valor enviado a la funcion.
 */
sumatoriacubo.stringToEntero = function(numeroComoCadena)
{
	if(numeroComoCadena === undefined)
	{
		return {estado:'ERROR_VALOR_IDEFENIDO',mensaje:'Valor indefinido'};
	}
	if(numeroComoCadena === null)
	{
		return {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
	}
	if (typeof numeroComoCadena !== 'string') 
	{
		return { estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
	}
		
	var valor = parseInt(numeroComoCadena);
	if( isNaN(valor) )
	{
		return {estado:'ERROR_VALOR_NO_ENTERO',mensaje:'Valor [' + numeroComoCadena + '] no es entero'};
	}
	else if(new String(valor) != numeroComoCadena.trim() )
	{
		return {estado:'ERROR_VALOR_NO_ENTERO',mensaje:'Valor [' + numeroComoCadena + '] no es entero'};
	}
	else
	{
		return {estado:'EXITO',mensaje:'Operacion exitosa',datos:valor};
	}	
};

})(window.sumatoriacubo || (window.sumatoriacubo = {}));

Node-path: trunk/sumatoria-cubo/WebContent/testsumatoriacubo.js
Node-kind: file
Node-action: change
Text-content-md5: fae47c4c07beb593b24f6f9624b74369
Text-content-sha1: 2e042930560a0cbbc73f7cb85edc1fb6776aeeb4
Text-content-length: 8849
Content-length: 8849


(function(sumatoriacubo) {
var sumatoriacubo = sumatoriacubo || {};

describe("Conversion de cadenas a numeros", function() 
{
	describe("Cuando se intentar convertir un valor idefinido o nulo a entero", function() 
	{
		it("Debe indicar que no se ingreso un valor", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero();
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_IDEFENIDO');
		});
		
		it("Debe indicar que se ingreso un valor nulo", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero(null);
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NULO');
		});
	});
	
	describe("Cuando se intenta convertir a entero una cadena con un valor no numerico", function() 
	{
		it("Debe indicar que no se ingreso una cadena con un valor entero para el valor ['1a']", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero('1a');
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que no se ingreso una cadena con un valor entero para el valor ['a1']", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero('a1');
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que no se ingreso una cadena con un valor entero para el valor ['']", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero('');
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que no se ingreso una cadena", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero(1);
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_STRING');
		});
	});
	
	describe("Cuando se intenta convertir una cadena con un valor valido", function() 
	{
		var numero = Math.floor((Math.random() *  Number.MAX_SAFE_INTEGER ) );
		var stringNumero = numero + '';
		it("Debe indicar que la operacion es exitosa y regresar el valor correctamente si se envia el valor ['" + numero + "']", function() 
		{			
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero(stringNumero);
		    expect(resultadoValorIndefinido.estado).toBe('EXITO');
		    expect(resultadoValorIndefinido.datos).toBe(numero);
		});
	});
});
	
describe("Lectura de numero de pruebas", function() 
{
	describe("Cuando el numero de pruebas a leer es invalido", function() 
	{
		it("Debe indicar que el numero de pruebas es invalido si envia texto en lugar de un numero", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas('w').estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que el numero de pruebas es invalido si envia texto vacio", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas('').estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que el numero de pruebas es invalido si envia texto un valor menor a 1", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas('0').estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar que el numero de pruebas es invalido si envia texto un valor mayor a 50", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas('51').estado).toBe('ERROR_RANGO_INVALIDO');
		});		
		
		var numero = Math.floor((Math.random() *  50 ) + 1 );
		var stringNumero = numero + '';
		it("Debe indicar que el numero de pruebas es valido si envia texto un valor [" + stringNumero +"] el cual esta entre 1 y 50", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas(stringNumero).estado).toBe('EXITO');
		});
	});
});	

describe("Lectura de dimension matriz y numero de sentencias", function() 
{
	describe("Cuando el valor con la dimension matriz y numero de sentencias es indefinido, nulo, no es una cadena o se envia los dos valores", function() 
	{
		it("Debe indicar error si no se define un valor para la dimension y el numero de sentencias", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias().estado).toBe('ERROR_VALOR_IDEFENIDO');
		});
		
		it("Debe indicar error si es nulo el valor para la dimension y el numero de sentencias", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias(null).estado).toBe('ERROR_VALOR_NULO');
		});
		
		it("Debe indicar error si el valor no es un string para la dimension y el numero de sentencias", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias(1).estado).toBe('ERROR_VALOR_NO_STRING');
		});
		
		it("Debe indicar error si el valor es un string vacio", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('').estado).toBe('ERROR_DIMENSION_MATRIZ_SENTENCIA');
		});

		it("Debe indicar error si solo se envia un valor", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('1').estado).toBe('ERROR_DIMENSION_MATRIZ_SENTENCIA');
		});
		
	});
	
	describe("Cuando el texto con la dimension de la matriz no es valido", function() 
	{
		it("Debe indicar que la dimension de la matriz es invalido si envia texto en lugar de un numero", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('n 3').estado).toBe('ERROR_VALOR_NO_ENTERO');
		});		
		
		var dimensionMenor = - Math.floor((Math.random() *  100 ) + 1 );
		var stringDimensionMenor = dimensionMenor + '';
		it("Debe indicar que la dimension de la matriz es invalida si el valor ["+ dimensionMenor +"] es menor es 1", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias(stringDimensionMenor + ' 3').estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		var dimensionMayor = 100 + Math.floor((Math.random() *  100 ) + 1 );
		var stringDimensionMayor = dimensionMayor + '';
		it("Debe indicar que la dimension de la matriz es invalida si el valor ["+ dimensionMayor +"] es mayor es 100", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias(stringDimensionMayor + ' 3').estado).toBe('ERROR_RANGO_INVALIDO');
		});		
	});
	
	describe("Cuando el texto con el numero de sentencias de la prueba no es valido", function() 
	{
		it("Debe indicar que la dimension de la matriz es invalido si envia texto en lugar de un numero", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('3 a').estado).toBe('ERROR_VALOR_NO_ENTERO');
		});		
		
		var sentenciasMenor = - Math.floor((Math.random() *  1000 ) + 1 );
		var stringSentenciasMenor = sentenciasMenor + '';
		it("Debe indicar que el numero de setencias es invalido si el valor ["+ sentenciasMenor +"] es menor es 1", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('3 ' + stringSentenciasMenor).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		var sentenciasMayor = 1000 + Math.floor((Math.random() *  1000 ) + 1 );
		var stringSentenciasMayor = sentenciasMayor + '';
		it("Debe indicar que el numero de setencias es invalido si el valor ["+ sentenciasMayor +"] es mayor es 1000", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('3 ' + stringSentenciasMayor).estado).toBe('ERROR_RANGO_INVALIDO');
		});		
	});
	
	describe("Cuando el texto con el la dimension de la matriz y el numero de sentencias es valido", function() 
	{
		var dimensionValida = Math.floor((Math.random() *  100 ) + 1 );
		var stringDimensionValida = dimensionValida + '';
		
		var sentenciaValida = Math.floor((Math.random() *  1000 ) + 1 );
		var stringSentenciaValida = sentenciaValida + '';
		it("Debe indicar que la dimension de la matriz y el numero de sentencias es valido para el valor ["+ stringDimensionValida + ' ' + sentenciaValida +"]", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias(stringDimensionValida + ' ' + stringSentenciaValida).estado).toBe('EXITO');
		});
	});	
});

})(window.sumatoriacubo || (window.sumatoriacubo = {}));

Revision-number: 13
Prop-content-length: 202
Content-length: 202

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-28T22:18:15.039000Z
K 7
svn:log
V 100
- Se agrega codigo que ejecuta el comando UPDATE
- Se agegan pruebas al codigo que ejecuta el UPDATE
PROPS-END

Node-path: trunk/sumatoria-cubo/WebContent/sumatoriacubo.js
Node-kind: file
Node-action: change
Text-content-md5: ccf08a49f58a0ad814d5f0b1381038a2
Text-content-sha1: 845a56c449b164d44b5e5f89fdbf59420ee89674
Text-content-length: 12370
Content-length: 12370


(function(sumatoriacubo) {
var sumatoriacubo = sumatoriacubo || {};

sumatoriacubo.procesar = function()
{
	document.getElementById('MensajeResultado').innerHTML = '';	
	var resultado = sumatoriacubo.procesarUsandoClase();
	if( resultado.estado === 'EXITO' )
	{
		document.getElementById('Resultado').value = resultado.datos;
	}
	else
	{
		var mensaje;
		if(resultado.mensajeAdicional)
		{
			mensaje = resultado.mensajeAdicional + ' ' + resultado.mensaje;
		}
		else
		{
			mensaje =  resultado.mensaje;
		}
		document.getElementById('MensajeResultado').innerHTML = mensaje;
		document.getElementById('Resultado').value = '';
	}
};

sumatoriacubo.procesarUsandoClase = function()
{
	var cadenaResultado = ''; 
	var lineaActual = 0;
	
	var comandos = document.getElementById('Comandos').value.trim();	
	var lectorPruebas = new sumatoriacubo.LectorPruebas(comandos);
	
	var comandosComoLineas = comandos.split('\n');
		
	var resultadosNumeroPruebas = lectorPruebas.leerNumeroPruebas( comandosComoLineas[lineaActual++] );
	if(resultadosNumeroPruebas.estado !== 'EXITO')
	{
		return resultadosNumeroPruebas;
	}	
	var numeroPruebas = resultadosNumeroPruebas.datos;
	
	for(var i = 0; i < numeroPruebas ; i++)
	{
		var resultadosLecturaDimensionMatrizSentencias = lectorPruebas.leerDimensionMatrizSentencias(comandosComoLineas[lineaActual++]);
		if(resultadosLecturaDimensionMatrizSentencias.estado !== 'EXITO')
		{
			return resultadosLecturaDimensionMatrizSentencias;
		}
		
		var dimensionMatriz = resultadosLecturaDimensionMatrizSentencias.datos.dimensionMatriz;
		var numeroSentencias = resultadosLecturaDimensionMatrizSentencias.datos.numeroSentencias;
		var matriz = new Map();
		
		for(var j = 0; j < numeroSentencias ;  j++)
		{
			var comando = comandosComoLineas[lineaActual++].trim();
			if( comando.substring(0,6) === 'UPDATE' )
			{
				var resultadoUpdate = lectorPruebas.ejecutarUpdate(comando,dimensionMatriz,matriz);
				if(resultadoUpdate.estado !== 'EXITO')
				{
					return resultadoUpdate;
				}
			}
			else if( comando.substring(0,5) === 'QUERY' )
			{
				var tokens = comando.split(' ');
				var x1 = parseInt(tokens[1]);
				var y1 = parseInt(tokens[2]);
				var z1 = parseInt(tokens[3]);
				var x2 = parseInt(tokens[4]);
				var y2 = parseInt(tokens[5]);
				var z2 = parseInt(tokens[6]);
				var suma = 0;
				for (var [key, value] of matriz) 
				{
					var keyTokens = key.split('|');
					var x = parseInt(keyTokens[0]);
					var y = parseInt(keyTokens[1]);
					var z = parseInt(keyTokens[2]);					
					if ( (x >= x1 && x <= x2) && (y >= y1 && y <= y2) && (z >= z1 && z <= z2)  )
					{
						suma += value;
					}
				}
				cadenaResultado += suma + '\n';
			}
		}		
	}
	
	return { estado:'EXITO',mensaje:'Operacion exitosa', datos:cadenaResultado};
};

/**
 * Clase que procesa las pruebas.
 * @param comandos Texto con los comandos a procesar.
 */
sumatoriacubo.LectorPruebas = function(comandos)
{
	this.comandos = comandos;
};

/**
 * Metodo que lee el numero de pruebas de una cadena de texto.
 * @param comando Cadena con el numero de pruebas
 * @return Regresa un objeto con el resultado de la prueba. El objeto tiene la estructura {estado,mensaje,datos}.
 * Si el valor no es numerico regresa un objeto con la estructura regresada por la funcion sumatoriacubo.stringToEntero,
 * Si el valor no esta en el rango entre 1 y 50 regresa en el estado el valor 'ERROR_RANGO_INVALIDO'
 */
sumatoriacubo.LectorPruebas.prototype.leerNumeroPruebas = function(comando)
{
	var resultado = sumatoriacubo.stringToEntero(comando);
	if( resultado.estado === 'EXITO' )
	{
		if ( resultado.datos < 1 || resultado.datos > 50 )
		{
			return {estado:'ERROR_RANGO_INVALIDO',mensaje:'El numero de pruebas no esta entre 1 y 50.'};
		}		
		return resultado;
	}
	else
	{
		resultado.mensajeAdicional = 'El numero de pruebas no es un numero entero valido.';
		return resultado;
	}	
};

/**
 * Lee la dimension de la matriz y el numero de sentencias de la prueba.
 * @param comando Cadena con el texto
 * @return Regresa un objeto con la estructura {estado,mensaje, datos:{dimensionMatriz,numeroSentencias}}.
 * - Si alguno de los valores no es numerico regresa un objeto con la estructura que se indica del metodo sumatoriacubo.stringToEntero
 * - Si la cadena enviada a la funcion no contiene dos valores, entonces se regresa estado = 'ERROR_DIMENSION_MATRIZ_SENTENCIA'
 * - Si la dimension de la matriz no esta en el rango entre 1 y 100 regresa estado = 'ERROR_RANGO_INVALIDO'
 * - Si el numero de sentencias no esta en el rango entre 1 y 1000 regresa estado =  'ERROR_RANGO_INVALIDO'
 * - Si no se define valor se regresa estado = 'ERROR_VALOR_IDEFENIDO'
 * - Si el valor es nulo regresa estado = 'ERROR_VALOR_NULO'
 * - Si el valor no es string regresa estado = 'ERROR_VALOR_NO_STRING'
 */
sumatoriacubo.LectorPruebas.prototype.leerDimensionMatrizSentencias = function(comando)
{
	if(comando === undefined)
	{
		return {estado:'ERROR_VALOR_IDEFENIDO',mensaje:'Valor indefinido'};
	}
	if(comando === null)
	{
		return {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
	}
	if (typeof comando !== 'string') 
	{
		return { estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
	}	
	
	var dimesionMatrizSentencias = comando.trim().split(' ');
	if( dimesionMatrizSentencias.length != 2 )
	{
		return {estado:'ERROR_DIMENSION_MATRIZ_SENTENCIA',mensaje:'El valor [' + comando +'] no contiene un valor valido con la dimension de la matriz y el numero de sentencias.'};
	}
	
	// Procesar el valor con la dimension de la matriz
	var resultadoDimensionMatriz = sumatoriacubo.stringToEntero( dimesionMatrizSentencias[0] );
	if( resultadoDimensionMatriz.estado === 'EXITO' )
	{
		if ( resultadoDimensionMatriz.datos < 1 || resultadoDimensionMatriz.datos > 100 )
		{
			return {estado:'ERROR_RANGO_INVALIDO',mensaje:'La dimension de la matriz no esta entre 1 y 100.'};
		}
	}
	else
	{
		resultadoDimensionMatriz.mensajeAdicional = 'La dimension de la matriz no es un numero entero valido.';
		return resultadoDimensionMatriz;
	}
	
	// Procesar el valor con el numero de sentencias
	var resultadoNumeroSentencias =  sumatoriacubo.stringToEntero( dimesionMatrizSentencias[1] );
	if( resultadoNumeroSentencias.estado === 'EXITO' )
	{
		if ( resultadoNumeroSentencias.datos < 1 || resultadoNumeroSentencias.datos > 1000 )
		{
			return {estado:'ERROR_RANGO_INVALIDO',mensaje:'El numero de sentencias no esta entre 1 y 1000.'};
		}
	}
	else
	{
		resultadoNumeroSentencias.mensajeAdicional = 'El numero de sentencias no es un numero entero valido.';
		return resultadoNumeroSentencias;
	}	
	
	// Regresar los datos si estos son validos
	return {estado:'EXITO',mensaje:'Operacion exitosa', datos:{dimensionMatriz:resultadoDimensionMatriz.datos,numeroSentencias:resultadoNumeroSentencias.datos}}
};

/**
 * Ejecuta una setencia UPDATE como es especificada en https://www.hackerrank.com/challenges/cube-summation
 * @param comando Comando UPDATE a ejecutar
 * @param dimensionMatriz Dimension de la matriz
 * @param matriz Matriz en la que se almacenan los datos.
 * @return Regresa un objeto de la forma {estado,mensaje} donde
 * - Regresa {estado:'ERROR_VALOR_IDEFENIDO',mensaje:'Valor indefinido'} si el valor del comando es undefined
 * - Regresa {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'} Si el valor del comando es null
 * - Regresa {estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'} Si el valor no es string
 * - Regresa {estado:'ERROR_NO_SE_ENVIA_COMANDO',mensaje:'El valor enviado no tiene comando'} Si el comando tiene una cadena vacia
 * - Regresa {estado:'ERROR_COMANDO_UPDATE_INVALIDO',mensaje:'El comando UPDATE debe ser de la forma UPDATE x y z W pero se envia:[ ...]'} Si el comando tiene una sintaxis invalida
 * - Si un de los valores de las coordenadas o el valor no es numerico entonces regresa el valor de la funcion sumatoriacubo.stringToEntero
 */
sumatoriacubo.LectorPruebas.prototype.ejecutarUpdate = function(comando,dimensionMatriz,matriz)
{
	if(comando === undefined)
	{
		return {estado:'ERROR_VALOR_IDEFENIDO',mensaje:'Valor indefinido'};
	}
	
	if(comando === null)
	{
		return {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
	}
	
	if (typeof comando !== 'string') 
	{
		return {estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
	}
	
	if (comando.trim().length === 0) 
	{
		return {estado:'ERROR_NO_SE_ENVIA_COMANDO',mensaje:'El valor enviado no tiene comando'};
	}
		
	var tokens = comando.split(' ');
	if(tokens.length != 5)
	{
		return {estado:'ERROR_COMANDO_UPDATE_INVALIDO',mensaje:'El comando UPDATE debe ser de la forma UPDATE x y z W pero se envia:[' + comando + ']'};
	}
	
	var x = sumatoriacubo.stringToEntero(tokens[1]);
	var resultadoValidacionX = this.validarEntero(x,'x',1,dimensionMatriz,comando)
	if(resultadoValidacionX)
	{
		return resultadoValidacionX;
	}
	
	var y = sumatoriacubo.stringToEntero(tokens[2]);
	var resultadoValidacionY = this.validarEntero(y,'y',1,dimensionMatriz,comando)
	if(resultadoValidacionY)
	{
		return resultadoValidacionY;
	}
	
	var z = sumatoriacubo.stringToEntero(tokens[3]);
	var resultadoValidacionZ = this.validarEntero(z,'z',1,dimensionMatriz,comando)
	if(resultadoValidacionZ)
	{
		return resultadoValidacionZ;
	}
	
	var valor = sumatoriacubo.stringToEntero( tokens[4] );
	var resultadoValidacionValor = this.validarEntero(valor,'W',-1000000000,1000000000,comando)
	if(resultadoValidacionValor)
	{
		return resultadoValidacionValor;
	}	
	
	matriz.set(x.datos + '|' + y.datos + '|' + z.datos, valor.datos );
	
	return {estado:'EXITO',mensaje:'Operacion exitosa'};
};

/**
 * Valida si el resultado de convertir una cadena a un entero es exitosa y de ser asi valida
 * que el valor este en el rango indicado.
 * @param valor Resultado de llamar a la funcion sumatoriacubo.stringToEntero
 * @param nombre Nombre de la variable. Usado para enviar descipcion del error
 * @param minimo Valor minimo que puede tomar el valor
 * @param maximo Valor maximo que puede tomar el valor
 * @param comando Comando que contiene el valor. Se usa para la drescripcion del error
 */
sumatoriacubo.LectorPruebas.prototype.validarEntero = function(valor,nombre,minimo,maximo,comando)
{
	if( valor.estado === 'EXITO' )
	{
		if ( valor.datos < minimo || valor.datos > maximo )
		{
			return {estado:'ERROR_RANGO_INVALIDO',mensaje:'El valor ' + nombre +' no esta entre ' + minimo + ' y ' + maximo + ' en la sentencia [' + comando + '].'};
		}
	}
	else
	{
		valor.mensajeAdicional = 'El valor ' + nombre +' no es un numero entero valido en la sentencia [' + comando + '].';
		return valor;
	}
};

/**
 * Convierte un string en un entero. Regresa un objeto con la estructura {estado,mensaje,datos}. Si la operacion es
 * exitosa regresa: {estado:'EXITO',mensaje:'Operacion exitosa',datos:valor} donde valor corresponde al valor convertido.
 * En caso de fallar regresa lo siguiente:
 * - Si no se ingresa un valor : {estado:'ERROR_VALOR_IDEFENIDO',mensaje:'Valor indefinido'};
 * - Si se envia null: {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
 * - Si se envia un valor que no es un string: { estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
 * - Si se envia una cadena con valor que no corresponde a un string se regresa:
 *   {estado:'ERROR_VALOR_NO_ENTERO',mensaje:'Valor [' + numeroComoCadena + '] no es entero'} donde numeroComoCadena
 *   corresponde al valor enviado a la funcion.
 */
sumatoriacubo.stringToEntero = function(numeroComoCadena)
{
	if(numeroComoCadena === undefined)
	{
		return {estado:'ERROR_VALOR_IDEFENIDO',mensaje:'Valor indefinido'};
	}
	if(numeroComoCadena === null)
	{
		return {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
	}
	if (typeof numeroComoCadena !== 'string') 
	{
		return { estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
	}
		
	var valor = parseInt(numeroComoCadena);
	if( isNaN(valor) )
	{
		return {estado:'ERROR_VALOR_NO_ENTERO',mensaje:'Valor [' + numeroComoCadena + '] no es entero'};
	}
	else if(new String(valor) != numeroComoCadena.trim() )
	{
		return {estado:'ERROR_VALOR_NO_ENTERO',mensaje:'Valor [' + numeroComoCadena + '] no es entero'};
	}
	else
	{
		return {estado:'EXITO',mensaje:'Operacion exitosa',datos:valor};
	}	
};

})(window.sumatoriacubo || (window.sumatoriacubo = {}));

Node-path: trunk/sumatoria-cubo/WebContent/testsumatoriacubo.js
Node-kind: file
Node-action: change
Text-content-md5: 64d69ac7003820dd67b36d8161f04fba
Text-content-sha1: 3bf073aa04a1c20db8cfdb9716ad643d74057cce
Text-content-length: 13994
Content-length: 13994


(function(sumatoriacubo) {
var sumatoriacubo = sumatoriacubo || {};

describe("Conversion de cadenas a numeros", function() 
{
	describe("Cuando se intentar convertir un valor idefinido o nulo a entero", function() 
	{
		it("Debe indicar que no se ingreso un valor", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero();
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_IDEFENIDO');
		});
		
		it("Debe indicar que se ingreso un valor nulo", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero(null);
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NULO');
		});
	});
	
	describe("Cuando se intenta convertir a entero una cadena con un valor no numerico", function() 
	{
		it("Debe indicar que no se ingreso una cadena con un valor entero para el valor ['1a']", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero('1a');
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que no se ingreso una cadena con un valor entero para el valor ['a1']", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero('a1');
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que no se ingreso una cadena con un valor entero para el valor ['']", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero('');
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que no se ingreso una cadena", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero(1);
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_STRING');
		});
	});
	
	describe("Cuando se intenta convertir una cadena con un valor valido", function() 
	{
		var numero = Math.floor((Math.random() *  Number.MAX_SAFE_INTEGER ) );
		var stringNumero = numero + '';
		it("Debe indicar que la operacion es exitosa y regresar el valor correctamente si se envia el valor ['" + numero + "']", function() 
		{			
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero(stringNumero);
		    expect(resultadoValorIndefinido.estado).toBe('EXITO');
		    expect(resultadoValorIndefinido.datos).toBe(numero);
		});
	});
});
	
describe("Lectura de numero de pruebas", function() 
{
	describe("Cuando el numero de pruebas a leer es invalido", function() 
	{
		it("Debe indicar que el numero de pruebas es invalido si envia texto en lugar de un numero", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas('w').estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que el numero de pruebas es invalido si envia texto vacio", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas('').estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que el numero de pruebas es invalido si envia texto un valor menor a 1", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas('0').estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar que el numero de pruebas es invalido si envia texto un valor mayor a 50", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas('51').estado).toBe('ERROR_RANGO_INVALIDO');
		});		
		
		var numero = Math.floor((Math.random() *  50 ) + 1 );
		var stringNumero = numero + '';
		it("Debe indicar que el numero de pruebas es valido si envia texto un valor [" + stringNumero +"] el cual esta entre 1 y 50", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas(stringNumero).estado).toBe('EXITO');
		});
	});
});	

describe("Lectura de dimension matriz y numero de sentencias", function() 
{
	describe("Cuando el valor con la dimension matriz y numero de sentencias es indefinido, nulo, no es una cadena o se una valor", function() 
	{
		it("Debe indicar error si no se define un valor para la dimension y el numero de sentencias", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias().estado).toBe('ERROR_VALOR_IDEFENIDO');
		});
		
		it("Debe indicar error si es nulo el valor para la dimension y el numero de sentencias", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias(null).estado).toBe('ERROR_VALOR_NULO');
		});
		
		it("Debe indicar error si el valor no es un string para la dimension y el numero de sentencias", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias(1).estado).toBe('ERROR_VALOR_NO_STRING');
		});
		
		it("Debe indicar error si el valor es un string vacio", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('').estado).toBe('ERROR_DIMENSION_MATRIZ_SENTENCIA');
		});

		it("Debe indicar error si solo se envia un valor", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('1').estado).toBe('ERROR_DIMENSION_MATRIZ_SENTENCIA');
		});
	});
	
	describe("Cuando el texto con la dimension de la matriz no es valido", function() 
	{
		it("Debe indicar que la dimension de la matriz es invalido si envia texto en lugar de un numero", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('n 3').estado).toBe('ERROR_VALOR_NO_ENTERO');
		});		
		
		var dimensionMenor = - Math.floor((Math.random() *  100 ) + 1 );
		var stringDimensionMenor = dimensionMenor + '';
		it("Debe indicar que la dimension de la matriz es invalida si el valor ["+ dimensionMenor +"] es menor es 1", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias(stringDimensionMenor + ' 3').estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		var dimensionMayor = 100 + Math.floor((Math.random() *  100 ) + 1 );
		var stringDimensionMayor = dimensionMayor + '';
		it("Debe indicar que la dimension de la matriz es invalida si el valor ["+ dimensionMayor +"] es mayor es 100", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias(stringDimensionMayor + ' 3').estado).toBe('ERROR_RANGO_INVALIDO');
		});		
	});
	
	describe("Cuando el texto con el numero de sentencias de la prueba no es valido", function() 
	{
		it("Debe indicar que la dimension de la matriz es invalido si envia texto en lugar de un numero", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('3 a').estado).toBe('ERROR_VALOR_NO_ENTERO');
		});		
		
		var sentenciasMenor = - Math.floor((Math.random() *  1000 ) + 1 );
		var stringSentenciasMenor = sentenciasMenor + '';
		it("Debe indicar que el numero de setencias es invalido si el valor ["+ sentenciasMenor +"] es menor es 1", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('3 ' + stringSentenciasMenor).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		var sentenciasMayor = 1000 + Math.floor((Math.random() *  1000 ) + 1 );
		var stringSentenciasMayor = sentenciasMayor + '';
		it("Debe indicar que el numero de setencias es invalido si el valor ["+ sentenciasMayor +"] es mayor es 1000", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('3 ' + stringSentenciasMayor).estado).toBe('ERROR_RANGO_INVALIDO');
		});		
	});
	
	describe("Cuando el texto con el la dimension de la matriz y el numero de sentencias es valido", function() 
	{
		var dimensionValida = Math.floor((Math.random() *  100 ) + 1 );
		var stringDimensionValida = dimensionValida + '';
		
		var sentenciaValida = Math.floor((Math.random() *  1000 ) + 1 );
		var stringSentenciaValida = sentenciaValida + '';
		it("Debe indicar que la dimension de la matriz y el numero de sentencias es valido para el valor ["+ stringDimensionValida + ' ' + sentenciaValida +"]", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias(stringDimensionValida + ' ' + stringSentenciaValida).estado).toBe('EXITO');
		});
	});	
});

describe("Ejecucion comando UPDATE", function() 
{
	describe("Cuando se intenta ejecutar un UPDATE pero el valor es indefinido, nulo, no es una cadena o se envia una cadena vacia", function() 
	{
		it("Debe indicar que se envio un valor indefinido", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate(undefined,100,matriz).estado).toBe('ERROR_VALOR_IDEFENIDO');
		});
		it("Debe indicar que se envio un valor nulo", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate(null,100,matriz).estado).toBe('ERROR_VALOR_NULO');
		});
		it("Debe indicar que se envio un valor no string", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate(1,100,matriz).estado).toBe('ERROR_VALOR_NO_STRING');
		});
		it("Debe indicar que se envio un valor vacio", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('',100,matriz).estado).toBe('ERROR_NO_SE_ENVIA_COMANDO');
		});	
	});
	
	describe("Cuando se intenta ejecutar un UPDATE con datos invalidos", function() 
	{
		it("Debe indicar que la coordenada x no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE x 1 2 5',100,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar que la coordenada x supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 3 1 1 5',1,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar que la coordenada y no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 y 2 5',100,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar que la coordenada y supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 3 1 5',1,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar que la coordenada z no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 1 z 5',100,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar que la coordenada z supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 1 3 5',1,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
	});
		
	describe("Cuando se intenta ejecutar un UPDATE con menos o mas parametros", function() 
	{
		it("Debe indicar que UPDATE es invalido al no enviar las coordenadas ni el valor en el comando", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE',100,matriz).estado).toBe('ERROR_COMANDO_UPDATE_INVALIDO');
		});
		
		it("Debe indicar que UPDATE es invalido cuando solo se envia una coordenada", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1',100,matriz).estado).toBe('ERROR_COMANDO_UPDATE_INVALIDO');
		});
		
		it("Debe indicar que UPDATE es invalido cuando solo se envia dos coordenadas", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 2',100,matriz).estado).toBe('ERROR_COMANDO_UPDATE_INVALIDO');
		});
		
		it("Debe indicar que UPDATE es invalido cuando solo se envia tres coordenadas", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 2 3',100,matriz).estado).toBe('ERROR_COMANDO_UPDATE_INVALIDO');
		});
		
		it("Debe indicar que UPDATE es invalido cuando solo se envia mas parametros", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 2 3 5 2',100,matriz).estado).toBe('ERROR_COMANDO_UPDATE_INVALIDO');
		});
	});
	
	describe("Cuando se ejecuta un UPDATE con datos validos", function() 
	{
		it("Debe quedar almacenado en la matriz el valor enviado en el comando", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 2 3 4',100,matriz).estado).toBe('EXITO');
		    expect(matriz.get('1|2|3')).toBe(4);
		});
	});
});

})(window.sumatoriacubo || (window.sumatoriacubo = {}));

Revision-number: 14
Prop-content-length: 207
Content-length: 207

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-29T01:07:53.728000Z
K 7
svn:log
V 105
- Se agrega codigo que ejecuta la sentencia QUERY
- Se agregan pruebas de ejecucion de la sentencia QUERY
PROPS-END

Node-path: trunk/sumatoria-cubo/WebContent/sumatoriacubo.js
Node-kind: file
Node-action: change
Text-content-md5: 5d316228ba11dd10cc4d3558cb8016d4
Text-content-sha1: 628bbd83d7d89585ce8880fabb371a061e30d1fe
Text-content-length: 16439
Content-length: 16439


(function(sumatoriacubo) {
var sumatoriacubo = sumatoriacubo || {};

sumatoriacubo.procesar = function()
{
	document.getElementById('MensajeResultado').innerHTML = '';	
	var resultado = sumatoriacubo.procesarUsandoClase();
	if( resultado.estado === 'EXITO' )
	{
		document.getElementById('Resultado').value = resultado.datos;
	}
	else
	{
		var mensaje;
		if(resultado.mensajeAdicional)
		{
			mensaje = resultado.mensajeAdicional + ' ' + resultado.mensaje;
		}
		else
		{
			mensaje =  resultado.mensaje;
		}
		document.getElementById('MensajeResultado').innerHTML = mensaje;
		document.getElementById('Resultado').value = '';
	}
};

sumatoriacubo.procesarUsandoClase = function()
{
	var cadenaResultado = ''; 
	var lineaActual = 0;
	
	var comandos = document.getElementById('Comandos').value.trim();	
	var lectorPruebas = new sumatoriacubo.LectorPruebas(comandos);
	
	var comandosComoLineas = comandos.split('\n');
		
	var resultadosNumeroPruebas = lectorPruebas.leerNumeroPruebas( comandosComoLineas[lineaActual++] );
	if(resultadosNumeroPruebas.estado !== 'EXITO')
	{
		return resultadosNumeroPruebas;
	}	
	var numeroPruebas = resultadosNumeroPruebas.datos;
	
	for(var i = 0; i < numeroPruebas ; i++)
	{
		var resultadosLecturaDimensionMatrizSentencias = lectorPruebas.leerDimensionMatrizSentencias(comandosComoLineas[lineaActual++]);
		if(resultadosLecturaDimensionMatrizSentencias.estado !== 'EXITO')
		{
			return resultadosLecturaDimensionMatrizSentencias;
		}
		
		var dimensionMatriz = resultadosLecturaDimensionMatrizSentencias.datos.dimensionMatriz;
		var numeroSentencias = resultadosLecturaDimensionMatrizSentencias.datos.numeroSentencias;
		var matriz = new Map();
		
		for(var j = 0; j < numeroSentencias ;  j++)
		{
			var comando = comandosComoLineas[lineaActual++].trim();
			if( comando.substring(0,6) === 'UPDATE' )
			{
				var resultadoUpdate = lectorPruebas.ejecutarUpdate(comando,dimensionMatriz,matriz);
				if(resultadoUpdate.estado !== 'EXITO')
				{
					return resultadoUpdate;
				}
			}
			else if( comando.substring(0,5) === 'QUERY' )
			{
				var resultadoQuery = lectorPruebas.ejecutarQuery(comando,dimensionMatriz,matriz);
				if(resultadoQuery.estado !== 'EXITO')
				{
					return resultadoQuery;
				}
				cadenaResultado += resultadoQuery.datos + '\n';
			}
		}		
	}
	
	return { estado:'EXITO',mensaje:'Operacion exitosa', datos:cadenaResultado};
};

/**
 * Clase que procesa las pruebas.
 * @param comandos Texto con los comandos a procesar.
 */
sumatoriacubo.LectorPruebas = function(comandos)
{
	this.comandos = comandos;
};

/**
 * Metodo que lee el numero de pruebas de una cadena de texto.
 * @param comando Cadena con el numero de pruebas
 * @return Regresa un objeto con el resultado de la prueba. El objeto tiene la estructura {estado,mensaje,datos}.
 * Si el valor no es numerico regresa un objeto con la estructura regresada por la funcion sumatoriacubo.stringToEntero,
 * Si el valor no esta en el rango entre 1 y 50 regresa en el estado el valor 'ERROR_RANGO_INVALIDO'
 */
sumatoriacubo.LectorPruebas.prototype.leerNumeroPruebas = function(comando)
{
	var resultado = sumatoriacubo.stringToEntero(comando);
	if( resultado.estado === 'EXITO' )
	{
		if ( resultado.datos < 1 || resultado.datos > 50 )
		{
			return {estado:'ERROR_RANGO_INVALIDO',mensaje:'El numero de pruebas no esta entre 1 y 50.'};
		}		
		return resultado;
	}
	else
	{
		resultado.mensajeAdicional = 'El numero de pruebas no es un numero entero valido.';
		return resultado;
	}	
};

/**
 * Lee la dimension de la matriz y el numero de sentencias de la prueba.
 * @param comando Cadena con el texto
 * @return Regresa un objeto con la estructura {estado,mensaje, datos:{dimensionMatriz,numeroSentencias}}.
 * - Si alguno de los valores no es numerico regresa un objeto con la estructura que se indica del metodo sumatoriacubo.stringToEntero
 * - Si la cadena enviada a la funcion no contiene dos valores, entonces se regresa estado = 'ERROR_DIMENSION_MATRIZ_SENTENCIA'
 * - Si la dimension de la matriz no esta en el rango entre 1 y 100 regresa estado = 'ERROR_RANGO_INVALIDO'
 * - Si el numero de sentencias no esta en el rango entre 1 y 1000 regresa estado =  'ERROR_RANGO_INVALIDO'
 * - Si no se define valor se regresa estado = 'ERROR_VALOR_IDEFENIDO'
 * - Si el valor es nulo regresa estado = 'ERROR_VALOR_NULO'
 * - Si el valor no es string regresa estado = 'ERROR_VALOR_NO_STRING'
 */
sumatoriacubo.LectorPruebas.prototype.leerDimensionMatrizSentencias = function(comando)
{
	if(comando === undefined)
	{
		return {estado:'ERROR_VALOR_IDEFENIDO',mensaje:'Valor indefinido'};
	}
	if(comando === null)
	{
		return {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
	}
	if (typeof comando !== 'string') 
	{
		return { estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
	}	
	
	var dimesionMatrizSentencias = comando.trim().split(' ');
	if( dimesionMatrizSentencias.length != 2 )
	{
		return {estado:'ERROR_DIMENSION_MATRIZ_SENTENCIA',mensaje:'El valor [' + comando +'] no contiene un valor valido con la dimension de la matriz y el numero de sentencias.'};
	}
	
	// Procesar el valor con la dimension de la matriz
	var resultadoDimensionMatriz = sumatoriacubo.stringToEntero( dimesionMatrizSentencias[0] );
	if( resultadoDimensionMatriz.estado === 'EXITO' )
	{
		if ( resultadoDimensionMatriz.datos < 1 || resultadoDimensionMatriz.datos > 100 )
		{
			return {estado:'ERROR_RANGO_INVALIDO',mensaje:'La dimension de la matriz no esta entre 1 y 100.'};
		}
	}
	else
	{
		resultadoDimensionMatriz.mensajeAdicional = 'La dimension de la matriz no es un numero entero valido.';
		return resultadoDimensionMatriz;
	}
	
	// Procesar el valor con el numero de sentencias
	var resultadoNumeroSentencias =  sumatoriacubo.stringToEntero( dimesionMatrizSentencias[1] );
	if( resultadoNumeroSentencias.estado === 'EXITO' )
	{
		if ( resultadoNumeroSentencias.datos < 1 || resultadoNumeroSentencias.datos > 1000 )
		{
			return {estado:'ERROR_RANGO_INVALIDO',mensaje:'El numero de sentencias no esta entre 1 y 1000.'};
		}
	}
	else
	{
		resultadoNumeroSentencias.mensajeAdicional = 'El numero de sentencias no es un numero entero valido.';
		return resultadoNumeroSentencias;
	}	
	
	// Regresar los datos si estos son validos
	return {estado:'EXITO',mensaje:'Operacion exitosa', datos:{dimensionMatriz:resultadoDimensionMatriz.datos,numeroSentencias:resultadoNumeroSentencias.datos}}
};

/**
 * Ejecuta una setencia UPDATE como es especificada en https://www.hackerrank.com/challenges/cube-summation
 * @param comando Comando UPDATE a ejecutar
 * @param dimensionMatriz Dimension de la matriz
 * @param matriz Matriz en la que se almacenan los datos.
 * @return Regresa un objeto de la forma {estado,mensaje} donde
 * - Regresa {estado:'ERROR_VALOR_IDEFENIDO',mensaje:'Valor indefinido'} si el valor del comando es undefined
 * - Regresa {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'} Si el valor del comando es null
 * - Regresa {estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'} Si el valor no es string
 * - Regresa {estado:'ERROR_NO_SE_ENVIA_COMANDO',mensaje:'El valor enviado no tiene comando'} Si el comando tiene una cadena vacia
 * - Regresa {estado:'ERROR_COMANDO_UPDATE_INVALIDO',mensaje:'El comando UPDATE debe ser de la forma UPDATE x y z W pero se envia:[ ...]'} Si el comando tiene una sintaxis invalida
 * - Si un de los valores de las coordenadas o el valor no es numerico entonces regresa el valor de la funcion sumatoriacubo.stringToEntero
 */
sumatoriacubo.LectorPruebas.prototype.ejecutarUpdate = function(comando,dimensionMatriz,matriz)
{
	if(comando === undefined)
	{
		return {estado:'ERROR_VALOR_IDEFENIDO',mensaje:'Valor indefinido'};
	}
	
	if(comando === null)
	{
		return {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
	}
	
	if (typeof comando !== 'string') 
	{
		return {estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
	}
	
	if (comando.trim().length === 0) 
	{
		return {estado:'ERROR_NO_SE_ENVIA_COMANDO',mensaje:'El valor enviado no tiene comando'};
	}
		
	var tokens = comando.split(' ');
	if(tokens.length != 5)
	{
		return {estado:'ERROR_COMANDO_UPDATE_INVALIDO',mensaje:'El comando UPDATE debe ser de la forma UPDATE x y z W pero se envia:[' + comando + ']'};
	}
	
	var x = sumatoriacubo.stringToEntero(tokens[1]);
	var resultadoValidacionX = this.validarEntero(x,'x',1,dimensionMatriz,comando)
	if(resultadoValidacionX)
	{
		return resultadoValidacionX;
	}
	
	var y = sumatoriacubo.stringToEntero(tokens[2]);
	var resultadoValidacionY = this.validarEntero(y,'y',1,dimensionMatriz,comando)
	if(resultadoValidacionY)
	{
		return resultadoValidacionY;
	}
	
	var z = sumatoriacubo.stringToEntero(tokens[3]);
	var resultadoValidacionZ = this.validarEntero(z,'z',1,dimensionMatriz,comando)
	if(resultadoValidacionZ)
	{
		return resultadoValidacionZ;
	}
	
	var valor = sumatoriacubo.stringToEntero( tokens[4] );
	var resultadoValidacionValor = this.validarEntero(valor,'W',-1000000000,1000000000,comando)
	if(resultadoValidacionValor)
	{
		return resultadoValidacionValor;
	}	
	
	matriz.set(x.datos + '|' + y.datos + '|' + z.datos, valor.datos );
	
	return {estado:'EXITO',mensaje:'Operacion exitosa'};
};

/**
 * Ejecuta una sentencia QUERY como es especificada en https://www.hackerrank.com/challenges/cube-summation
 * @param comando Cadena con la sentencia QUERY
 * @param dimensionMatriz Dimension de la matriz con los datos.
 * @param matriz Corresponde a un Map donde la llave es una cadena de la forma x|y|z.
 * @return Regresa un objeto de la forma {estado,mensaje,datos} donde 
 * - Regresa {estado:'ERROR_VALOR_IDEFENIDO',mensaje:'Valor indefinido'} si se envia indefinido como comando
 * - Regresa {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'} Si envia un valor nulo
 * - Regresa {estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'} Si el valor no es string
 * - Regresa {estado:'ERROR_NO_SE_ENVIA_COMANDO',mensaje:'El valor enviado no tiene comando'} Si no se envia comando
 * - Regresa {estado:'ERROR_COMANDO_QUERY_INVALIDO',mensaje:'El comando QUERY debe ser de la forma UPDATE x1 y1 z1 x2 y2 z2 pero se envia:[' + comando + ']'} si el comando no tiene sintaxis valida
 * - Regresa {estado:'ERROR_X1_MAYOR_X2',mensaje:'El valor del x1 es mayor a x2 en la sentencia ' + comando} si x1 > x2
 * - Regresa {estado:'ERROR_Y1_MAYOR_Y2',mensaje:'El valor del y1 es mayor a y2 en la sentencia ' + comando} Si y1 > y2
 * - Regresa {estado:'ERROR_Z1_MAYOR_Z2',mensaje:'El valor del z1 es mayor a z2 en la sentencia ' + comando} Si z1 > z2
 * - Regresa {estado:'EXITO',datos:suma} Si se ejecuta correctamente el comando
 */
sumatoriacubo.LectorPruebas.prototype.ejecutarQuery = function(comando,dimensionMatriz,matriz)
{
	if(comando === undefined)
	{
		return {estado:'ERROR_VALOR_IDEFENIDO',mensaje:'Valor indefinido'};
	}
	
	if(comando === null)
	{
		return {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
	}
	
	if (typeof comando !== 'string') 
	{
		return {estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
	}
	
	if (comando.trim().length === 0) 
	{
		return {estado:'ERROR_NO_SE_ENVIA_COMANDO',mensaje:'El valor enviado no tiene comando'};
	}
	
	var tokens = comando.split(' ');
	if(tokens.length != 7 )
	{
		return {estado:'ERROR_COMANDO_QUERY_INVALIDO',mensaje:'El comando QUERY debe ser de la forma UPDATE x1 y1 z1 x2 y2 z2 pero se envia:[' + comando + ']'};
	}
	
	var resultadox1 = sumatoriacubo.stringToEntero(tokens[1]);
	var resultadoValidacionX1 = this.validarEntero(resultadox1,'x1',1,dimensionMatriz,comando);
	if(resultadoValidacionX1)
	{
		return resultadoValidacionX1;
	}
	
	var resultadoy1 = sumatoriacubo.stringToEntero(tokens[2]);
	var resultadoValidacionY1 = this.validarEntero(resultadoy1,'y1',1,dimensionMatriz,comando);
	if(resultadoValidacionY1)
	{
		return resultadoValidacionY1;
	}
	
	var resultadoz1 = sumatoriacubo.stringToEntero(tokens[3]);
	var resultadoValidacionZ1 = this.validarEntero(resultadoz1,'z1',1,dimensionMatriz,comando);
	if(resultadoValidacionZ1)
	{
		return resultadoValidacionZ1;
	}
	
	var resultadox2 = sumatoriacubo.stringToEntero(tokens[4]);
	var resultadoValidacionX2 = this.validarEntero(resultadox2,'x2',1,dimensionMatriz,comando);
	if(resultadoValidacionX2)
	{
		return resultadoValidacionX2;
	}	
	
	var resultadoy2 = sumatoriacubo.stringToEntero(tokens[5]);
	var resultadoValidacionY2 = this.validarEntero(resultadoy2,'y2',1,dimensionMatriz,comando);
	if(resultadoValidacionY2)
	{
		return resultadoValidacionY2;
	}
	
	var resultadoz2 = sumatoriacubo.stringToEntero(tokens[6]);
	var resultadoValidacionZ2 = this.validarEntero(resultadoz2,'z2',1,dimensionMatriz,comando);
	if(resultadoValidacionZ2)
	{
		return resultadoValidacionZ2;
	}
	
	var x1 = resultadox1.datos;
	var y1 = resultadoy1.datos;
	var z1 = resultadoz1.datos;
	var x2 = resultadoz2.datos;
	var y2 = resultadoy2.datos;
	var z2 = resultadoz2.datos;
	
	if( x1 > x2 )
	{
		return {estado:'ERROR_X1_MAYOR_X2',mensaje:'El valor del x1 es mayor a x2 en la sentencia ' + comando};
	}
	
	if( y1 > y2 )
	{
		return {estado:'ERROR_Y1_MAYOR_Y2',mensaje:'El valor del y1 es mayor a y2 en la sentencia ' + comando};
	}
	
	if( z1 > z2 )
	{
		return {estado:'ERROR_Z1_MAYOR_Z2',mensaje:'El valor del z1 es mayor a z2 en la sentencia ' + comando};
	}
	
	var suma = 0;
	for (var [key, value] of matriz) 
	{
		var keyTokens = key.split('|');
		var x = parseInt(keyTokens[0]);
		var y = parseInt(keyTokens[1]);
		var z = parseInt(keyTokens[2]);
		
		if ( (x >= x1 && x <= x2) && (y >= y1 && y <= y2) && (z >= z1 && z <= z2) )
		{
			suma += value;
		}
	}
	
	return {estado:'EXITO',datos:suma};
}

/**
 * Valida si el resultado de convertir una cadena a un entero es exitosa y de ser asi valida
 * que el valor este en el rango indicado.
 * @param valor Resultado de llamar a la funcion sumatoriacubo.stringToEntero
 * @param nombre Nombre de la variable. Usado para enviar descipcion del error
 * @param minimo Valor minimo que puede tomar el valor
 * @param maximo Valor maximo que puede tomar el valor
 * @param comando Comando que contiene el valor. Se usa para la drescripcion del error
 */
sumatoriacubo.LectorPruebas.prototype.validarEntero = function(valor,nombre,minimo,maximo,comando)
{
	if( valor.estado === 'EXITO' )
	{
		if ( valor.datos < minimo || valor.datos > maximo )
		{
			return {estado:'ERROR_RANGO_INVALIDO',mensaje:'El valor ' + nombre +' no esta entre ' + minimo + ' y ' + maximo + ' en la sentencia [' + comando + '].'};
		}
	}
	else
	{
		valor.mensajeAdicional = 'El valor ' + nombre +' no es un numero entero valido en la sentencia [' + comando + '].';
		return valor;
	}
};

/**
 * Convierte un string en un entero. Regresa un objeto con la estructura {estado,mensaje,datos}. Si la operacion es
 * exitosa regresa: {estado:'EXITO',mensaje:'Operacion exitosa',datos:valor} donde valor corresponde al valor convertido.
 * En caso de fallar regresa lo siguiente:
 * - Si no se ingresa un valor : {estado:'ERROR_VALOR_IDEFENIDO',mensaje:'Valor indefinido'};
 * - Si se envia null: {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
 * - Si se envia un valor que no es un string: { estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
 * - Si se envia una cadena con valor que no corresponde a un string se regresa:
 *   {estado:'ERROR_VALOR_NO_ENTERO',mensaje:'Valor [' + numeroComoCadena + '] no es entero'} donde numeroComoCadena
 *   corresponde al valor enviado a la funcion.
 */
sumatoriacubo.stringToEntero = function(numeroComoCadena)
{
	if(numeroComoCadena === undefined)
	{
		return {estado:'ERROR_VALOR_IDEFENIDO',mensaje:'Valor indefinido'};
	}
	if(numeroComoCadena === null)
	{
		return {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
	}
	if (typeof numeroComoCadena !== 'string') 
	{
		return { estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
	}
		
	var valor = parseInt(numeroComoCadena);
	if( isNaN(valor) )
	{
		return {estado:'ERROR_VALOR_NO_ENTERO',mensaje:'Valor [' + numeroComoCadena + '] no es entero'};
	}
	else if(new String(valor) != numeroComoCadena.trim() )
	{
		return {estado:'ERROR_VALOR_NO_ENTERO',mensaje:'Valor [' + numeroComoCadena + '] no es entero'};
	}
	else
	{
		return {estado:'EXITO',mensaje:'Operacion exitosa',datos:valor};
	}	
};

})(window.sumatoriacubo || (window.sumatoriacubo = {}));

Node-path: trunk/sumatoria-cubo/WebContent/testsumatoriacubo.js
Node-kind: file
Node-action: change
Text-content-md5: bfd14752e2ffcad14163d151b5b7a591
Text-content-sha1: 5bf08c17f7933f147981c3a936285e40e296e56c
Text-content-length: 22784
Content-length: 22784


(function(sumatoriacubo) {
var sumatoriacubo = sumatoriacubo || {};

describe("Conversion de cadenas a numeros", function() 
{
	describe("Cuando se intentar convertir un valor idefinido o nulo a entero", function() 
	{
		it("Debe indicar que no se ingreso un valor", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero();
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_IDEFENIDO');
		});
		
		it("Debe indicar que se ingreso un valor nulo", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero(null);
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NULO');
		});
	});
	
	describe("Cuando se intenta convertir a entero una cadena con un valor no numerico", function() 
	{
		it("Debe indicar que no se ingreso una cadena con un valor entero para el valor ['1a']", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero('1a');
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que no se ingreso una cadena con un valor entero para el valor ['a1']", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero('a1');
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que no se ingreso una cadena con un valor entero para el valor ['']", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero('');
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que no se ingreso una cadena", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero(1);
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_STRING');
		});
	});
	
	describe("Cuando se intenta convertir una cadena con un valor valido", function() 
	{
		var numero = Math.floor((Math.random() *  Number.MAX_SAFE_INTEGER ) );
		var stringNumero = numero + '';
		it("Debe indicar que la operacion es exitosa y regresar el valor correctamente si se envia el valor ['" + numero + "']", function() 
		{			
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero(stringNumero);
		    expect(resultadoValorIndefinido.estado).toBe('EXITO');
		    expect(resultadoValorIndefinido.datos).toBe(numero);
		});
	});
});
	
describe("Lectura de numero de pruebas", function() 
{
	describe("Cuando el numero de pruebas a leer es invalido", function() 
	{
		it("Debe indicar que el numero de pruebas es invalido si envia texto en lugar de un numero", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas('w').estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que el numero de pruebas es invalido si envia texto vacio", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas('').estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que el numero de pruebas es invalido si envia texto un valor menor a 1", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas('0').estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar que el numero de pruebas es invalido si envia texto un valor mayor a 50", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas('51').estado).toBe('ERROR_RANGO_INVALIDO');
		});		
		
		var numero = Math.floor((Math.random() *  50 ) + 1 );
		var stringNumero = numero + '';
		it("Debe indicar que el numero de pruebas es valido si envia texto un valor [" + stringNumero +"] el cual esta entre 1 y 50", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas(stringNumero).estado).toBe('EXITO');
		});
	});
});	

describe("Lectura de dimension matriz y numero de sentencias", function() 
{
	describe("Cuando el valor con la dimension matriz y numero de sentencias es indefinido, nulo, no es una cadena o se una valor", function() 
	{
		it("Debe indicar error si no se define un valor para la dimension y el numero de sentencias", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias().estado).toBe('ERROR_VALOR_IDEFENIDO');
		});
		
		it("Debe indicar error si es nulo el valor para la dimension y el numero de sentencias", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias(null).estado).toBe('ERROR_VALOR_NULO');
		});
		
		it("Debe indicar error si el valor no es un string para la dimension y el numero de sentencias", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias(1).estado).toBe('ERROR_VALOR_NO_STRING');
		});
		
		it("Debe indicar error si el valor es un string vacio", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('').estado).toBe('ERROR_DIMENSION_MATRIZ_SENTENCIA');
		});

		it("Debe indicar error si solo se envia un valor", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('1').estado).toBe('ERROR_DIMENSION_MATRIZ_SENTENCIA');
		});
	});
	
	describe("Cuando el texto con la dimension de la matriz no es valido", function() 
	{
		it("Debe indicar que la dimension de la matriz es invalido si envia texto en lugar de un numero", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('n 3').estado).toBe('ERROR_VALOR_NO_ENTERO');
		});		
		
		var dimensionMenor = - Math.floor((Math.random() *  100 ) + 1 );
		var stringDimensionMenor = dimensionMenor + '';
		it("Debe indicar que la dimension de la matriz es invalida si el valor ["+ dimensionMenor +"] es menor es 1", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias(stringDimensionMenor + ' 3').estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		var dimensionMayor = 100 + Math.floor((Math.random() *  100 ) + 1 );
		var stringDimensionMayor = dimensionMayor + '';
		it("Debe indicar que la dimension de la matriz es invalida si el valor ["+ dimensionMayor +"] es mayor es 100", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias(stringDimensionMayor + ' 3').estado).toBe('ERROR_RANGO_INVALIDO');
		});		
	});
	
	describe("Cuando el texto con el numero de sentencias de la prueba no es valido", function() 
	{
		it("Debe indicar que la dimension de la matriz es invalido si envia texto en lugar de un numero", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('3 a').estado).toBe('ERROR_VALOR_NO_ENTERO');
		});		
		
		var sentenciasMenor = - Math.floor((Math.random() *  1000 ) + 1 );
		var stringSentenciasMenor = sentenciasMenor + '';
		it("Debe indicar que el numero de setencias es invalido si el valor ["+ sentenciasMenor +"] es menor es 1", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('3 ' + stringSentenciasMenor).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		var sentenciasMayor = 1000 + Math.floor((Math.random() *  1000 ) + 1 );
		var stringSentenciasMayor = sentenciasMayor + '';
		it("Debe indicar que el numero de setencias es invalido si el valor ["+ sentenciasMayor +"] es mayor es 1000", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('3 ' + stringSentenciasMayor).estado).toBe('ERROR_RANGO_INVALIDO');
		});		
	});
	
	describe("Cuando el texto con el la dimension de la matriz y el numero de sentencias es valido", function() 
	{
		var dimensionValida = Math.floor((Math.random() *  100 ) + 1 );
		var stringDimensionValida = dimensionValida + '';
		
		var sentenciaValida = Math.floor((Math.random() *  1000 ) + 1 );
		var stringSentenciaValida = sentenciaValida + '';
		it("Debe indicar que la dimension de la matriz y el numero de sentencias es valido para el valor ["+ stringDimensionValida + ' ' + sentenciaValida +"]", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias(stringDimensionValida + ' ' + stringSentenciaValida).estado).toBe('EXITO');
		});
	});	
});

describe("Ejecucion comando UPDATE", function() 
{
	describe("Cuando se intenta ejecutar un UPDATE pero el valor es indefinido, nulo, no es una cadena o se envia una cadena vacia", function() 
	{
		it("Debe indicar que se envio un valor indefinido", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate(undefined,100,matriz).estado).toBe('ERROR_VALOR_IDEFENIDO');
		});
		it("Debe indicar que se envio un valor nulo", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate(null,100,matriz).estado).toBe('ERROR_VALOR_NULO');
		});
		it("Debe indicar que se envio un valor no string", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate(1,100,matriz).estado).toBe('ERROR_VALOR_NO_STRING');
		});
		it("Debe indicar que se envio un valor vacio", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('',100,matriz).estado).toBe('ERROR_NO_SE_ENVIA_COMANDO');
		});	
	});
	
	describe("Cuando se intenta ejecutar un UPDATE con datos invalidos", function() 
	{
		it("Debe indicar que la coordenada x no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE x 1 2 5',100,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar que la coordenada x supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 3 1 1 5',1,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar que la coordenada y no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 y 2 5',100,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar que la coordenada y supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 3 1 5',1,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar que la coordenada z no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 1 z 5',100,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar que la coordenada z supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 1 3 5',1,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
	});
		
	describe("Cuando se intenta ejecutar un UPDATE con menos o mas parametros", function() 
	{
		it("Debe indicar que UPDATE es invalido al no enviar las coordenadas ni el valor en el comando", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE',100,matriz).estado).toBe('ERROR_COMANDO_UPDATE_INVALIDO');
		});
		
		it("Debe indicar que UPDATE es invalido cuando solo se envia una coordenada", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1',100,matriz).estado).toBe('ERROR_COMANDO_UPDATE_INVALIDO');
		});
		
		it("Debe indicar que UPDATE es invalido cuando solo se envia dos coordenadas", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 2',100,matriz).estado).toBe('ERROR_COMANDO_UPDATE_INVALIDO');
		});
		
		it("Debe indicar que UPDATE es invalido cuando solo se envia tres coordenadas", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 2 3',100,matriz).estado).toBe('ERROR_COMANDO_UPDATE_INVALIDO');
		});
		
		it("Debe indicar que UPDATE es invalido cuando solo se envia mas parametros", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 2 3 5 2',100,matriz).estado).toBe('ERROR_COMANDO_UPDATE_INVALIDO');
		});
	});
	
	describe("Cuando se ejecuta un UPDATE con datos validos", function() 
	{
		it("Debe quedar almacenado en la matriz el valor enviado en el comando", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 2 3 4',100,matriz).estado).toBe('EXITO');
		    expect(matriz.get('1|2|3')).toBe(4);
		});
	});
});


describe("Ejecucion comando QUERY", function() 
{
	describe("Cuando se ejecuta un QUERY con datos invalidos", function() 
	{
		it("Debe indicar error si no se envia un indefinido", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery(undefined,5,matriz).estado).toBe('ERROR_VALOR_IDEFENIDO');
		});
		
		it("Debe indicar error si se envia un valor nulo", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery(null,5,matriz).estado).toBe('ERROR_VALOR_NULO');
		});
		
		it("Debe indicar error si se envia un valor no string", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery(1,5,matriz).estado).toBe('ERROR_VALOR_NO_STRING');
		});
		
		it("Debe indicar error si se envia un valor vacio", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery(' ',5,matriz).estado).toBe('ERROR_NO_SE_ENVIA_COMANDO');
		});
		
		it("Debe indicar error si se envian menos datos de los que espera el comando QUERY", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 2 2 2 2',5,matriz).estado).toBe('ERROR_COMANDO_QUERY_INVALIDO');
		});
		
		it("Debe indicar error si la coordenada x1 no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY a 2 2 2 2 2',5,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar error si la coordenada x1 supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 6 2 2 2 2 2',5,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar error si la coordenada y1 no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 2 a 2 2 2 2',5,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar error si la coordenada y1 supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 6 2 2 2 2',5,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar error si la coordenada z1 no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 2 2 q 2 2 2',5,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar error si la coordenada z1 supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 1 6 2 2 2',5,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar error si la coordenada x2 no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 2 2 2 a 2 2',5,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar error si la coordenada x2 supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 2 2 6 2 2',5,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar error si la coordenada y2 no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 2 2 2 2 a 2',5,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar error si la coordenada y2 supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 1 2 2 6 2',5,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar error si la coordenada z2 no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 2 2 1 2 2 a',5,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar error si la coordenada z2 supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 1 1 2 2 6',5,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		
		it("Debe indicar error si la coordenada x1 es mayor x2", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 2 1 1 1 2 1',5,matriz).estado).toBe('ERROR_X1_MAYOR_X2');
		});
		it("Debe indicar error si la coordenada y1 es mayor y2", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 2 1 1 1 1',5,matriz).estado).toBe('ERROR_Y1_MAYOR_Y2');
		});
		it("Debe indicar error si la coordenada z1 es mayor z2", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 1 2 1 1 1',5,matriz).estado).toBe('ERROR_Z1_MAYOR_Z2');
		});
	});
		
	describe("Cuando se intenta ejecutar un QUERY con menos o mas parametros", function() 
	{
		it("Debe indicar error si se envian mas datos de los que espera el comando QUERY", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 2 2 2 2 2 1',5,matriz).estado).toBe('ERROR_COMANDO_QUERY_INVALIDO');
		});
		
		it("Debe indicar error si se envian solo una coordenada al comando QUERY", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1',5,matriz).estado).toBe('ERROR_COMANDO_QUERY_INVALIDO');
		});
		it("Debe indicar error si se envian dos coordenadas al comando QUERY", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 2',5,matriz).estado).toBe('ERROR_COMANDO_QUERY_INVALIDO');
		});
		it("Debe indicar error si se envian tres coordenadas al comando QUERY", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 2 3',5,matriz).estado).toBe('ERROR_COMANDO_QUERY_INVALIDO');
		});
		it("Debe indicar error si se envian cuatro coordenadas al comando QUERY", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 2 3 4',5,matriz).estado).toBe('ERROR_COMANDO_QUERY_INVALIDO');
		});
		it("Debe indicar error si se envian cinco coordenadas al comando QUERY", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 2 3 4 5',5,matriz).estado).toBe('ERROR_COMANDO_QUERY_INVALIDO');
		});
	});
		
	describe("Cuando se ejecutar un QUERY con coordenadas validas", function() 
	{
		it("Debe indicar exito si se envian datos validos", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 1 1 2 2 2',5,matriz).estado).toBe('EXITO');
		});
		
		it("Debe regresar cero si la matriz es vacia", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 1 1 2 2 2',5,matriz).datos).toBe(0);
		});		
		
		it("Debe indicar exito si el resultado de los valores al sumar es el esperado", function() 
		{
			var matriz = new Map();
			matriz.set('1|1|1',23);
			matriz.set('1|1|2',11);
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 1 1 2 2 2',5,matriz).datos).toBe(34);
		});		
	});
});		

})(window.sumatoriacubo || (window.sumatoriacubo = {}));

Revision-number: 15
Prop-content-length: 180
Content-length: 180

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-29T18:22:07.719000Z
K 7
svn:log
V 79
Se agrega codigo original a refactorizar, codigo refactorizado y pagina inicial
PROPS-END

Node-path: trunk/sumatoria-cubo/WebContent/codigo-original-refactorizar.php.html
Node-kind: file
Node-action: add
Text-content-md5: ff8a3185ce0599bee65dc3cba07fe233
Text-content-sha1: 4628d818d01dee81e05a078717fdbd3f50a04dd6
Prop-content-length: 10
Text-content-length: 1894
Content-length: 1904

PROPS-END
public function post_confirm()
{
	$id = Input::get('service_id');
	$servicio = Service::find($id);
	//dd($servicio)
	if($servicio != NULL)
	{
		if( $servicio->status_id == '6' )
		{
			return Response::json(array('error' => '2'));
		}
		
		if( $servicio->driver_id == NULL && $servicio->status_id == '1' )
		{
			$servicio = Service::update($id,
										array
										(
											'driver_id' => Input::get('driver_id'),
											'status_id' => '2'
											// Up Carro
											//, 'pwd' => md5(Input::get('pwd'))
										)
										);
			Driver::update(Input::get('driver_id'),array('available' => '0'));
			$driverTmp = Driver::find(Input::get('driver_id'));
			Service::update($id,array('car_id' => $driverTmp->car_id
									  // Up Carro
									  //, 'pwd' => md5(Input::get('pwd'))
			));
			//Notificar a usuario
			$pushMessage = 'Tu servcio ha sido confirmado!';
			/* $servicio = Service::find($id);
			   $push = Push::make();
			   if( $servicio->user->type == '1' ) // iPhone
			   {
			   	$pushAns = $push->ios($sericio->user->uuid,$pushMEssage);
			   }
			   else
			   {
			   	$pushAns = $push->android($servicio->user->uuid,$pushMessage);
			   }
			*/
			$servicio = Service::find($id);
		    $push = Push::make();
		    if( $servicio->user->uuid == '' )
		    {
		   	  	return Response::json(array('error' => '0'));
		    }
		    
		    if( $servicio->user->type == '1' ) // iPhone
		    {
		   	    $result = $push->ios($sericio->user->uuid,$pushMEssage,1,'honk.wav','Open',array('serviceId' => $servicio->id));
		    }
		    else
		    {
		    	$result = $push->android2($sericio->user->uuid,$pushMEssage,1,'default','Open',array('serviceId' => $servicio->id));
		    }
		    return Response::json(array('error' => '0'))
		}
		else
		{
			return Response::json(array('error' => '1'))
		}
	}
	else
	{
		return Response::json(array('error' => '3'));
	}
}

Node-path: trunk/sumatoria-cubo/WebContent/codigo-refactorizado.php.html
Node-kind: file
Node-action: add
Text-content-md5: ffe9411b327cf769096cbf0e952df532
Text-content-sha1: 6c381e0827bb6ac48646c8c471bafc8a0937ca73
Prop-content-length: 10
Text-content-length: 3586
Content-length: 3596

PROPS-END
// A continuacion se listan los ajustes realizados al codigo para eliminar malas practivas
// 1. Se elimina codigo comentariado obsoleto
// 2. Se deja solo comentarios nuevos indicando los cambios o mejoras
// 3. Se usa "estado" en lugar de "error" para indicar que la respuesta no siempre es un error
// 4. Se regresa en estado un texto para hacer mas compresible los posibles errores
// 5. Se hacen validaciones antes de hacer operaciones para:
//     - Evitar tener if anidados que hacen mas dificil leer el codigo.
//     - Evitar hacer consultas y cambios en la base de datos. 
// 6. Se valida el resultado de la operacion push
// 7. Se evita inyeccion SQL
public function post_confirm()
{
	$idServicio = Input::get('service_id'); // Se cambia el nombre de la variable de id a idServicio
	if( !is_int( $idServicio ) )            // Se valida que el valor sea un entero para evitar SQL inyection
	{
		return Response::json(array('estado' => 'ERROR_ID_SERVICIO_NO_NUMERICO'));
	}
	
	$idDriver = Input::get('driver_id');
	if( !is_int( $idDriver ) )            // Se valida que el valor sea un entero para evitar SQL inyection
	{
		return Response::json(array('estado' => 'ERROR_ID_DRIVER_NO_NUMERICO'));
	}
	
	$servicio = Service::find($idServicio);
	// Se hacen validaciones antes de hacer operaciones
	if($servicio == NULL)
	{
		return Response::json(array('estado' => 'ERROR_SERVICIO_NO_EXISTE'));
	}	
	if( $servicio->status_id == '6' )
	{
		return Response::json(array('estado' => 'ERROR_ESTADO_SERVICIO_INVALIDO'));
	}	
	if( $servicio->driver_id != NULL )
	{
		return Response::json(array('estado' => 'ERROR_SERVICIO_TIENE_ASIGNADO_CONDUCTOR'));
	}
	if( $servicio->status_id != '1' )
	{
		return Response::json(array('estado' => 'ERROR_ESTADO_SERVICIO_DISTINTO_1'));
	}	
    if( $servicio->user->uuid == '' )
    {
   	  	return Response::json(array('estado' => 'ERROR_USUARIO_SIN_UUID'));
    }
	
	// Se consulta y valida que exista el Driver antes enviar el update de Servicio
	$driver = Driver::find($idDriver);
	if( $driver == NULL )
	{
		return Response::json(array('estado' => 'ERROR_DRIVER_NO_EXISTE'));
	}

	Service::update($idServicio, array('driver_id' => driver->driver_id,'status_id' => '2'));
											
	Driver::update($idDriver,array('available' => '0'));
	// Nota: Se evita consultar de nuevo el driver ya que el car_id no ha cambiado.
	Service::update($idServicio,array('car_id' => $driver->car_id ));		    
    
    // Se deja en una nueva funcion el envio de mensajes push y se valida el resultado
    $resultadoPush = send_push($servicio,'Tu servcio ha sido confirmado!');
    if( $resultadoPush == NULL )
	{
		return Response::json(array('estado' => 'ERROR_TIPO_DISPOSITIVO_NOTIFICACION_NO_SOPORTADO'));
	}
	else if( $resultadoPush->error == TRUE ) // Se asume que el resultado regresa un 
	{
		return Response::json(array('estado' => 'ERROR_ENVIAR_NOTIFICACION'));
	}
    
    return Response::json(array('estado' => 'OPERACION_EXITOSA'));
}

public function send_push($servicio,$pushMessage)
{
	// Se usa switch que permite codificar de mejor forma distintos casos.
	// Adicionalmente se deja un default para indicar que el tipo de dispositivo no se soporta
	$push = Push::make();
	switch ($servicio->user->type) 
	{
    	case '1':
        	return $push->ios($servicio->user->uuid,$pushMessage,1,'honk.wav','Open',array('serviceId' => $servicio->id));
        break;
    	case '2':
    		return $push->android2($servicio->user->uuid,$pushMessage,1,'default','Open',array('serviceId' => $servicio->id));
    	break;
    	default:
    		return NULL;
    }
}

Node-path: trunk/sumatoria-cubo/WebContent/index.html
Node-kind: file
Node-action: add
Text-content-md5: e9c654975eaae39f10db3525d0378e34
Text-content-sha1: fbb23490ffe001e600c131c9627dca175db5e6db
Prop-content-length: 10
Text-content-length: 855
Content-length: 865

PROPS-END
<!DOCTYPE html>
<html>
	<head>
	<meta charset="UTF-8">
	<title>Descripcion Sumatoria del cubo</title>
	<link rel="stylesheet" type="text/css" href="dependencias/foundation.min.css" />
</head>
<body>

	<h1 class="text-center"> Prueba tecnica backend Rappi - Alejandro Vivas  </h1>
	
	<div class="row">
		<div class="small-8 small-centered columns">
			<ul class="vertical menu" data-accordion-menu>
				<li>
			    	<a href="sumatoriacubo.html">Solucion al problema Sumatoria Cubo - CODING CHALLENGE</a>
			  	</li>
			  	<li>
			  		<a href="testsumatoriacubo.html">Pruebas de la solucion al problema Sumatoria Cubo - CODING CHALLENGE</a>
			  	</li>
			  	<li>
			  		<a href="documentacion.html">Documentacion - CODING CHALLENGE</a>
			  	</li>
			  	<li>
			  		<a>CODE REFACTORING y PREGUNTAS</a>
			  	</li>
			</ul>	
		</div>
	</div>
</body>
</html>

Revision-number: 16
Prop-content-length: 132
Content-length: 132

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-29T18:47:29.812000Z
K 7
svn:log
V 31
Mejora menor para centrar texto
PROPS-END

Node-path: trunk/sumatoria-cubo/WebContent/sumatoriacubo.html
Node-kind: file
Node-action: change
Text-content-md5: 46bfac2329a55ee9d9351a4573581a66
Text-content-sha1: c2b4c4c10811bbc321acf8b56329a7e7e80299d4
Text-content-length: 994
Content-length: 994

<!DOCTYPE html>
<html>
	<head>
	<meta charset="UTF-8">
	<title>Sumatoria cubo</title>
	<link rel="stylesheet" type="text/css" href="dependencias/foundation.min.css" />
</head>
<body>	
	<h1 class="text-center">Sumatoria cubo</h1>
	<h4 id="MensajeResultado" class="text-center"></h4>
	<form>
		<div class="row">
			<div class="medium-5 columns">
				<label>
					Entrada:
					<textarea id="Comandos" rows="15">
2
4 5
UPDATE 2 2 2 4
QUERY 1 1 1 3 3 3
UPDATE 1 1 1 23
QUERY 2 2 2 4 4 4
QUERY 1 1 1 3 3 3
2 4
UPDATE 2 2 2 1
QUERY 1 1 1 1 1 1
QUERY 1 1 1 2 2 2
QUERY 2 2 2 2 2 2
					</textarea>
				</label>
			</div>
			<div class="medium-2 columns">
				<input class="button" type="button" onclick="sumatoriacubo.procesar()" value="Procesar" />
			</div>
			<div class="medium-5 columns">
				<label>
					Salida:
					<textarea id="Resultado" rows="15">		
					</textarea>
				</label>
			</div>
		</div>
	</form>
	<script type="text/javascript" src="sumatoriacubo.js"></script>	
</body>
</html>

Revision-number: 17
Prop-content-length: 230
Content-length: 230

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-29T20:31:24.244000Z
K 7
svn:log
V 128
- Se deja toda la logica de procesamiento en el metodo procesarPruebas
- Se agregan pruebas para el procesamiento de las pruebas
PROPS-END

Node-path: trunk/sumatoria-cubo/WebContent/sumatoriacubo.js
Node-kind: file
Node-action: change
Text-content-md5: 3e95cb52682e256d537c8fffc74a861f
Text-content-sha1: 3113e550a5009792f93e1e0a615d956cd54157c3
Text-content-length: 18660
Content-length: 18660


(function(sumatoriacubo) {
var sumatoriacubo = sumatoriacubo || {};

/**
 * Funcion que es llamada por el boton que realiza el calculo.
 */
sumatoriacubo.procesar = function()
{
	document.getElementById('MensajeResultado').innerHTML = '';	
	var comandos = document.getElementById('Comandos').value.trim();
	var lectorPruebas = new sumatoriacubo.LectorPruebas(comandos);
	var resultado = lectorPruebas.procesarPruebas();
	if( resultado.estado === 'EXITO' )
	{
		document.getElementById('Resultado').value = resultado.datos;
	}
	else
	{
		var mensaje;
		if(resultado.mensajeAdicional)
		{
			mensaje = resultado.mensajeAdicional + ' ' + resultado.mensaje;
		}
		else
		{
			mensaje =  resultado.mensaje;
		}
		document.getElementById('MensajeResultado').innerHTML = mensaje;
		document.getElementById('Resultado').value = '';
	}
};

/**
 * Clase que procesa las pruebas.
 * @param comandos Texto con los comandos a procesar.
 */
sumatoriacubo.LectorPruebas = function(comandos)
{
	this.comandos = comandos;
};

/**
 * Metodo que lee los datos y los procesa.
 * @return Regresa un objeto con la estructura {estado,mensaje,datos} se regresa:
 * - Regresa {estado:'ERROR_VALOR_INDEFENIDO',mensaje:'No se envia comandos'} Si el valor de los comandos es indefinido
 * - Regresa {estado:'ERROR_VALOR_NULO',mensaje:'El valor enviado es null'} Si el valor con los comandos es nulo
 * - Regresa {estado:'ERROR_COMANDOS_NO_STRING',mensaje:'El valor de los camandos no es un string [..]'} Si el valor no es un string
 * - Regresa {estado:'ERROR_NO_SE_ENVIA_COMANDOS',mensaje:'El valor enviado no tiene comandos'} Si no se envian comandos
 * - Regresa {estado:'NUMERO_PRUEBAS_INFERIOR_ESPERADO',mensaje:'Numero de pruebas inferior al esperado'} Si el numero de pruebas es inferior al indicado
 * - Regresa {estado:'NUMERO_SENTENCIA_INFERIOR_ESPERADO',mensaje:'Numero de sentencias inferior al esperado'} Numero de sentencia es inferior al esperado
 * - Regresa {estado:'COMANDO_INVALIDO',mensaje:'Comando [...] invalido. Se espera UPDATE o QUERY'} Si uno de los es invalido 
 * - Regresa {estado:'EXITO',mensaje:'Operacion exitosa', datos:cadenaResultado} Si la operacion es exitosa
 */
sumatoriacubo.LectorPruebas.prototype.procesarPruebas = function()
{
	if(this.comandos === undefined)
	{
		return {estado:'ERROR_VALOR_INDEFENIDO',mensaje:'No se envia comandos'};		
	}
	
	if(this.comandos === null)
	{
		return {estado:'ERROR_VALOR_NULO',mensaje:'El valor enviado es null'};		
	}
	
	if (typeof this.comandos !== 'string') 
	{
		return {estado:'ERROR_COMANDOS_NO_STRING',mensaje:'El valor de los camandos no es un string [' + this.comandos + ']'};
	}
	
	if (this.comandos.trim().length === 0) 
	{
		return {estado:'ERROR_NO_SE_ENVIA_COMANDOS',mensaje:'El valor enviado no tiene comandos'};
	}
	
	var cadenaResultado = ''; 
	var lineaActual = 0;
	var comandosComoLineas = this.comandos.split('\n');
	
	var resultadosNumeroPruebas = this.leerNumeroPruebas( comandosComoLineas[lineaActual++] );
	if(resultadosNumeroPruebas.estado !== 'EXITO')
	{
		return resultadosNumeroPruebas;
	}
	
	var numeroPruebas = resultadosNumeroPruebas.datos;
	for(var i = 0; i < numeroPruebas ; i++)
	{
		if( lineaActual >= comandosComoLineas.length )
		{
			return {estado:'NUMERO_PRUEBAS_INFERIOR_ESPERADO',mensaje:'Numero de pruebas inferior al esperado'};
		}
		
		var resultadosLecturaDimensionMatrizSentencias = this.leerDimensionMatrizSentencias(comandosComoLineas[lineaActual++]);
		if(resultadosLecturaDimensionMatrizSentencias.estado !== 'EXITO')
		{
			return resultadosLecturaDimensionMatrizSentencias;
		}
		
		var dimensionMatriz = resultadosLecturaDimensionMatrizSentencias.datos.dimensionMatriz;
		var numeroSentencias = resultadosLecturaDimensionMatrizSentencias.datos.numeroSentencias;		
		var matriz = new Map();
		for(var j = 0; j < numeroSentencias ; j++)
		{
			if(lineaActual >= comandosComoLineas.length)
			{
				return {estado:'NUMERO_SENTENCIA_INFERIOR_ESPERADO',mensaje:'Numero de sentencias inferior al esperado'};
			}
			
			var comando = comandosComoLineas[lineaActual++].trim();
			if( comando.substring(0,6) === 'UPDATE' )
			{
				var resultadoUpdate = this.ejecutarUpdate(comando,dimensionMatriz,matriz);
				if(resultadoUpdate.estado !== 'EXITO')
				{
					return resultadoUpdate;
				}
			}
			else if( comando.substring(0,5) === 'QUERY' )
			{
				var resultadoQuery =  this.ejecutarQuery(comando,dimensionMatriz,matriz);
				if(resultadoQuery.estado !== 'EXITO')
				{
					return resultadoQuery;
				}
				cadenaResultado += resultadoQuery.datos + '\n';
			}
			else
			{
				return {estado:'COMANDO_INVALIDO',mensaje:'Comando ['+ comando +'] invalido. Se espera UPDATE o QUERY'};
			}
		}
	}
	
	return {estado:'EXITO',mensaje:'Operacion exitosa', datos:cadenaResultado};
};

/**
 * Metodo que lee el numero de pruebas de una cadena de texto.
 * @param comando Cadena con el numero de pruebas
 * @return Regresa un objeto con el resultado de la prueba. El objeto tiene la estructura {estado,mensaje,datos}.
 * Si el valor no es numerico regresa un objeto con la estructura regresada por la funcion sumatoriacubo.stringToEntero,
 * Si el valor no esta en el rango entre 1 y 50 regresa en el estado el valor 'ERROR_RANGO_INVALIDO'
 */
sumatoriacubo.LectorPruebas.prototype.leerNumeroPruebas = function(comando)
{
	var resultado = sumatoriacubo.stringToEntero(comando);
	if( resultado.estado === 'EXITO' )
	{
		if ( resultado.datos < 1 || resultado.datos > 50 )
		{
			return {estado:'ERROR_RANGO_INVALIDO',mensaje:'El numero de pruebas no esta entre 1 y 50.'};
		}		
		return resultado;
	}
	else
	{
		resultado.mensajeAdicional = 'El numero de pruebas no es un numero entero valido.';
		return resultado;
	}	
};

/**
 * Lee la dimension de la matriz y el numero de sentencias de la prueba.
 * @param comando Cadena con el texto
 * @return Regresa un objeto con la estructura {estado,mensaje, datos:{dimensionMatriz,numeroSentencias}}.
 * - Si alguno de los valores no es numerico regresa un objeto con la estructura que se indica del metodo sumatoriacubo.stringToEntero
 * - Si la cadena enviada a la funcion no contiene dos valores, entonces se regresa estado = 'ERROR_DIMENSION_MATRIZ_SENTENCIA'
 * - Si la dimension de la matriz no esta en el rango entre 1 y 100 regresa estado = 'ERROR_RANGO_INVALIDO'
 * - Si el numero de sentencias no esta en el rango entre 1 y 1000 regresa estado =  'ERROR_RANGO_INVALIDO'
 * - Si no se define valor se regresa estado = 'ERROR_VALOR_INDEFENIDO'
 * - Si el valor es nulo regresa estado = 'ERROR_VALOR_NULO'
 * - Si el valor no es string regresa estado = 'ERROR_VALOR_NO_STRING'
 */
sumatoriacubo.LectorPruebas.prototype.leerDimensionMatrizSentencias = function(comando)
{
	if(comando === undefined)
	{
		return {estado:'ERROR_VALOR_INDEFENIDO',mensaje:'Valor indefinido'};
	}
	if(comando === null)
	{
		return {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
	}
	if (typeof comando !== 'string') 
	{
		return { estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
	}	
	
	var dimesionMatrizSentencias = comando.trim().split(' ');
	if( dimesionMatrizSentencias.length != 2 )
	{
		return {estado:'ERROR_DIMENSION_MATRIZ_SENTENCIA',mensaje:'El valor [' + comando +'] no contiene un valor valido con la dimension de la matriz y el numero de sentencias.'};
	}
	
	// Procesar el valor con la dimension de la matriz
	var resultadoDimensionMatriz = sumatoriacubo.stringToEntero( dimesionMatrizSentencias[0] );
	if( resultadoDimensionMatriz.estado === 'EXITO' )
	{
		if ( resultadoDimensionMatriz.datos < 1 || resultadoDimensionMatriz.datos > 100 )
		{
			return {estado:'ERROR_RANGO_INVALIDO',mensaje:'La dimension de la matriz no esta entre 1 y 100.'};
		}
	}
	else
	{
		resultadoDimensionMatriz.mensajeAdicional = 'La dimension de la matriz no es un numero entero valido.';
		return resultadoDimensionMatriz;
	}
	
	// Procesar el valor con el numero de sentencias
	var resultadoNumeroSentencias =  sumatoriacubo.stringToEntero( dimesionMatrizSentencias[1] );
	if( resultadoNumeroSentencias.estado === 'EXITO' )
	{
		if ( resultadoNumeroSentencias.datos < 1 || resultadoNumeroSentencias.datos > 1000 )
		{
			return {estado:'ERROR_RANGO_INVALIDO',mensaje:'El numero de sentencias no esta entre 1 y 1000.'};
		}
	}
	else
	{
		resultadoNumeroSentencias.mensajeAdicional = 'El numero de sentencias no es un numero entero valido.';
		return resultadoNumeroSentencias;
	}	
	
	// Regresar los datos si estos son validos
	return {estado:'EXITO',mensaje:'Operacion exitosa', datos:{dimensionMatriz:resultadoDimensionMatriz.datos,numeroSentencias:resultadoNumeroSentencias.datos}}
};

/**
 * Ejecuta una setencia UPDATE como es especificada en https://www.hackerrank.com/challenges/cube-summation
 * @param comando Comando UPDATE a ejecutar
 * @param dimensionMatriz Dimension de la matriz
 * @param matriz Matriz en la que se almacenan los datos.
 * @return Regresa un objeto de la forma {estado,mensaje} donde
 * - Regresa {estado:'ERROR_VALOR_INDEFENIDO',mensaje:'Valor indefinido'} si el valor del comando es undefined
 * - Regresa {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'} Si el valor del comando es null
 * - Regresa {estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'} Si el valor no es string
 * - Regresa {estado:'ERROR_NO_SE_ENVIA_COMANDO',mensaje:'El valor enviado no tiene comando'} Si el comando tiene una cadena vacia
 * - Regresa {estado:'ERROR_COMANDO_UPDATE_INVALIDO',mensaje:'El comando UPDATE debe ser de la forma UPDATE x y z W pero se envia:[ ...]'} Si el comando tiene una sintaxis invalida
 * - Si un de los valores de las coordenadas o el valor no es numerico entonces regresa el valor de la funcion sumatoriacubo.stringToEntero
 */
sumatoriacubo.LectorPruebas.prototype.ejecutarUpdate = function(comando,dimensionMatriz,matriz)
{
	if(comando === undefined)
	{
		return {estado:'ERROR_VALOR_INDEFENIDO',mensaje:'Valor indefinido'};
	}
	
	if(comando === null)
	{
		return {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
	}
	
	if (typeof comando !== 'string') 
	{
		return {estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
	}
	
	if (comando.trim().length === 0) 
	{
		return {estado:'ERROR_NO_SE_ENVIA_COMANDO',mensaje:'El valor enviado no tiene comando'};
	}
		
	var tokens = comando.split(' ');
	if(tokens.length != 5)
	{
		return {estado:'ERROR_COMANDO_UPDATE_INVALIDO',mensaje:'El comando UPDATE debe ser de la forma UPDATE x y z W pero se envia:[' + comando + ']'};
	}
	
	var x = sumatoriacubo.stringToEntero(tokens[1]);
	var resultadoValidacionX = this.validarEntero(x,'x',1,dimensionMatriz,comando)
	if(resultadoValidacionX)
	{
		return resultadoValidacionX;
	}
	
	var y = sumatoriacubo.stringToEntero(tokens[2]);
	var resultadoValidacionY = this.validarEntero(y,'y',1,dimensionMatriz,comando)
	if(resultadoValidacionY)
	{
		return resultadoValidacionY;
	}
	
	var z = sumatoriacubo.stringToEntero(tokens[3]);
	var resultadoValidacionZ = this.validarEntero(z,'z',1,dimensionMatriz,comando)
	if(resultadoValidacionZ)
	{
		return resultadoValidacionZ;
	}
	
	var valor = sumatoriacubo.stringToEntero( tokens[4] );
	var resultadoValidacionValor = this.validarEntero(valor,'W',-1000000000,1000000000,comando)
	if(resultadoValidacionValor)
	{
		return resultadoValidacionValor;
	}	
	
	matriz.set(x.datos + '|' + y.datos + '|' + z.datos, valor.datos );
	
	return {estado:'EXITO',mensaje:'Operacion exitosa'};
};

/**
 * Ejecuta una sentencia QUERY como es especificada en https://www.hackerrank.com/challenges/cube-summation
 * @param comando Cadena con la sentencia QUERY
 * @param dimensionMatriz Dimension de la matriz con los datos.
 * @param matriz Corresponde a un Map donde la llave es una cadena de la forma x|y|z.
 * @return Regresa un objeto de la forma {estado,mensaje,datos} donde 
 * - Regresa {estado:'ERROR_VALOR_INDEFENIDO',mensaje:'Valor indefinido'} si se envia indefinido como comando
 * - Regresa {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'} Si envia un valor nulo
 * - Regresa {estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'} Si el valor no es string
 * - Regresa {estado:'ERROR_NO_SE_ENVIA_COMANDO',mensaje:'El valor enviado no tiene comando'} Si no se envia comando
 * - Regresa {estado:'ERROR_COMANDO_QUERY_INVALIDO',mensaje:'El comando QUERY debe ser de la forma UPDATE x1 y1 z1 x2 y2 z2 pero se envia:[' + comando + ']'} si el comando no tiene sintaxis valida
 * - Regresa {estado:'ERROR_X1_MAYOR_X2',mensaje:'El valor del x1 es mayor a x2 en la sentencia ' + comando} si x1 > x2
 * - Regresa {estado:'ERROR_Y1_MAYOR_Y2',mensaje:'El valor del y1 es mayor a y2 en la sentencia ' + comando} Si y1 > y2
 * - Regresa {estado:'ERROR_Z1_MAYOR_Z2',mensaje:'El valor del z1 es mayor a z2 en la sentencia ' + comando} Si z1 > z2
 * - Regresa {estado:'EXITO',datos:suma} Si se ejecuta correctamente el comando
 */
sumatoriacubo.LectorPruebas.prototype.ejecutarQuery = function(comando,dimensionMatriz,matriz)
{
	if(comando === undefined)
	{
		return {estado:'ERROR_VALOR_INDEFENIDO',mensaje:'Valor indefinido'};
	}
	
	if(comando === null)
	{
		return {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
	}
	
	if (typeof comando !== 'string') 
	{
		return {estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
	}
	
	if (comando.trim().length === 0) 
	{
		return {estado:'ERROR_NO_SE_ENVIA_COMANDO',mensaje:'El valor enviado no tiene comando'};
	}
	
	var tokens = comando.split(' ');
	if(tokens.length != 7 )
	{
		return {estado:'ERROR_COMANDO_QUERY_INVALIDO',mensaje:'El comando QUERY debe ser de la forma UPDATE x1 y1 z1 x2 y2 z2 pero se envia:[' + comando + ']'};
	}
	
	var resultadox1 = sumatoriacubo.stringToEntero(tokens[1]);
	var resultadoValidacionX1 = this.validarEntero(resultadox1,'x1',1,dimensionMatriz,comando);
	if(resultadoValidacionX1)
	{
		return resultadoValidacionX1;
	}
	
	var resultadoy1 = sumatoriacubo.stringToEntero(tokens[2]);
	var resultadoValidacionY1 = this.validarEntero(resultadoy1,'y1',1,dimensionMatriz,comando);
	if(resultadoValidacionY1)
	{
		return resultadoValidacionY1;
	}
	
	var resultadoz1 = sumatoriacubo.stringToEntero(tokens[3]);
	var resultadoValidacionZ1 = this.validarEntero(resultadoz1,'z1',1,dimensionMatriz,comando);
	if(resultadoValidacionZ1)
	{
		return resultadoValidacionZ1;
	}
	
	var resultadox2 = sumatoriacubo.stringToEntero(tokens[4]);
	var resultadoValidacionX2 = this.validarEntero(resultadox2,'x2',1,dimensionMatriz,comando);
	if(resultadoValidacionX2)
	{
		return resultadoValidacionX2;
	}	
	
	var resultadoy2 = sumatoriacubo.stringToEntero(tokens[5]);
	var resultadoValidacionY2 = this.validarEntero(resultadoy2,'y2',1,dimensionMatriz,comando);
	if(resultadoValidacionY2)
	{
		return resultadoValidacionY2;
	}
	
	var resultadoz2 = sumatoriacubo.stringToEntero(tokens[6]);
	var resultadoValidacionZ2 = this.validarEntero(resultadoz2,'z2',1,dimensionMatriz,comando);
	if(resultadoValidacionZ2)
	{
		return resultadoValidacionZ2;
	}
	
	var x1 = resultadox1.datos;
	var y1 = resultadoy1.datos;
	var z1 = resultadoz1.datos;
	var x2 = resultadoz2.datos;
	var y2 = resultadoy2.datos;
	var z2 = resultadoz2.datos;
	
	if( x1 > x2 )
	{
		return {estado:'ERROR_X1_MAYOR_X2',mensaje:'El valor del x1 es mayor a x2 en la sentencia ' + comando};
	}
	
	if( y1 > y2 )
	{
		return {estado:'ERROR_Y1_MAYOR_Y2',mensaje:'El valor del y1 es mayor a y2 en la sentencia ' + comando};
	}
	
	if( z1 > z2 )
	{
		return {estado:'ERROR_Z1_MAYOR_Z2',mensaje:'El valor del z1 es mayor a z2 en la sentencia ' + comando};
	}
	
	var suma = 0;
	for (var [key, value] of matriz) 
	{
		var keyTokens = key.split('|');
		var x = parseInt(keyTokens[0]);
		var y = parseInt(keyTokens[1]);
		var z = parseInt(keyTokens[2]);
		
		if ( (x >= x1 && x <= x2) && (y >= y1 && y <= y2) && (z >= z1 && z <= z2) )
		{
			suma += value;
		}
	}
	
	return {estado:'EXITO',datos:suma};
}

/**
 * Valida si el resultado de convertir una cadena a un entero es exitosa y de ser asi valida
 * que el valor este en el rango indicado.
 * @param valor Resultado de llamar a la funcion sumatoriacubo.stringToEntero
 * @param nombre Nombre de la variable. Usado para enviar descipcion del error
 * @param minimo Valor minimo que puede tomar el valor
 * @param maximo Valor maximo que puede tomar el valor
 * @param comando Comando que contiene el valor. Se usa para la drescripcion del error
 */
sumatoriacubo.LectorPruebas.prototype.validarEntero = function(valor,nombre,minimo,maximo,comando)
{
	if( valor.estado === 'EXITO' )
	{
		if ( valor.datos < minimo || valor.datos > maximo )
		{
			return {estado:'ERROR_RANGO_INVALIDO',mensaje:'El valor ' + nombre +' no esta entre ' + minimo + ' y ' + maximo + ' en la sentencia [' + comando + '].'};
		}
	}
	else
	{
		valor.mensajeAdicional = 'El valor ' + nombre +' no es un numero entero valido en la sentencia [' + comando + '].';
		return valor;
	}
};

/**
 * Convierte un string en un entero. Regresa un objeto con la estructura {estado,mensaje,datos}. Si la operacion es
 * exitosa regresa: {estado:'EXITO',mensaje:'Operacion exitosa',datos:valor} donde valor corresponde al valor convertido.
 * En caso de fallar regresa lo siguiente:
 * - Si no se ingresa un valor : {estado:'ERROR_VALOR_INDEFENIDO',mensaje:'Valor indefinido'};
 * - Si se envia null: {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
 * - Si se envia un valor que no es un string: { estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
 * - Si se envia una cadena con valor que no corresponde a un string se regresa:
 *   {estado:'ERROR_VALOR_NO_ENTERO',mensaje:'Valor [' + numeroComoCadena + '] no es entero'} donde numeroComoCadena
 *   corresponde al valor enviado a la funcion.
 */
sumatoriacubo.stringToEntero = function(numeroComoCadena)
{
	if(numeroComoCadena === undefined)
	{
		return {estado:'ERROR_VALOR_INDEFENIDO',mensaje:'Valor indefinido'};
	}
	if(numeroComoCadena === null)
	{
		return {estado:'ERROR_VALOR_NULO',mensaje:'Valor indefinido'};
	}
	if (typeof numeroComoCadena !== 'string') 
	{
		return { estado:'ERROR_VALOR_NO_STRING',mensaje:'El valor ingresado no es un string'};
	}
		
	var valor = parseInt(numeroComoCadena);
	if( isNaN(valor) )
	{
		return {estado:'ERROR_VALOR_NO_ENTERO',mensaje:'Valor [' + numeroComoCadena + '] no es entero'};
	}
	else if(new String(valor) != numeroComoCadena.trim() )
	{
		return {estado:'ERROR_VALOR_NO_ENTERO',mensaje:'Valor [' + numeroComoCadena + '] no es entero'};
	}
	else
	{
		return {estado:'EXITO',mensaje:'Operacion exitosa',datos:valor};
	}	
};

})(window.sumatoriacubo || (window.sumatoriacubo = {}));

Node-path: trunk/sumatoria-cubo/WebContent/testsumatoriacubo.js
Node-kind: file
Node-action: change
Text-content-md5: 5b5c044630b6f236404b8562cf43a223
Text-content-sha1: 775723e9ea08f7d6ef3c799a52a1859a9108e495
Text-content-length: 26247
Content-length: 26247


(function(sumatoriacubo) {
var sumatoriacubo = sumatoriacubo || {};

describe("Conversion de cadenas a numeros", function() 
{
	describe("Cuando se intentar convertir un valor idefinido o nulo a entero", function() 
	{
		it("Debe indicar que no se ingreso un valor", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero();
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_INDEFENIDO');
		});
		
		it("Debe indicar que se ingreso un valor nulo", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero(null);
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NULO');
		});
	});
	
	describe("Cuando se intenta convertir a entero una cadena con un valor no numerico", function() 
	{
		it("Debe indicar que no se ingreso una cadena con un valor entero para el valor ['1a']", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero('1a');
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que no se ingreso una cadena con un valor entero para el valor ['a1']", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero('a1');
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que no se ingreso una cadena con un valor entero para el valor ['']", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero('');
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que no se ingreso una cadena", function() 
		{
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero(1);
		    expect(resultadoValorIndefinido.estado).toBe('ERROR_VALOR_NO_STRING');
		});
	});
	
	describe("Cuando se intenta convertir una cadena con un valor valido", function() 
	{
		var numero = Math.floor((Math.random() *  Number.MAX_SAFE_INTEGER ) );
		var stringNumero = numero + '';
		it("Debe indicar que la operacion es exitosa y regresar el valor correctamente si se envia el valor ['" + numero + "']", function() 
		{			
		    var resultadoValorIndefinido = sumatoriacubo.stringToEntero(stringNumero);
		    expect(resultadoValorIndefinido.estado).toBe('EXITO');
		    expect(resultadoValorIndefinido.datos).toBe(numero);
		});
	});
});
	
describe("Lectura de numero de pruebas", function() 
{
	describe("Cuando el numero de pruebas a leer es invalido", function() 
	{
		it("Debe indicar que el numero de pruebas es invalido si envia texto en lugar de un numero", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas('w').estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que el numero de pruebas es invalido si envia texto vacio", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas('').estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		
		it("Debe indicar que el numero de pruebas es invalido si envia texto un valor menor a 1", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas('0').estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar que el numero de pruebas es invalido si envia texto un valor mayor a 50", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas('51').estado).toBe('ERROR_RANGO_INVALIDO');
		});		
		
		var numero = Math.floor((Math.random() *  50 ) + 1 );
		var stringNumero = numero + '';
		it("Debe indicar que el numero de pruebas es valido si envia texto un valor [" + stringNumero +"] el cual esta entre 1 y 50", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerNumeroPruebas(stringNumero).estado).toBe('EXITO');
		});
	});
});	

describe("Lectura de dimension matriz y numero de sentencias", function() 
{
	describe("Cuando el valor con la dimension matriz y numero de sentencias es indefinido, nulo, no es una cadena o se una valor", function() 
	{
		it("Debe indicar error si no se define un valor para la dimension y el numero de sentencias", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias().estado).toBe('ERROR_VALOR_INDEFENIDO');
		});
		
		it("Debe indicar error si es nulo el valor para la dimension y el numero de sentencias", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias(null).estado).toBe('ERROR_VALOR_NULO');
		});
		
		it("Debe indicar error si el valor no es un string para la dimension y el numero de sentencias", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias(1).estado).toBe('ERROR_VALOR_NO_STRING');
		});
		
		it("Debe indicar error si el valor es un string vacio", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('').estado).toBe('ERROR_DIMENSION_MATRIZ_SENTENCIA');
		});

		it("Debe indicar error si solo se envia un valor", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('1').estado).toBe('ERROR_DIMENSION_MATRIZ_SENTENCIA');
		});
	});
	
	describe("Cuando el texto con la dimension de la matriz no es valido", function() 
	{
		it("Debe indicar que la dimension de la matriz es invalido si envia texto en lugar de un numero", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('n 3').estado).toBe('ERROR_VALOR_NO_ENTERO');
		});		
		
		var dimensionMenor = - Math.floor((Math.random() *  100 ) + 1 );
		var stringDimensionMenor = dimensionMenor + '';
		it("Debe indicar que la dimension de la matriz es invalida si el valor ["+ dimensionMenor +"] es menor es 1", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias(stringDimensionMenor + ' 3').estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		var dimensionMayor = 100 + Math.floor((Math.random() *  100 ) + 1 );
		var stringDimensionMayor = dimensionMayor + '';
		it("Debe indicar que la dimension de la matriz es invalida si el valor ["+ dimensionMayor +"] es mayor es 100", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias(stringDimensionMayor + ' 3').estado).toBe('ERROR_RANGO_INVALIDO');
		});		
	});
	
	describe("Cuando el texto con el numero de sentencias de la prueba no es valido", function() 
	{
		it("Debe indicar que la dimension de la matriz es invalido si envia texto en lugar de un numero", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('3 a').estado).toBe('ERROR_VALOR_NO_ENTERO');
		});		
		
		var sentenciasMenor = - Math.floor((Math.random() *  1000 ) + 1 );
		var stringSentenciasMenor = sentenciasMenor + '';
		it("Debe indicar que el numero de setencias es invalido si el valor ["+ sentenciasMenor +"] es menor es 1", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('3 ' + stringSentenciasMenor).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		var sentenciasMayor = 1000 + Math.floor((Math.random() *  1000 ) + 1 );
		var stringSentenciasMayor = sentenciasMayor + '';
		it("Debe indicar que el numero de setencias es invalido si el valor ["+ sentenciasMayor +"] es mayor es 1000", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias('3 ' + stringSentenciasMayor).estado).toBe('ERROR_RANGO_INVALIDO');
		});		
	});
	
	describe("Cuando el texto con el la dimension de la matriz y el numero de sentencias es valido", function() 
	{
		var dimensionValida = Math.floor((Math.random() *  100 ) + 1 );
		var stringDimensionValida = dimensionValida + '';
		
		var sentenciaValida = Math.floor((Math.random() *  1000 ) + 1 );
		var stringSentenciaValida = sentenciaValida + '';
		it("Debe indicar que la dimension de la matriz y el numero de sentencias es valido para el valor ["+ stringDimensionValida + ' ' + sentenciaValida +"]", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.leerDimensionMatrizSentencias(stringDimensionValida + ' ' + stringSentenciaValida).estado).toBe('EXITO');
		});
	});	
});

describe("Ejecucion comando UPDATE", function() 
{
	describe("Cuando se intenta ejecutar un UPDATE pero el valor es indefinido, nulo, no es una cadena o se envia una cadena vacia", function() 
	{
		it("Debe indicar que se envio un valor indefinido", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate(undefined,100,matriz).estado).toBe('ERROR_VALOR_INDEFENIDO');
		});
		it("Debe indicar que se envio un valor nulo", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate(null,100,matriz).estado).toBe('ERROR_VALOR_NULO');
		});
		it("Debe indicar que se envio un valor no string", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate(1,100,matriz).estado).toBe('ERROR_VALOR_NO_STRING');
		});
		it("Debe indicar que se envio un valor vacio", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('',100,matriz).estado).toBe('ERROR_NO_SE_ENVIA_COMANDO');
		});	
	});
	
	describe("Cuando se intenta ejecutar un UPDATE con datos invalidos", function() 
	{
		it("Debe indicar que la coordenada x no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE x 1 2 5',100,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar que la coordenada x supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 3 1 1 5',1,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar que la coordenada y no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 y 2 5',100,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar que la coordenada y supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 3 1 5',1,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar que la coordenada z no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 1 z 5',100,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar que la coordenada z supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 1 3 5',1,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
	});
		
	describe("Cuando se intenta ejecutar un UPDATE con menos o mas parametros", function() 
	{
		it("Debe indicar que UPDATE es invalido al no enviar las coordenadas ni el valor en el comando", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE',100,matriz).estado).toBe('ERROR_COMANDO_UPDATE_INVALIDO');
		});
		
		it("Debe indicar que UPDATE es invalido cuando solo se envia una coordenada", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1',100,matriz).estado).toBe('ERROR_COMANDO_UPDATE_INVALIDO');
		});
		
		it("Debe indicar que UPDATE es invalido cuando solo se envia dos coordenadas", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 2',100,matriz).estado).toBe('ERROR_COMANDO_UPDATE_INVALIDO');
		});
		
		it("Debe indicar que UPDATE es invalido cuando solo se envia tres coordenadas", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 2 3',100,matriz).estado).toBe('ERROR_COMANDO_UPDATE_INVALIDO');
		});
		
		it("Debe indicar que UPDATE es invalido cuando solo se envia mas parametros", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 2 3 5 2',100,matriz).estado).toBe('ERROR_COMANDO_UPDATE_INVALIDO');
		});
	});
	
	describe("Cuando se ejecuta un UPDATE con datos validos", function() 
	{
		it("Debe quedar almacenado en la matriz el valor enviado en el comando", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarUpdate('UPDATE 1 2 3 4',100,matriz).estado).toBe('EXITO');
		    expect(matriz.get('1|2|3')).toBe(4);
		});
	});
});


describe("Ejecucion comando QUERY", function() 
{
	describe("Cuando se ejecuta un QUERY con datos invalidos", function() 
	{
		it("Debe indicar error si no se envia un indefinido", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery(undefined,5,matriz).estado).toBe('ERROR_VALOR_INDEFENIDO');
		});
		
		it("Debe indicar error si se envia un valor nulo", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery(null,5,matriz).estado).toBe('ERROR_VALOR_NULO');
		});
		
		it("Debe indicar error si se envia un valor no string", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery(1,5,matriz).estado).toBe('ERROR_VALOR_NO_STRING');
		});
		
		it("Debe indicar error si se envia un valor vacio", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery(' ',5,matriz).estado).toBe('ERROR_NO_SE_ENVIA_COMANDO');
		});
		
		it("Debe indicar error si se envian menos datos de los que espera el comando QUERY", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 2 2 2 2',5,matriz).estado).toBe('ERROR_COMANDO_QUERY_INVALIDO');
		});
		
		it("Debe indicar error si la coordenada x1 no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY a 2 2 2 2 2',5,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar error si la coordenada x1 supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 6 2 2 2 2 2',5,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar error si la coordenada y1 no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 2 a 2 2 2 2',5,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar error si la coordenada y1 supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 6 2 2 2 2',5,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar error si la coordenada z1 no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 2 2 q 2 2 2',5,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar error si la coordenada z1 supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 1 6 2 2 2',5,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar error si la coordenada x2 no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 2 2 2 a 2 2',5,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar error si la coordenada x2 supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 2 2 6 2 2',5,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar error si la coordenada y2 no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 2 2 2 2 a 2',5,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar error si la coordenada y2 supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 1 2 2 6 2',5,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		it("Debe indicar error si la coordenada z2 no corresponde con un valor entero", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 2 2 1 2 2 a',5,matriz).estado).toBe('ERROR_VALOR_NO_ENTERO');
		});
		it("Debe indicar error si la coordenada z2 supera la dimension de la matriz", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 1 1 2 2 6',5,matriz).estado).toBe('ERROR_RANGO_INVALIDO');
		});
		
		
		it("Debe indicar error si la coordenada x1 es mayor x2", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 2 1 1 1 2 1',5,matriz).estado).toBe('ERROR_X1_MAYOR_X2');
		});
		it("Debe indicar error si la coordenada y1 es mayor y2", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 2 1 1 1 1',5,matriz).estado).toBe('ERROR_Y1_MAYOR_Y2');
		});
		it("Debe indicar error si la coordenada z1 es mayor z2", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 1 2 1 1 1',5,matriz).estado).toBe('ERROR_Z1_MAYOR_Z2');
		});
	});
		
	describe("Cuando se intenta ejecutar un QUERY con menos o mas parametros", function() 
	{
		it("Debe indicar error si se envian mas datos de los que espera el comando QUERY", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 2 2 2 2 2 1',5,matriz).estado).toBe('ERROR_COMANDO_QUERY_INVALIDO');
		});
		
		it("Debe indicar error si se envian solo una coordenada al comando QUERY", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1',5,matriz).estado).toBe('ERROR_COMANDO_QUERY_INVALIDO');
		});
		it("Debe indicar error si se envian dos coordenadas al comando QUERY", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 2',5,matriz).estado).toBe('ERROR_COMANDO_QUERY_INVALIDO');
		});
		it("Debe indicar error si se envian tres coordenadas al comando QUERY", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 2 3',5,matriz).estado).toBe('ERROR_COMANDO_QUERY_INVALIDO');
		});
		it("Debe indicar error si se envian cuatro coordenadas al comando QUERY", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 2 3 4',5,matriz).estado).toBe('ERROR_COMANDO_QUERY_INVALIDO');
		});
		it("Debe indicar error si se envian cinco coordenadas al comando QUERY", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 2 3 4 5',5,matriz).estado).toBe('ERROR_COMANDO_QUERY_INVALIDO');
		});
	});
		
	describe("Cuando se ejecutar un QUERY con coordenadas validas", function() 
	{
		it("Debe indicar exito si se envian datos validos", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 1 1 2 2 2',5,matriz).estado).toBe('EXITO');
		});
		
		it("Debe regresar cero si la matriz es vacia", function() 
		{
			var matriz = new Map();
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 1 1 2 2 2',5,matriz).datos).toBe(0);
		});		
		
		it("Debe indicar exito si el resultado de los valores al sumar es el esperado", function() 
		{
			var matriz = new Map();
			matriz.set('1|1|1',23);
			matriz.set('1|1|2',11);
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.ejecutarQuery('QUERY 1 1 1 2 2 2',5,matriz).datos).toBe(34);
		});		
	});
});

describe("Procesamiento de pruebas", function() 
{
	describe("Cuando no se envia datos a procesar", function() 
	{
		it("Debe indicar que no se ingreso un valor cuando no se envio valor en el constructor", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas();
		    expect(lectorPruebas.procesarPruebas().estado).toBe('ERROR_VALOR_INDEFENIDO');
		});
		
		it("Debe indicar que no se ingreso un valor cuando no se envio un valor nulo", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas(null);
		    expect(lectorPruebas.procesarPruebas().estado).toBe('ERROR_VALOR_NULO');
		});
		
		it("Debe indicar que no se ingreso un valor cuando no se envia un cadena vacia", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas('');
		    expect(lectorPruebas.procesarPruebas().estado).toBe('ERROR_NO_SE_ENVIA_COMANDOS');
		});		
	});
	
	describe("Cuando se envia datos que no son string", function() 
	{
		it("Debe indicar que no se ingreso un valor string cuando se envia un numero", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas(1);
		    expect(lectorPruebas.procesarPruebas().estado).toBe('ERROR_COMANDOS_NO_STRING');
		});
		
		it("Debe indicar que no se ingreso un valor string cuando se envia un objeto que no es de la clase string", function() 
		{
		    var lectorPruebas = new sumatoriacubo.LectorPruebas(new Object());
		    expect(lectorPruebas.procesarPruebas().estado).toBe('ERROR_COMANDOS_NO_STRING');
		});
	});
	
	describe("Cuando los datos a procesar son invalidos", function() 
	{
		it("Debe indicar error si el numero de pruebas indicado es inferior al enviado en los datos", function() 
		{
     		var datos = '2\n4 1\nUPDATE 2 2 2 4';
		    var lectorPruebas = new sumatoriacubo.LectorPruebas(datos);		   
		    expect(lectorPruebas.procesarPruebas().estado).toBe('NUMERO_PRUEBAS_INFERIOR_ESPERADO');
		});
		it("Debe indicar error si el numero de sentencias indicado es inferior al enviado en los datos", function() 
		{
     		var datos = '1\n4 2\nUPDATE 2 2 2 4';
		    var lectorPruebas = new sumatoriacubo.LectorPruebas(datos);		   
		    expect(lectorPruebas.procesarPruebas().estado).toBe('NUMERO_SENTENCIA_INFERIOR_ESPERADO');
		});		
	});
	
	describe("Cuando los datos a procesar son validos", function() 
	{
		it("Debe indicar exito si se envian datos validos con una prueba", function() 
		{
     		var datos = '1\n4 2\nUPDATE 2 2 2 4\nQUERY 1 1 1 2 2 2';
		    var lectorPruebas = new sumatoriacubo.LectorPruebas(datos);		   
		    expect(lectorPruebas.procesarPruebas().estado).toBe('EXITO');
		    expect(lectorPruebas.procesarPruebas().datos).toBe('4\n');
		});
		
		it("Debe indicar exito si se envian datos validos con dos pruebas", function() 
		{
     		var datos = '2\n'+
     		            '4 5\n' +
     		            'UPDATE 2 2 2 4\n'+
     		            'QUERY 1 1 1 3 3 3\n'+
     		            'UPDATE 1 1 1 23\n'+
     		            'QUERY 2 2 2 4 4 4\n'+
     		            'QUERY 1 1 1 3 3 3\n' +
     					'2 4\n'+
     					'UPDATE 2 2 2 1\n'+
     					'QUERY 1 1 1 1 1 1\n'+
     					'QUERY 1 1 1 2 2 2\n'+
     					'QUERY 2 2 2 2 2 2';
     		var valorEsperado = '4\n4\n27\n0\n1\n1\n';
		    var lectorPruebas = new sumatoriacubo.LectorPruebas(datos);		   
		    expect(lectorPruebas.procesarPruebas().estado).toBe('EXITO');
		    expect(lectorPruebas.procesarPruebas().datos).toBe(valorEsperado);
		});
		
	});
});

})(window.sumatoriacubo || (window.sumatoriacubo = {}));

Revision-number: 18
Prop-content-length: 100
Content-length: 100

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-29T20:44:22.818000Z
K 7
svn:log
V 0

PROPS-END

Node-path: trunk/sumatoria-cubo/WebContent/codigo-original-refactorizar.php
Node-kind: file
Node-action: add
Node-copyfrom-rev: 17
Node-copyfrom-path: trunk/sumatoria-cubo/WebContent/codigo-original-refactorizar.php.html
Text-copy-source-md5: ff8a3185ce0599bee65dc3cba07fe233
Text-copy-source-sha1: 4628d818d01dee81e05a078717fdbd3f50a04dd6


Node-path: trunk/sumatoria-cubo/WebContent/codigo-original-refactorizar.php.html
Node-action: delete


Revision-number: 19
Prop-content-length: 100
Content-length: 100

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-29T20:44:29.557000Z
K 7
svn:log
V 0

PROPS-END

Node-path: trunk/sumatoria-cubo/WebContent/codigo-refactorizado.php
Node-kind: file
Node-action: add
Node-copyfrom-rev: 18
Node-copyfrom-path: trunk/sumatoria-cubo/WebContent/codigo-refactorizado.php.html
Text-copy-source-md5: ffe9411b327cf769096cbf0e952df532
Text-copy-source-sha1: 6c381e0827bb6ac48646c8c471bafc8a0937ca73


Node-path: trunk/sumatoria-cubo/WebContent/codigo-refactorizado.php.html
Node-action: delete


Revision-number: 20
Prop-content-length: 100
Content-length: 100

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-29T20:45:39.429000Z
K 7
svn:log
V 0

PROPS-END

Node-path: trunk/sumatoria-cubo/WebContent/codigo-original-refactorizar.php.txt
Node-kind: file
Node-action: add
Node-copyfrom-rev: 19
Node-copyfrom-path: trunk/sumatoria-cubo/WebContent/codigo-original-refactorizar.php
Text-copy-source-md5: ff8a3185ce0599bee65dc3cba07fe233
Text-copy-source-sha1: 4628d818d01dee81e05a078717fdbd3f50a04dd6


Node-path: trunk/sumatoria-cubo/WebContent/codigo-original-refactorizar.php
Node-action: delete


Revision-number: 21
Prop-content-length: 100
Content-length: 100

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-29T20:45:46.294000Z
K 7
svn:log
V 0

PROPS-END

Node-path: trunk/sumatoria-cubo/WebContent/codigo-refactorizado.php.txt
Node-kind: file
Node-action: add
Node-copyfrom-rev: 20
Node-copyfrom-path: trunk/sumatoria-cubo/WebContent/codigo-refactorizado.php
Text-copy-source-md5: ffe9411b327cf769096cbf0e952df532
Text-copy-source-sha1: 6c381e0827bb6ac48646c8c471bafc8a0937ca73


Node-path: trunk/sumatoria-cubo/WebContent/codigo-refactorizado.php
Node-action: delete


Revision-number: 22
Prop-content-length: 150
Content-length: 150

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-30T14:05:34.767000Z
K 7
svn:log
V 49
Se agrega html con las respuestas a las preguntas
PROPS-END

Node-path: trunk/sumatoria-cubo/WebContent/preguntas.html
Node-kind: file
Node-action: add
Text-content-md5: 14d36c92269cc887e3e840f4bc97f1ad
Text-content-sha1: 43f12af53daba0b78021e768174b3c12d7ed5501
Prop-content-length: 10
Text-content-length: 1880
Content-length: 1890

PROPS-END
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Preguntas</title>
	<link rel="stylesheet" type="text/css" href="dependencias/foundation.min.css" />
</head>
<body>
	<h1 class="text-center">Preguntas</h1>
	<div class="row">
		<div class="callout primary">
			<ul>
				<li>
					<span style="font-weight: bold;">Â¿En quÃ© consiste el principio de responsabilidad Ãºnica? Â¿CuÃ¡l es su propÃ³sito?</span>
					<br />
					En programaci&oacute;n orienta a objetos esto quiere decir que una Clase debe tener un &uacute;nico proposito,
					por lo que todo el c&oacute;digo que se encuentre dentro de esta debe estar orientado a resolver ese
					&uacute;nico proposito. 
				</li>
				<li>
					<span style="font-weight: bold;">Â¿QuÃ© caracterÃ­sticas tiene segÃºn tu opiniÃ³n â€œbuenâ€ cÃ³digo o cÃ³digo limpio?</span>
					<br />
					Estas son algunas de las caracter&iacute;sticas que en mi opini&oacute;n debe tener el buen c&oacute;digo o c&oacute;digo limpio
					<ul>						 
						<li>No tener hardcode o codigo "quemado"</li>
						<li>Una funci&oacute;n debe tener un &uacute;nico objetivo e implementar solo este.</li>
						<li>Una clase debe tener e implementar una &uacute;nica responsabilidad.</li>
						<li>El c&oacute;digo no tiene mas de dos o tres if,while,switch,for,try anidados.</li>
						<li>Los nombres de las variables deben ser claros y explictos sobre lo que representan.</li>
						<li>El c&oacute;digo debe tener comentarios sobre todo cuando este implementa reglas de negocio que no son simples.</li>
						<li>Un m&eacute;todo o funci&oacute;n no superan las 50 lineas de programaci&oacute;n.</li>
						<li>Las clases no superan las 1000 lineas de programaci&oacute;n</li>
						<li>Las lineas de c&oacute;digo son cortas, cerca de 10 caracteres como m&aacute;ximo.</li>			
					</ul>
				</li>
			</ul>
		</div>
	</div>	
</body>
</html>

Revision-number: 23
Prop-content-length: 142
Content-length: 142

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-30T14:07:14.576000Z
K 7
svn:log
V 41
Documentacion del codigo de la aplicacion
PROPS-END

Node-path: trunk/sumatoria-cubo/WebContent/documentacion.html
Node-kind: file
Node-action: add
Text-content-md5: c9bba9fe3072625c1c30d8b2d853eec7
Text-content-sha1: ded42e49475fd71d7f14aa09d33f84c3e74a5dcf
Prop-content-length: 10
Text-content-length: 1427
Content-length: 1437

PROPS-END
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Documento sobre el c&oacute;digo</title>
	<link rel="stylesheet" type="text/css" href="dependencias/foundation.min.css" />
</head>
<body>
	<h1 class="text-center">Documento sobre el c&oacute;digo</h1>
	<div class="row">
		<div class="callout primary">
			La aplicaci&oacute;n esta compuesta por:
			<ul>
				<li>Archivo html <a href="sumatoriacubo.html">sumatoriacubo.html</a></li>
				<li>JavaScript con el c&oacute;digo que realiza las operaciones <a href="sumatoriacubo.js">sumatoriacubo.js</a></li>
			</ul>
			Las pruebas estan en:
			<ul>
				<li>Archivo html <a href="testsumatoriacubo.html">testsumatoriacubo.html</a></li>
				<li>JavaScript con las pruebas de la aplicaci&oacute;n <a href="testsumatoriacubo.js">testsumatoriacubo.js</a></li>
			</ul>
			En el archivo <a href="sumatoriacubo.js">sumatoriacubo.js</a> se encuentra el c&oacute;digo de la aplicaci&oacute;n en el paquete <code>sumatoriacubo</code>.
			En el paquete se encuentra:
			<ul>
				<li>La funci&oacute;n <code>procesar</code> la cual es ejecutada cuando se hece click en el boton procesar</li>
				<li>La funci&oacute;n <code>stringToEntero</code> que realiza conversi&oacute;n de cadenas a enteros</li>
				<li>La clase <code>LectorPruebas</code> la cual contiene la l&oacute;gica que realiza las operaciones requeridas por la prueba</li>
			</ul>
		</div>		
	</div>
</body>
</html>

Revision-number: 24
Prop-content-length: 144
Content-length: 144

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-30T14:33:48.141000Z
K 7
svn:log
V 43
Se agrega enlaces a contenidos de la prueba
PROPS-END

Node-path: trunk/sumatoria-cubo/WebContent/index.html
Node-kind: file
Node-action: change
Text-content-md5: 040ffcabd0703cb84a38297f55c65ec9
Text-content-sha1: bb8693bf771d8ad2237b2c4a055ed56ee56fdb2d
Text-content-length: 1475
Content-length: 1475

<!DOCTYPE html>
<html>
	<head>
	<meta charset="UTF-8">
	<title>Descripcion Sumatoria del cubo</title>
	<link rel="stylesheet" type="text/css" href="dependencias/foundation.min.css" />
</head>
<body>

	<h1 class="text-center"> Prueba tecnica backend Rappi - Alejandro Vivas  </h1>
	
	<div class="row">
		<div class="small-8 small-centered columns">
			<ul class="vertical menu" data-accordion-menu>
				<li>
			    	<a href="#">CODING CHALLENGE</a>			    	
			    	<ul class="nested vertical menu">
				      <li><a href="sumatoriacubo.html">Soluci&oacute;n al problema Sumatoria Cubo</a></li>
				      <li><a href="testsumatoriacubo.html">Pruebas de la aplicaci&oacute;n</a></li>
				      <li><a href="documentacion.html">Documento sobre el c&oacute;digo</a></li>				      
				      <li><a href="sumatoriacubo.js">C&oacute;digo JavaScript</a></li>
				      <li><a href="testsumatoriacubo.js">C&oacute;digo de Pruebas JavaScript</a></li>
				      <li><a href="testsumatoriacubo.dump">Dump Subversion (version 1.9.3)</a></li>
    				</ul>			    	
			  	</li>
			  	<li>
			  		<a href="#">CODE REFACTORING</a>
			  		<ul class="nested vertical menu">
				      <li><a href="codigo-original-refactorizar.php.txt">C&oacute;digo original</a></li>
				      <li><a href="codigo-refactorizado.php.txt">C&oacute;digo refactorizado</a></li>
    				</ul>
			  	</li>
			  	<li>
			  		<a href="preguntas.html">PREGUNTAS</a>
			  	</li>
			</ul>	
		</div>
	</div>
</body>
</html>

Revision-number: 25
Prop-content-length: 182
Content-length: 182

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-30T14:34:25.542000Z
K 7
svn:log
V 81
Se hacen cambios que incluyen los comentarios con las malas practicas del codigo 
PROPS-END

Node-path: trunk/sumatoria-cubo/WebContent/codigo-original-refactorizar.php.txt
Node-kind: file
Node-action: change
Text-content-md5: 9a9c13291fc75c8d6c552d10f535f2d2
Text-content-sha1: 8f52344bc843e07d0fe5eb9574700bae4a2f4065
Text-content-length: 3340
Content-length: 3340

//---------------------------------------
// Los comentarios que inician con //MP Corresponde a malas practicas en mi criterio
//--------------------------------------
public function post_confirm()
{
	$id = Input::get('service_id'); //MP El nombre de la variable no es bueno. Se recomienda cambiar el nombre por idServicio
	$servicio = Service::find($id); //MP El valor de la variable $id no se valida, lo que puede derivar inyeccion SQL 
	//dd($servicio) //MP Comentario no util para el codigo
	if($servicio != NULL)
	{
		if( $servicio->status_id == '6' )
		{
			return Response::json(array('error' => '2')); //MP El codigo de error no es claro, mejor usar algo como "ERROR_SERVICIO_FINALIZADO"
		}
		
		if( $servicio->driver_id == NULL && $servicio->status_id == '1' )
		{
			$servicio = Service::update($id,
										array
										(
											'driver_id' => Input::get('driver_id'),//MP El valor de la variable $driver_id no se valida, lo que puede derivar inyeccion SQL
																				   //MP No se valida que exista el "Driver"
											
											'status_id' => '2'
											// Up Carro    //MP Comentario no util para el codigo
											//, 'pwd' => md5(Input::get('pwd')) //MP Comentario no util para el codigo
										)
										);
			Driver::update(Input::get('driver_id'),array('available' => '0'));//MP No se valida que exista el "Driver"
			$driverTmp = Driver::find(Input::get('driver_id'));
			Service::update($id,array('car_id' => $driverTmp->car_id //MP No se valida que exista el "Driver"
									  // Up Carro //MP Comentario no util para el codigo
									  //, 'pwd' => md5(Input::get('pwd')) //MP Comentario no util para el codigo
			));
			//Notificar a usuario
			$pushMessage = 'Tu servcio ha sido confirmado!';
			//MP Comentario no util para el codigo
			/* $servicio = Service::find($id);
			   $push = Push::make();
			   if( $servicio->user->type == '1' ) // iPhone
			   {
			   	$pushAns = $push->ios($sericio->user->uuid,$pushMEssage);
			   }
			   else
			   {
			   	$pushAns = $push->android($servicio->user->uuid,$pushMessage);
			   }
			*/
			$servicio = Service::find($id); //MP Se consulta de nuevo el servicio sin ser necesario
		    $push = Push::make();
		    if( $servicio->user->uuid == '' )
		    {
		   	  	return Response::json(array('error' => '0'));
		    }
		    
		    //MP Esta logica es mejor dejarla en una funcion distinta
		    if( $servicio->user->type == '1' ) // iPhone
		    {
		    	//MP No hace uso de la variable result la cual puede posiblemente indicar un error  
		   	    $result = $push->ios($sericio->user->uuid,$pushMEssage,1,'honk.wav','Open',array('serviceId' => $servicio->id));
		    }
		    //MP Se asume que siempre que el type sea distinto de 1 es notificacion android lo cual puede no ser cierto		    
		    else
		    {
			    //MP No hace uso de la variable result la cual puede posiblemente indicar un error
		    	$result = $push->android2($sericio->user->uuid,$pushMEssage,1,'default','Open',array('serviceId' => $servicio->id));
		    }
		    		    
		    return Response::json(array('error' => '0')) //MP El codigo de error no claro
		}
		else
		{
			return Response::json(array('error' => '1')) //MP El codigo de error no claro
		}
	}
	else
	{
		return Response::json(array('error' => '3')); //MP El codigo de error no claro
	}
}

Node-path: trunk/sumatoria-cubo/WebContent/codigo-refactorizado.php.txt
Node-kind: file
Node-action: change
Text-content-md5: 5360a6762ff368ff8a5aaba9b92782e2
Text-content-sha1: e5492209596f2de8faa44128aa8c88cdd4b3c5f0
Text-content-length: 3530
Content-length: 3530

// A continuacion se listan los ajustes realizados al codigo para eliminar malas practivas
// 1. Se elimina codigo comentariado obsoleto
// 2. Se deja solo comentarios nuevos indicando los cambios o mejoras
// 3. Se usa "estado" en lugar de "error" para indicar que la respuesta no siempre es un error
// 4. Se regresa en estado un texto para hacer mas compresible los posibles errores
// 5. Se hacen validaciones antes de hacer operaciones para:
//     - Evitar tener if anidados que hacen mas dificil leer el codigo.
//     - Evitar hacer consultas y cambios en la base de datos. 
// 6. Se valida el resultado de la operacion push
// 7. Se evita inyeccion SQL
public function post_confirm()
{
	$idServicio = Input::get('service_id'); // Se cambia el nombre de la variable de id a idServicio
	if( !is_int( $idServicio ) )            // Se valida que el valor sea un entero para evitar SQL inyection
	{
		return Response::json(array('estado' => 'ERROR_ID_SERVICIO_NO_NUMERICO'));
	}
	
	$idDriver = Input::get('driver_id');
	if( !is_int( $idDriver ) )            // Se valida que el valor sea un entero para evitar SQL inyection
	{
		return Response::json(array('estado' => 'ERROR_ID_DRIVER_NO_NUMERICO'));
	}
	
	$servicio = Service::find($idServicio);
	// Se hacen validaciones antes de hacer operaciones
	if($servicio == NULL)
	{
		return Response::json(array('estado' => 'ERROR_SERVICIO_NO_EXISTE'));
	}	
	if( $servicio->status_id == '6' )
	{
		return Response::json(array('estado' => 'ERROR_ESTADO_SERVICIO_INVALIDO'));
	}	
	if( $servicio->driver_id != NULL )
	{
		return Response::json(array('estado' => 'ERROR_SERVICIO_TIENE_ASIGNADO_CONDUCTOR'));
	}
	if( $servicio->status_id != '1' )
	{
		return Response::json(array('estado' => 'ERROR_ESTADO_SERVICIO_DISTINTO_1'));
	}	
	if( $servicio->user->uuid == '' )
	{
	  	return Response::json(array('estado' => 'ERROR_USUARIO_SIN_UUID'));
	}
	
	// Se consulta y valida que exista el Driver antes enviar el update de Servicio
	$driver = Driver::find($idDriver);
	if( $driver == NULL )
	{
		return Response::json(array('estado' => 'ERROR_DRIVER_NO_EXISTE'));
	}

	Service::update($idServicio, array('driver_id' => driver->driver_id,'status_id' => '2'));										
	Driver::update($idDriver,array('available' => '0'));
	// Nota: Se evita consultar de nuevo el driver ya que el car_id no ha cambiado.
	Service::update($idServicio,array('car_id' => $driver->car_id ));		    
    
	// Se deja en una nueva funcion el envio de mensajes push y se valida el resultado
	$resultadoPush = send_push($servicio,'Tu servcio ha sido confirmado!');
	if( $resultadoPush == NULL )
	{
		return Response::json(array('estado' => 'ERROR_TIPO_DISPOSITIVO_NOTIFICACION_NO_SOPORTADO'));
	}
	else if( $resultadoPush->error == TRUE ) // Se asume que el resultado regresa un 
	{
		return Response::json(array('estado' => 'ERROR_ENVIAR_NOTIFICACION'));
	}
    
    return Response::json(array('estado' => 'OPERACION_EXITOSA'));
}

public function send_push($servicio,$pushMessage)
{
	// Se usa switch que permite codificar de mejor forma distintos casos.
	// Adicionalmente se deja un default para indicar que el tipo de dispositivo no se soporta
	$push = Push::make();
	switch ($servicio->user->type) 
	{
		case '1':
			return $push->ios($servicio->user->uuid,$pushMessage,1,'honk.wav','Open',array('serviceId' => $servicio->id));
		break;
		case '2':
			return $push->android2($servicio->user->uuid,$pushMessage,1,'default','Open',array('serviceId' => $servicio->id));
		break;
		default:
			return NULL;
	}
}

Revision-number: 26
Prop-content-length: 208
Content-length: 208

K 10
svn:author
V 6
avivas
K 8
svn:date
V 27
2016-11-30T19:10:53.210000Z
K 7
svn:log
V 106
- Se agrega validacion de disponibilidad del driver
- Se mejora comentario de error al enviar notificacion
PROPS-END

Node-path: trunk/sumatoria-cubo/WebContent/codigo-refactorizado.php.txt
Node-kind: file
Node-action: change
Text-content-md5: c3dd77c6407c53b7b551f71f0be45bc1
Text-content-sha1: cee2bc4927b7f5ec5789ff05fcc2050dd0fee6cc
Text-content-length: 3833
Content-length: 3833

// A continuacion se listan los ajustes realizados al codigo para eliminar malas practicas
// 1. Se elimina codigo comentariado obsoleto
// 2. Se deja solo comentarios nuevos indicando los cambios o mejoras
// 3. Se usa "estado" en lugar de "error" para indicar que la respuesta no siempre es un error
// 4. Se regresa en estado un texto para hacer mas compresible los posibles errores
// 5. Se hacen validaciones antes de hacer operaciones para:
//     - Evitar tener if anidados que hacen mas dificil leer el codigo.
//     - Evitar hacer consultas y cambios en la base de datos. 
// 6. Se valida el resultado de la operacion push
// 7. Se evita inyeccion SQL
public function post_confirm()
{
	$idServicio = Input::get('service_id'); // Se cambia el nombre de la variable de id a idServicio
	if( !is_int( $idServicio ) )            // Se valida que el valor sea un entero para evitar SQL inyection
	{
		return Response::json(array('estado' => 'ERROR_ID_SERVICIO_NO_NUMERICO'));
	}
	
	$idDriver = Input::get('driver_id');
	if( !is_int( $idDriver ) )            // Se valida que el valor sea un entero para evitar SQL inyection
	{
		return Response::json(array('estado' => 'ERROR_ID_DRIVER_NO_NUMERICO'));
	}
	
	$servicio = Service::find($idServicio);
	// Se hacen validaciones antes de hacer operaciones
	if($servicio == NULL)
	{
		return Response::json(array('estado' => 'ERROR_SERVICIO_NO_EXISTE'));
	}	
	if( $servicio->status_id == '6' )
	{
		return Response::json(array('estado' => 'ERROR_ESTADO_SERVICIO_INVALIDO'));
	}	
	if( $servicio->driver_id != NULL )
	{
		return Response::json(array('estado' => 'ERROR_SERVICIO_TIENE_ASIGNADO_CONDUCTOR'));
	}
	if( $servicio->status_id != '1' )
	{
		return Response::json(array('estado' => 'ERROR_ESTADO_SERVICIO_DISTINTO_1'));
	}	
	if( $servicio->user->uuid == '' )
	{
	  	return Response::json(array('estado' => 'ERROR_USUARIO_SIN_UUID'));
	}
	
	// Se consulta y valida que exista el Driver antes enviar el update de Servicio
	$driver = Driver::find($idDriver);
	if( $driver == NULL )
	{
		return Response::json(array('estado' => 'ERROR_DRIVER_NO_EXISTE'));
	}
	// Se valida que el driver este disponible, segun la logica parace ser que hace falta esta validacion
	if( $driver->available == '0' )
	{
		return Response::json(array('estado' => 'ERROR_DRIVER_NO_ESTA_DISPONIBLE'));
	}

	Service::update($idServicio, array('driver_id' => driver->driver_id,'status_id' => '2'));
	Driver::update($idDriver,array('available' => '0'));
	// Nota: Se evita consultar de nuevo el driver ya que el car_id no ha cambiado.
	Service::update($idServicio,array('car_id' => $driver->car_id ));		    
    
	// Se deja en una nueva funcion el envio de mensajes push y se valida el resultado
	$resultadoPush = send_push($servicio,'Tu servcio ha sido confirmado!');
	if( $resultadoPush == NULL )
	{
		return Response::json(array('estado' => 'ERROR_TIPO_DISPOSITIVO_NOTIFICACION_NO_SOPORTADO'));
	}
	else if( $resultadoPush->error == TRUE ) // Se asume que el resultado tiene una variable que permite verificar 
	{                                        // si sucede un error.
		return Response::json(array('estado' => 'ERROR_ENVIAR_NOTIFICACION'));
	}
    
    return Response::json(array('estado' => 'OPERACION_EXITOSA'));
}

public function send_push($servicio,$pushMessage)
{
	// Se usa switch que permite codificar de mejor forma distintos casos.
	// Adicionalmente se deja un default para indicar que el tipo de dispositivo no se soporta
	$push = Push::make();
	switch ($servicio->user->type) 
	{
		case '1':
			return $push->ios($servicio->user->uuid,$pushMessage,1,'honk.wav','Open',array('serviceId' => $servicio->id));
		break;
		case '2':
			return $push->android2($servicio->user->uuid,$pushMessage,1,'default','Open',array('serviceId' => $servicio->id));
		break;
		default:
			return NULL;
	}
}

